
// @priority 1000000000

'use strict';

/* MIT https://github.com/kenwheeler/cash */
(function(){
'use strict';var e=document,g=window,k=e.createElement("div"),l=Array.prototype,m=l.filter,n=l.indexOf,aa=l.map,q=l.push,r=l.reverse,u=l.slice,v=l.some,ba=l.splice,ca=/^#[\w-]*$/,da=/^\.[\w-]*$/,ea=/<.+>/,fa=/^\w+$/;function w(a,b){void 0===b&&(b=e);return b!==e&&1!==b.nodeType?[]:da.test(a)?b.getElementsByClassName(a.slice(1)):fa.test(a)?b.getElementsByTagName(a):b.querySelectorAll(a)}
var x=function(){function a(a,c){void 0===c&&(c=e);if(a){if(a instanceof x)return a;var b=a;if(y(a)){if(b=c instanceof x?c[0]:c,b=ca.test(a)?b.getElementById(a.slice(1)):ea.test(a)?z(a):w(a,b),!b)return}else if(A(a))return this.ready(a);if(b.nodeType||b===g)b=[b];this.length=b.length;a=0;for(c=this.length;a<c;a++)this[a]=b[a]}}a.prototype.init=function(b,c){return new a(b,c)};return a}(),B=x.prototype.init;B.fn=B.prototype=x.prototype;x.prototype.length=0;x.prototype.splice=ba;
x.prototype.get=function(a){return void 0===a?u.call(this):this[0>a?a+this.length:a]};x.prototype.eq=function(a){return B(this.get(a))};x.prototype.first=function(){return this.eq(0)};x.prototype.last=function(){return this.eq(-1)};x.prototype.map=function(a){return B(aa.call(this,function(b,c){return a.call(b,c,b)}))};x.prototype.slice=function(){return B(u.apply(this,arguments))};var ha=/-([a-z])/g;function ia(a,b){return b.toUpperCase()}function C(a){return a.replace(ha,ia)}B.camelCase=C;
function D(a,b){for(var c=0,d=a.length;c<d&&!1!==b.call(a[c],c,a[c]);c++);}B.each=D;x.prototype.each=function(a){D(this,a);return this};x.prototype.removeProp=function(a){return this.each(function(b,c){delete c[a]})};function E(a){for(var b=1;b<arguments.length;b++);b=arguments;for(var c=b.length,d=2>c?0:1;d<c;d++)for(var f in b[d])a[f]=b[d][f];return a}x.prototype.extend=function(a){return E(B.fn,a)};B.extend=E;var F=1;B.guid=F;
function G(a,b){var c=a&&(a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.msMatchesSelector||a.oMatchesSelector);return!!c&&c.call(a,b)}B.matches=G;function H(a,b,c){for(var d=[],f=0,h=a.length;f<h;f++)for(var p=a[f][b];null!=p;){d.push(p);if(!c)break;p=p[b]}return d}function A(a){return"function"===typeof a}function y(a){return"string"===typeof a}function ja(a){return!isNaN(parseFloat(a))&&isFinite(a)}var I=Array.isArray;B.isFunction=A;B.isString=y;B.isNumeric=ja;B.isArray=I;
x.prototype.prop=function(a,b){if(a){if(y(a))return 2>arguments.length?this[0]&&this[0][a]:this.each(function(c,f){f[a]=b});for(var c in a)this.prop(c,a[c]);return this}};function J(a){return y(a)?function(b,c){return G(c,a)}:A(a)?a:a instanceof x?function(b,c){return a.is(c)}:function(b,c){return c===a}}x.prototype.filter=function(a){if(!a)return B();var b=J(a);return B(m.call(this,function(a,d){return b.call(a,d,a)}))};function K(a,b){return b&&a.length?a.filter(b):a}var ka=/\S+/g;
function L(a){return y(a)?a.match(ka)||[]:[]}x.prototype.hasClass=function(a){return a&&v.call(this,function(b){return b.classList.contains(a)})};x.prototype.removeAttr=function(a){var b=L(a);return b.length?this.each(function(a,d){D(b,function(a,b){d.removeAttribute(b)})}):this};
x.prototype.attr=function(a,b){if(a){if(y(a)){if(2>arguments.length){if(!this[0])return;var c=this[0].getAttribute(a);return null===c?void 0:c}return null===b?this.removeAttr(a):this.each(function(c,f){f.setAttribute(a,b)})}for(c in a)this.attr(c,a[c]);return this}};x.prototype.toggleClass=function(a,b){var c=L(a),d=void 0!==b;return c.length?this.each(function(a,h){D(c,function(a,c){d?b?h.classList.add(c):h.classList.remove(c):h.classList.toggle(c)})}):this};
x.prototype.addClass=function(a){return this.toggleClass(a,!0)};x.prototype.removeClass=function(a){return arguments.length?this.toggleClass(a,!1):this.attr("class","")};function N(a){return 1<a.length?m.call(a,function(a,c,d){return n.call(d,a)===c}):a}B.unique=N;x.prototype.add=function(a,b){return B(N(this.get().concat(B(a,b).get())))};function O(a,b,c){if(1===a.nodeType&&b)return a=g.getComputedStyle(a,null),b?c?a.getPropertyValue(b)||void 0:a[b]:a}
function P(a,b){return parseInt(O(a,b),10)||0}var Q=/^--/,R={},la=k.style,ma=["webkit","moz","ms","o"];function na(a,b){void 0===b&&(b=Q.test(a));if(b)return a;if(!R[a]){b=C(a);var c=""+b.charAt(0).toUpperCase()+b.slice(1);b=(b+" "+ma.join(c+" ")+c).split(" ");D(b,function(b,c){if(c in la)return R[a]=c,!1})}return R[a]}B.prefixedProp=na;var oa={animationIterationCount:!0,columnCount:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0};
function pa(a,b,c){void 0===c&&(c=Q.test(a));return c||oa[a]||!ja(b)?b:b+"px"}x.prototype.css=function(a,b){if(y(a)){var c=Q.test(a);a=na(a,c);if(2>arguments.length)return this[0]&&O(this[0],a,c);if(!a)return this;b=pa(a,b,c);return this.each(function(d,h){1===h.nodeType&&(c?h.style.setProperty(a,b):h.style[a]=b)})}for(var d in a)this.css(d,a[d]);return this};var qa=/^data-(.*)/;B.hasData=function(a){return"__cashData"in a};function S(a){return a.__cashData=a.__cashData||{}}
function ra(a,b){var c=S(a);if(b){if(!(b in c)&&(a=a.dataset?a.dataset[b]||a.dataset[C(b)]:B(a).attr("data-"+b),void 0!==a)){try{a=JSON.parse(a)}catch(d){}c[b]=a}return c[b]}return c}x.prototype.data=function(a,b){var c=this;if(!a){if(!this[0])return;D(this[0].attributes,function(a,b){(a=b.name.match(qa))&&c.data(a[1])});return ra(this[0])}if(y(a))return void 0===b?this[0]&&ra(this[0],a):this.each(function(c,d){S(d)[a]=b});for(var d in a)this.data(d,a[d]);return this};
x.prototype.removeData=function(a){return this.each(function(b,c){void 0===a?delete c.__cashData:delete S(c)[a]})};function sa(a,b){return P(a,"border"+(b?"Left":"Top")+"Width")+P(a,"padding"+(b?"Left":"Top"))+P(a,"padding"+(b?"Right":"Bottom"))+P(a,"border"+(b?"Right":"Bottom")+"Width")}D(["Width","Height"],function(a,b){x.prototype["inner"+b]=function(){if(this[0])return this[0]===g?g["inner"+b]:this[0]["client"+b]}});
D(["width","height"],function(a,b){x.prototype[b]=function(c){if(!this[0])return void 0===c?void 0:this;if(!arguments.length)return this[0]===g?this[0][C("outer-"+b)]:this[0].getBoundingClientRect()[b]-sa(this[0],!a);var d=parseInt(c,10);return this.each(function(c,h){1===h.nodeType&&(c=O(h,"boxSizing"),h.style[b]=pa(b,d+("border-box"===c?sa(h,!a):0)))})}});
D(["Width","Height"],function(a,b){x.prototype["outer"+b]=function(c){if(this[0])return this[0]===g?g["outer"+b]:this[0]["offset"+b]+(c?P(this[0],"margin"+(a?"Top":"Left"))+P(this[0],"margin"+(a?"Bottom":"Right")):0)}});var T={};
x.prototype.toggle=function(a){return this.each(function(b,c){if(a=void 0!==a?a:"none"===O(c,"display")){if(c.style.display="","none"===O(c,"display")){b=c.style;c=c.tagName;if(T[c])c=T[c];else{var d=e.createElement(c);e.body.appendChild(d);var f=O(d,"display");e.body.removeChild(d);c=T[c]="none"!==f?f:"block"}b.display=c}}else c.style.display="none"})};x.prototype.hide=function(){return this.toggle(!1)};x.prototype.show=function(){return this.toggle(!0)};
function ta(a,b){return!b||!v.call(b,function(b){return 0>a.indexOf(b)})}var U={focus:"focusin",blur:"focusout"},ua={mouseenter:"mouseover",mouseleave:"mouseout"},va=/^(?:mouse|pointer|contextmenu|drag|drop|click|dblclick)/i;function wa(a,b,c,d){d.guid=d.guid||F++;var f=a.__cashEvents=a.__cashEvents||{};f[b]=f[b]||[];f[b].push([c,d]);a.addEventListener(b,d)}function V(a){a=a.split(".");return[a[0],a.slice(1).sort()]}
function W(a,b,c,d){var f=a.__cashEvents=a.__cashEvents||{};if(b)f[b]&&(f[b]=f[b].filter(function(f){var h=f[0];f=f[1];if(d&&f.guid!==d.guid||!ta(h,c))return!0;a.removeEventListener(b,f)}));else{for(b in f)W(a,b,c,d);delete a.__cashEvents}}x.prototype.off=function(a,b){var c=this;void 0===a?this.each(function(a,b){return W(b)}):D(L(a),function(a,f){a=V(ua[f]||U[f]||f);var d=a[0],p=a[1];c.each(function(a,c){return W(c,d,p,b)})});return this};
x.prototype.on=function(a,b,c,d){var f=this;if(!y(a)){for(var h in a)this.on(h,b,a[h]);return this}A(b)&&(c=b,b="");D(L(a),function(a,h){a=V(ua[h]||U[h]||h);var p=a[0],M=a[1];f.each(function(a,f){a=function za(a){if(!a.namespace||ta(M,a.namespace.split("."))){var h=f;if(b){for(var t=a.target;!G(t,b);){if(t===f)return;t=t.parentNode;if(!t)return}h=t;a.__delegate=!0}a.__delegate&&Object.defineProperty(a,"currentTarget",{configurable:!0,get:function(){return h}});t=c.call(h,a,a.data);d&&W(f,p,M,za);
!1===t&&(a.preventDefault(),a.stopPropagation())}};a.guid=c.guid=c.guid||F++;wa(f,p,M,a)})});return this};x.prototype.one=function(a,b,c){return this.on(a,b,c,!0)};x.prototype.ready=function(a){function b(){return a(B)}"loading"!==e.readyState?setTimeout(b):e.addEventListener("DOMContentLoaded",b);return this};
x.prototype.trigger=function(a,b){var c=a;if(y(a)){var d=V(a);a=d[0];d=d[1];var f=va.test(a)?"MouseEvents":"HTMLEvents";c=e.createEvent(f);c.initEvent(a,!0,!0);c.namespace=d.join(".")}c.data=b;var h=c.type in U;return this.each(function(a,b){if(h&&A(b[c.type]))b[c.type]();else b.dispatchEvent(c)})};function xa(a){return a.multiple?H(m.call(a.options,function(a){return a.selected&&!a.disabled&&!a.parentNode.disabled}),"value"):a.value||""}var ya=/%20/g,Aa=/file|reset|submit|button|image/i,Ba=/radio|checkbox/i;
x.prototype.serialize=function(){var a="";this.each(function(b,c){D(c.elements||[c],function(b,c){c.disabled||!c.name||"FIELDSET"===c.tagName||Aa.test(c.type)||Ba.test(c.type)&&!c.checked||(b=xa(c),void 0!==b&&(b=I(b)?b:[b],D(b,function(b,d){b=a;d="&"+encodeURIComponent(c.name)+"="+encodeURIComponent(d).replace(ya,"+");a=b+d})))})});return a.substr(1)};
x.prototype.val=function(a){return void 0===a?this[0]&&xa(this[0]):this.each(function(b,c){if("SELECT"===c.tagName){var d=I(a)?a:null===a?[]:[a];D(c.options,function(a,b){b.selected=0<=d.indexOf(b.value)})}else c.value=null===a?"":a})};x.prototype.clone=function(){return this.map(function(a,b){return b.cloneNode(!0)})};x.prototype.detach=function(){return this.each(function(a,b){b.parentNode&&b.parentNode.removeChild(b)})};var Ca=/^\s*<(\w+)[^>]*>/,Da=/^\s*<(\w+)\s*\/?>(?:<\/\1>)?\s*$/,X;
function z(a){if(!X){var b=e.createElement("table"),c=e.createElement("tr");X={"*":k,tr:e.createElement("tbody"),td:c,th:c,thead:b,tbody:b,tfoot:b}}if(!y(a))return[];if(Da.test(a))return[e.createElement(RegExp.$1)];b=Ca.test(a)&&RegExp.$1;b=X[b]||X["*"];b.innerHTML=a;return B(b.childNodes).detach().get()}B.parseHTML=z;x.prototype.empty=function(){var a=this[0];if(a)for(;a.firstChild;)a.removeChild(a.firstChild);return this};
x.prototype.html=function(a){return void 0===a?this[0]&&this[0].innerHTML:this.each(function(b,c){c.innerHTML=a})};x.prototype.remove=function(){return this.detach().off()};x.prototype.text=function(a){return void 0===a?this[0]?this[0].textContent:"":this.each(function(b,c){c.textContent=a})};x.prototype.unwrap=function(){this.parent().each(function(a,b){a=B(b);a.replaceWith(a.children())});return this};var Ea=e.documentElement;
x.prototype.offset=function(){var a=this[0];if(a)return a=a.getBoundingClientRect(),{top:a.top+g.pageYOffset-Ea.clientTop,left:a.left+g.pageXOffset-Ea.clientLeft}};x.prototype.offsetParent=function(){return B(this[0]&&this[0].offsetParent)};x.prototype.position=function(){var a=this[0];if(a)return{left:a.offsetLeft,top:a.offsetTop}};x.prototype.children=function(a){var b=[];this.each(function(a,d){q.apply(b,d.children)});return K(B(N(b)),a)};
x.prototype.contents=function(){var a=[];this.each(function(b,c){q.apply(a,"IFRAME"===c.tagName?[c.contentDocument]:c.childNodes)});return B(N(a))};x.prototype.find=function(a){for(var b=[],c=0,d=this.length;c<d;c++){var f=w(a,this[c]);f.length&&q.apply(b,f)}return B(N(b))};var Fa=/^$|^module$|\/(?:java|ecma)script/i,Ga=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
function Y(a){a=B(a);a.filter("script").add(a.find("script")).each(function(a,c){!c.src&&Fa.test(c.type)&&c.ownerDocument.documentElement.contains(c)&&eval(c.textContent.replace(Ga,""))})}function Z(a,b,c){D(a,function(a,f){D(b,function(b,d){b=a?d.cloneNode(!0):d;c?f.insertBefore(b,c&&f.firstChild):f.appendChild(b);Y(b)})})}x.prototype.append=function(){var a=this;D(arguments,function(b,c){Z(a,B(c))});return this};x.prototype.appendTo=function(a){Z(B(a),this);return this};
x.prototype.insertAfter=function(a){var b=this;B(a).each(function(a,d){var c=d.parentNode;c&&b.each(function(b,f){b=a?f.cloneNode(!0):f;c.insertBefore(b,d.nextSibling);Y(b)})});return this};x.prototype.after=function(){var a=this;D(r.apply(arguments),function(b,c){r.apply(B(c).slice()).insertAfter(a)});return this};x.prototype.insertBefore=function(a){var b=this;B(a).each(function(a,d){var c=d.parentNode;c&&b.each(function(b,f){b=a?f.cloneNode(!0):f;c.insertBefore(b,d);Y(b)})});return this};
x.prototype.before=function(){var a=this;D(arguments,function(b,c){B(c).insertBefore(a)});return this};x.prototype.prepend=function(){var a=this;D(arguments,function(b,c){Z(a,B(c),!0)});return this};x.prototype.prependTo=function(a){Z(B(a),r.apply(this.slice()),!0);return this};x.prototype.replaceWith=function(a){return this.before(a).remove()};x.prototype.replaceAll=function(a){B(a).replaceWith(this);return this};
x.prototype.wrapAll=function(a){if(this[0]){a=B(a);this.first().before(a);for(a=a[0];a.children.length;)a=a.firstElementChild;this.appendTo(a)}return this};x.prototype.wrap=function(a){return this.each(function(b,c){var d=B(a)[0];B(c).wrapAll(b?d.cloneNode(!0):d)})};x.prototype.wrapInner=function(a){return this.each(function(b,c){b=B(c);c=b.contents();c.length?c.wrapAll(a):b.append(a)})};
x.prototype.has=function(a){var b=y(a)?function(b,d){return!!w(a,d).length}:function(b,d){return d.contains(a)};return this.filter(b)};x.prototype.is=function(a){if(!a||!this[0])return!1;var b=J(a),c=!1;this.each(function(a,f){c=b.call(f,a,f);return!c});return c};x.prototype.next=function(a,b){return K(B(N(H(this,"nextElementSibling",b))),a)};x.prototype.nextAll=function(a){return this.next(a,!0)};
x.prototype.not=function(a){if(!a||!this[0])return this;var b=J(a);return this.filter(function(a,d){return!b.call(d,a,d)})};x.prototype.parent=function(a){return K(B(N(H(this,"parentNode"))),a)};x.prototype.index=function(a){var b=a?B(a)[0]:this[0];a=a?this:B(b).parent().children();return n.call(a,b)};x.prototype.closest=function(a){if(!a||!this[0])return B();var b=this.filter(a);return b.length?b:this.parent().closest(a)};
x.prototype.parents=function(a){return K(B(N(H(this,"parentElement",!0))),a)};x.prototype.prev=function(a,b){return K(B(N(H(this,"previousElementSibling",b))),a)};x.prototype.prevAll=function(a){return this.prev(a,!0)};x.prototype.siblings=function(a){var b=this[0];return K(this.parent().children().filter(function(a,d){return d!==b}),a)};"undefined"!==typeof exports?module.exports=B:g.cash=g.$=B;
})();


window.cash = window.$ = module.exports;


// @optional ./vendor/cash.js
// @optional ./vendor/jquery.js

(function () {

  /* JQUERY */

  window.$ = window.jQuery || window.$;

}());


// @require ../init.js

(function ( $ ) {

  /* ELEMENTS */

  $.$empty = $();

  $.$window = $(window);
  $.window = window;
  $.$document = $(document);
  $.document = document;
  $.$html = $(document.documentElement);
  $.html = document.documentElement;
  $.$head = $(document.head);
  $.head = document.head;

  Object.defineProperty ( $, 'body', { // Body not avaiable yet inside `head`
    enumerable: true,
    get () {
      return document.body;
    }
  });

  let $body;

  Object.defineProperty ( $, '$body', { // Body not avaiable yet inside `head`
    enumerable: true,
    get () {
      if ( $body ) return $body;
      let body = $.body;
      if ( body ) return $body = $(body);
      return $.$empty;
    }
  });

}( window.$ ));


// @require ../init.js

(function ( $ ) {

  /* EVENT NAMESPACER */

  const eventsSeparatorRe = /[,\s]+/g;

  $.eventNamespacer = function ( events, namespace ) {

    return events.split ( eventsSeparatorRe ).map ( event => `${event}${namespace}` ).join ( ' ' );

  };

}( window.$ ));


// @require ../init.js

(function ( $ ) {

  /* EVENT XY */

  $.eventXY = function ( event, X = 'pageX', Y = 'pageY' ) {

    if ( 'originalEvent' in event ) {

      return $.eventXY ( event.originalEvent, X, Y );

    } else if ( 'changedTouches' in event && event.changedTouches.length ) {

      return {
        x: event.changedTouches[0][X],
        y: event.changedTouches[0][Y]
      };

    } else if ( 'touches' in event && event.touches.length ) {

      return {
        x: event.touches[0][X],
        y: event.touches[0][Y]
      };

    } else if ( X in event ) {

      return {
        x: event[X],
        y: event[Y]
      };

    }

  };

}( window.$ ));


// @require ../init.js

(function ( $ ) {

  /* FIND ALL */ // Like find, but can also include the root elements

  $.fn.findAll = function ( selector ) {

    const $self = this.filter ( selector ),
          $nested = this.find ( selector );

    return $self.length
             ? $nested.length
               ? $nested.add ( $self )
               : $self
             : $nested;

  };

}( window.$ ));



// @require ../init.js

(function ( $ ) {

  /* RECT */

  $.getRect = function ( node ) {

    return node === window ? $.getWindowRect () : node.getBoundingClientRect ();

  };

  $.fn.getRect = function () {

    return this.length ? $.getRect ( this[0] ) : undefined;

  };

  /* WINDOW RECT */

  $.getWindowRect = function () {

    let rect = {};

    rect.left = 0;
    rect.top = 0;
    rect.width = window.innerWidth;
    rect.height = window.innerHeight;
    rect.right = rect.width;
    rect.bottom = rect.height;

    return rect;

  };

}( window.$ ));


// @require ../init.js

(function ( $ ) {

  /* HAS ATTRIBUTE */

  $.fn.hasAttribute = function ( attr ) {

    return !!this[0] && this[0].hasAttribute ( attr );

  };

}( window.$ ));


// @require ../init.js

// It only currently works for setting

(function ( $ ) {

  /* HSL */

  $.fn.hsl = function ( h, s, l ) {

    this[0].style.backgroundColor = `hsl(${h},${s}%,${l}%)`;

    return this;

  };

}( window.$ ));


// @require ../init.js
// @require ./elements.js

(function ( $ ) {

  /* IS ATTACHED */

  $.isAttached = function ( ele ) {

    return !!ele && ( ele === $.html || $.html.contains ( ele ) );

  };

  $.fn.isAttached = function () {

    return $.isAttached ( this[0] );

  };

}( window.$ ));


// @require ../init.js

(function ( $ ) {

  /* IS DEFAULT PREVENTED */ // In order to support non-jQuery DOM libraries like cash

  $.isDefaultPrevented = function ( event ) {

    return ( 'isDefaultPrevented' in event ) ? event.isDefaultPrevented : event.defaultPrevented;

  };

}( window.$ ));


// @require ../init.js

(function ( $ ) {

  /* IS EVENT */ // Checks if a variable is an event

  $.isEvent = function ( x ) {

    return typeof x === 'object' && ( ( window.Event && x instanceof window.Event ) || ( window.CustomEvent && x instanceof window.CustomEvent ) || ( $.Event && x instanceof $.Event ) );

  };

}( window.$ ));


// @require ../init.js

(function ( $ ) {

  /* IS FOCUSED */

  $.isFocused = function ( ele ) {

    return ele === document.activeElement && ( !document.hasFocus || document.hasFocus () ) && !!( ele.type || ele.href || ~ele.tabIndex );

  };

  $.fn.isFocused = function () {

    return $.isFocused ( this[0] );

  };

}( window.$ ));


// @require ./is_focused.js

(function ( $ ) {

  /* IS EDITABLE */

  $.isEditable = function ( ele ) {

    return $(ele).is ( 'input, textarea, [contenteditable]' );

  };

  $.fn.isEditable = function () {

    return $.isEditable ( this[0] );

  };

}( window.$ ));


// @require ../init.js
// @require ./get_rect.js

(function ( $ ) {

  /* IS VISIBLE */

  $.isVisible = function ( ele, inViewport ) {

    if ( !ele || !( ele.offsetWidth || ele.offsetHeight || ele.getClientRects ().length ) ) return false;

    if ( inViewport ) {

      const rect1 = $.getRect ( ele ),
            rect2 = $.getWindowRect ();

      return !( rect2.left > rect1.right || rect2.right < rect1.left || rect2.top > rect1.bottom || rect2.bottom < rect1.top );

    }

    return true;

  };

  $.fn.isVisible = function ( inViewport ) {

    return $.isVisible ( this[0], inViewport );

  };

}( window.$ ));


// @require ../init.js

// Triggering a `remove` event, so that we can properly destroy widgets instances when their relative elements are removed

(function ( $ ) {

  /* REMOVE */

  const _remove = $.fn.remove;

  $.fn.remove = function () {

    this.trigger ( 'remove' );

    return _remove.call ( this );

  };

}( window.$ ));


// @require ../init.js
// @require ./elements.js

(function ( $ ) {

  // On mobile a `resize` event may get triggered because of the chrome of the browser

  /* RESIZE */

  let width = $.window.outerWidth,
      height = $.window.outerHeight,
      pixelRatio = $.window.devicePixelRatio || 1; // Used for more reliable zoom detection

  $.$window.on ( 'resize', (e) => {

    const newPixelRatio = $.window.devicePixelRatio || 1,
          newWidth = $.window.outerWidth;

    if ( newWidth !== width || newPixelRatio !== pixelRatio ) {

      width = newWidth;

      $.$window.trigger ( 'resize:width' );

    }

    const newHeight = $.window.outerHeight;

    if ( newHeight !== height || newPixelRatio !== pixelRatio ) {

      height = newHeight;

      $.$window.trigger ( 'resize:height' );

    }

    pixelRatio = newPixelRatio;

  });

}( window.$ ));


const lodash = require ( 'lodash' ); // Avoiding using 2 instances of lodash, improves performance

window._ = lodash.clone ( lodash );


// @require ../init.js
// @require core/jquery/init.js

(function ( _, $ ) {

  /* CLONE DEEP */ // Much smaller than lodash's implementation

  _.cloneDeep = function ( obj ) {

    if ( obj === null || typeof obj !== 'object' || _.isElement ( obj ) || _.isRegExp ( obj ) || obj instanceof $ || '__is_cloning__' in obj ) return obj;

    const dupe = obj instanceof Date ? new obj.constructor () : obj.constructor ();

    for ( let key in obj ) {

      if ( !obj.hasOwnProperty ( key ) ) continue;

      obj['__is_cloning__'] = true;

      dupe[key] = _.cloneDeep ( obj[key] );

      delete obj['__is_cloning__'];

    }

    return dupe;

  };

}( window._, window.$ ));


// @require ../init.js

(function ( _ ) {

  /* CONSTANTS */

  _.true = _.constant ( true );
  _.false = _.constant ( false );
  _.undefined = _.constant ();
  _.null = _.constant ( null );

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* CSS 2 DOM */ // Simpler alternative to `camelCase`

  _.CSS2DOM = function ( name ) {

    return name.replace ( /([a-z])-([a-z])/g, ( str, m1, m2 ) => m1 + m2.toUpperCase () ).replace ( /^-/, '' );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* DIFFERENCE */ // Much smaller than lodash's implementation

  _.difference = function ( array, ...others ) {

    return array.filter ( val => !others.some ( other => other.includes ( val ) ) );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* EXTEND */ // Much smaller than lodash's implementation

  _.extend = _.assignIn = Object.assign;

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* FIND MATCHES */

  _.findMatches = function ( str, regex ) {

    let matches = [],
        match;

    while ( match = regex.exec ( str ) ) {

      matches.push ( match );

    }

    return matches;

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* FLATTEN */ // Much smaller than lodash's implementation

  _.flatten = _.flattenDepth = function ( arr, depth = 1 ) {

    return arr.reduce ( ( a, v ) => a.concat ( depth > 1 && _.isArray ( v ) ? _.flatten ( v, depth - 1 ) : v ), [] );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* FORMAT */

  _.format = function ( msg, ...args ) {

    for ( let i = 1, l = args.length; i <= l; i++ ) {

      msg = msg.replace ( `$${i}`, args[i - 1] );

    }

    return msg;

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* IS EQUAL JSON */ // Tiny, not very robust (comparing objects depends on the order of their keys), alternative to `isEqual`

  _.isEqualJSON = function ( a, b ) {

    return a === b || JSON.stringify ( a ) === JSON.stringify ( b );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* MERGE */ // Much smaller than lodash's implementation (it's only ment to work with plain objects)

  _.merge = function ( ...objs ) {

    return objs.reduce ( ( acc, obj ) => {

      if ( _.isPlainObject ( obj ) ) {

        for ( let key in obj ) {

          if ( !obj.hasOwnProperty ( key ) ) continue;

          if ( _.isPlainObject ( obj[key] ) ) {

            if ( !acc[key] ) acc[key] = {};

            _.merge ( acc[key], obj[key] );

          } else {

            acc[key] = obj[key];

          }

        }

      }

      return acc;

    });

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* MOVE */

  _.move = function ( arr, from, to ) {

    arr.splice ( to, 0, arr.splice ( from, 1 )[0] );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* NAT SORT */

  _.natSort = _.natSortBy = function ( arr, iteratee = _.identity ) {

    return arr.sort ( ( a, b ) => iteratee ( a ) - iteratee ( b ) );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* NOW SECS */

  _.nowSecs = function () {

    return Math.floor ( _.now () / 1000 );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* OMIT */ // Much smaller than lodash's implementation

  _.omit = function ( obj, keys ) {

    return Object.keys ( obj )
             .filter ( key => !keys.includes ( key ) )
             .reduce ( ( acc, key ) => ( ( acc[key] = obj[key] ), acc ), {} );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* PICK */ // Much smaller than lodash's implementation

  _.pick = function ( obj, keys ) {

    return keys.reduce ( ( acc, curr ) => ( curr in obj && ( acc[curr] = obj[curr] ), acc ), {} );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* PROP */ // Tiny, limited (doesn't support arrays), not very fast, alternative to `get` and `set`

  _.get = function ( obj, selector, value, _isGet = true ) {

    if ( !selector ) return;

    const result = selector
                     .split ( '.' )
                     .filter ( _.identity )
                     .reduce ( ( obj, key, keyIndex, keys ) => {
                       if ( _isGet ) {
                         return obj && ( obj[key] !== undefined ? obj[key] : value );
                       } else {
                         if ( obj ) {
                           if ( keyIndex === ( keys.length - 1 ) ) {
                             return obj[key] = value;
                           } else {
                             return obj[key] || ( obj[key] = {} );
                           }
                         }
                       }
                     }, obj );

    return _isGet ? result : obj;

  };

  _.set = function ( obj, selector, value ) {
    return _.get ( obj, selector, value, false );
  }

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* REPLACE ALL */

  _.replaceAll = function ( string, pattern, replacement ) {

    let escaped = pattern.replace ( /[.*+?^${}()|[\]\\]/g, '\\$&' );

    return string.replace ( new RegExp ( escaped, 'g' ), replacement );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* ROUND CLOSER */

  _.roundCloser = function ( number, step = 1 ) {

    let left = ( number % step ),
        halfStep = step / 2;

    return number - left + ( left >= halfStep ? step : 0 );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* TEMPLATE MINIFY */ // Simple minification, useful for discarding useless text nodes

  _.templateMinify = function ( template ) {

    return template.trim ().replace ( />\n\s*</gm, '><' );

  };

}( window._ ));


// @require ../init.js
// @require ./template_minify.js

(function ( _ ) {

  /* TEMPLATE */

  if ( !_.template ) return;

  const _template = _.template;

  _.template = function ( str, options ) {

    return _template.call ( _, _.templateMinify ( str ), options );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* TEMPLATE SETTINGS */ // Default settings

  if ( !_.templateSettings ) return;

  _.templateSettings.variable = 'o';

}( window._ ));


// @require ../init.js
// @require ./now_secs.js

(function ( _ ) {

  /* TIME AGO */

  _.timeAgo = function ( timestamp ) { // Timestamp is required in seconds

    let elapsed = _.nowSecs () - timestamp,
        justNow = 5;

    let names = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second'],
        times = [31536000, 2592000, 604800, 86400, 3600, 60, 1];

    if ( elapsed < justNow ) {

      return {
        str: 'Just now',
        next: justNow - elapsed
      };

    } else {

      for ( let i = 0, l = times.length; i < l; i++ ) {

        let name = names[i],
            secs = times[i],
            number = Math.floor ( elapsed / secs );

        if ( number >= 1 ) {

          return {
            str: number + ' ' + name + ( number > 1 ? 's' : '' ) + ' ago',
            next: secs - ( elapsed - ( number * secs ) )
          };

        }

      }

    }

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* UNIQ */ // Much smaller than lodash's implementation

  _.uniq = _.uniqBy = function ( arr, iteratee = _.identity ) {

    const values = arr.map ( iteratee );

    return arr.filter ( ( entry, i ) => values.indexOf ( values[i] ) === i );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* UPPER FIRST */ // Much smaller than lodash's implementation

  _.upperFirst = function ( str ) {

    return str ? `${str[0].toUpperCase ()}${str.substring ( 1 )}` : str;

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* WAIT */

  _.wait = function ( ms ) {

    return new Promise ( resolve => setTimeout ( resolve, ms ) );

  };

}( window._ ));


// @require ../init.js

(function ( _ ) {

  /* XOR */ // Much smaller than lodash's implementation

  _.xor = function ( ...arrays ) {

    return arrays.reduce ( ( acc, arr ) => _.difference ( acc, arr ).concat ( _.difference ( arr, acc ) ), [] );

  };

}( window._ ));

/*!
 * modernizr v3.3.1
 * Build http://modernizr.com/download?-addtest-atrule-domprefixes-hasevent-mq-prefixed-prefixedcss-prefixedcssvalue-prefixes-setclasses-testallprops-testprop-teststyles-dontmin
 *
 * Copyright (c)
 *  Faruk Ates
 *  Paul Irish
 *  Alex Sexton
 *  Ryan Seddon
 *  Patrick Kettner
 *  Stu Cox
 *  Richard Herrera

 * MIT License
 */

/*
 * Modernizr tests which native CSS3 and HTML5 features are available in the
 * current UA and makes the results available to you in two ways: as properties on
 * a global `Modernizr` object, and as classes on the `<html>` element. This
 * information allows you to progressively enhance your pages with a granular level
 * of control over the experience.
*/

;(function(window, document, undefined){
  var classes = [];


  var tests = [];


  /**
   *
   * ModernizrProto is the constructor for Modernizr
   *
   * @class
   * @access public
   */

  var ModernizrProto = {
    // The current version, dummy
    _version: '3.3.1',

    // Any settings that don't work as separate modules
    // can go in here as configuration.
    _config: {
      'classPrefix': '',
      'enableClasses': true,
      'enableJSClass': false,
      'usePrefixes': true
    },

    // Queue of tests
    _q: [],

    // Stub these for people who are listening
    on: function(test, cb) {
      // I don't really think people should do this, but we can
      // safe guard it a bit.
      // -- NOTE:: this gets WAY overridden in src/addTest for actual async tests.
      // This is in case people listen to synchronous tests. I would leave it out,
      // but the code to *disallow* sync tests in the real version of this
      // function is actually larger than this.
      var self = this;
      setTimeout(function() {
        cb(self[test]);
      }, 0);
    },

    addTest: function(name, fn, options) {
      tests.push({name: name, fn: fn, options: options});
    },

    addAsyncTest: function(fn) {
      tests.push({name: null, fn: fn});
    }
  };



  // Fake some of Object.create so we can force non test results to be non "own" properties.
  var Modernizr = function() {};
  Modernizr.prototype = ModernizrProto;

  // Leak modernizr globally when you `require` it rather than force it here.
  // Overwrite name so constructor name is nicer :D
  Modernizr = new Modernizr();



  /**
   * List of property values to set for css tests. See ticket #21
   * http://git.io/vUGl4
   *
   * @memberof Modernizr
   * @name Modernizr._prefixes
   * @optionName Modernizr._prefixes
   * @optionProp prefixes
   * @access public
   * @example
   *
   * Modernizr._prefixes is the internal list of prefixes that we test against
   * inside of things like [prefixed](#modernizr-prefixed) and [prefixedCSS](#-code-modernizr-prefixedcss). It is simply
   * an array of kebab-case vendor prefixes you can use within your code.
   *
   * Some common use cases include
   *
   * Generating all possible prefixed version of a CSS property
   * ```js
   * var rule = Modernizr._prefixes.join('transform: rotate(20deg); ');
   *
   * rule === 'transform: rotate(20deg); webkit-transform: rotate(20deg); moz-transform: rotate(20deg); o-transform: rotate(20deg); ms-transform: rotate(20deg);'
   * ```
   *
   * Generating all possible prefixed version of a CSS value
   * ```js
   * rule = 'display:' +  Modernizr._prefixes.join('flex; display:') + 'flex';
   *
   * rule === 'display:flex; display:-webkit-flex; display:-moz-flex; display:-o-flex; display:-ms-flex; display:flex'
   * ```
   */

  // we use ['',''] rather than an empty array in order to allow a pattern of .`join()`ing prefixes to test
  // values in feature detects to continue to work
  var prefixes = (ModernizrProto._config.usePrefixes ? ' -webkit- -moz- -o- -ms- '.split(' ') : ['','']);

  // expose these for the plugin API. Look in the source for how to join() them against your input
  ModernizrProto._prefixes = prefixes;



  /**
   * is returns a boolean if the typeof an obj is exactly type.
   *
   * @access private
   * @function is
   * @param {*} obj - A thing we want to check the type of
   * @param {string} type - A string to compare the typeof against
   * @returns {boolean}
   */

  function is(obj, type) {
    return typeof obj === type;
  }
  ;

  /**
   * Run through all tests and detect their support in the current UA.
   *
   * @access private
   */

  function testRunner() {
    var featureNames;
    var feature;
    var aliasIdx;
    var result;
    var nameIdx;
    var featureName;
    var featureNameSplit;

    for (var featureIdx in tests) {
      if (tests.hasOwnProperty(featureIdx)) {
        featureNames = [];
        feature = tests[featureIdx];
        // run the test, throw the return value into the Modernizr,
        // then based on that boolean, define an appropriate className
        // and push it into an array of classes we'll join later.
        //
        // If there is no name, it's an 'async' test that is run,
        // but not directly added to the object. That should
        // be done with a post-run addTest call.
        if (feature.name) {
          featureNames.push(feature.name.toLowerCase());

          if (feature.options && feature.options.aliases && feature.options.aliases.length) {
            // Add all the aliases into the names list
            for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++) {
              featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());
            }
          }
        }

        // Run the test, or use the raw value if it's not a function
        result = is(feature.fn, 'function') ? feature.fn() : feature.fn;


        // Set each of the names on the Modernizr object
        for (nameIdx = 0; nameIdx < featureNames.length; nameIdx++) {
          featureName = featureNames[nameIdx];
          // Support dot properties as sub tests. We don't do checking to make sure
          // that the implied parent tests have been added. You must call them in
          // order (either in the test, or make the parent test a dependency).
          //
          // Cap it to TWO to make the logic simple and because who needs that kind of subtesting
          // hashtag famous last words
          featureNameSplit = featureName.split('.');

          if (featureNameSplit.length === 1) {
            Modernizr[featureNameSplit[0]] = result;
          } else {
            // cast to a Boolean, if not one already
            /* jshint -W053 */
            if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
              Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
            }

            Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result;
          }

          classes.push((result ? '' : 'no-') + featureNameSplit.join('-'));
        }
      }
    }
  }
  ;

  /**
   * docElement is a convenience wrapper to grab the root element of the document
   *
   * @access private
   * @returns {HTMLElement|SVGElement} The root element of the document
   */

  var docElement = document.documentElement;


  /**
   * A convenience helper to check if the document we are running in is an SVG document
   *
   * @access private
   * @returns {boolean}
   */

  var isSVG = docElement.nodeName.toLowerCase() === 'svg';


  /**
   * setClasses takes an array of class names and adds them to the root element
   *
   * @access private
   * @function setClasses
   * @param {string[]} classes - Array of class names
   */

  // Pass in an and array of class names, e.g.:
  //  ['no-webp', 'borderradius', ...]
  function setClasses(classes) {
    var className = docElement.className;
    var classPrefix = Modernizr._config.classPrefix || '';

    if (isSVG) {
      className = className.baseVal;
    }

    // Change `no-js` to `js` (independently of the `enableClasses` option)
    // Handle classPrefix on this too
    if (Modernizr._config.enableJSClass) {
      var reJS = new RegExp('(^|\\s)' + classPrefix + 'no-js(\\s|$)');
      className = className.replace(reJS, '$1' + classPrefix + 'js$2');
    }

    if (Modernizr._config.enableClasses) {
      // Add the new classes
      className += ' ' + classPrefix + classes.join(' ' + classPrefix);
      isSVG ? docElement.className.baseVal = className : docElement.className = className;
    }

  }

  ;

  /**
   * If the browsers follow the spec, then they would expose vendor-specific style as:
   *   elem.style.WebkitBorderRadius
   * instead of something like the following, which would be technically incorrect:
   *   elem.style.webkitBorderRadius

   * Webkit ghosts their properties in lowercase but Opera & Moz do not.
   * Microsoft uses a lowercase `ms` instead of the correct `Ms` in IE8+
   *   erik.eae.net/archives/2008/03/10/21.48.10/

   * More here: github.com/Modernizr/Modernizr/issues/issue/21
   *
   * @access private
   * @returns {string} The string representing the vendor-specific style properties
   */

  var omPrefixes = 'Moz O ms Webkit';


  /**
   * List of JavaScript DOM values used for tests
   *
   * @memberof Modernizr
   * @name Modernizr._domPrefixes
   * @optionName Modernizr._domPrefixes
   * @optionProp domPrefixes
   * @access public
   * @example
   *
   * Modernizr._domPrefixes is exactly the same as [_prefixes](#modernizr-_prefixes), but rather
   * than kebab-case properties, all properties are their Capitalized variant
   *
   * ```js
   * Modernizr._domPrefixes === [ "Moz", "O", "ms", "Webkit" ];
   * ```
   */

  var domPrefixes = (ModernizrProto._config.usePrefixes ? omPrefixes.toLowerCase().split(' ') : []);
  ModernizrProto._domPrefixes = domPrefixes;


  /**
   * hasOwnProp is a shim for hasOwnProperty that is needed for Safari 2.0 support
   *
   * @author kangax
   * @access private
   * @function hasOwnProp
   * @param {object} object - The object to check for a property
   * @param {string} property - The property to check for
   * @returns {boolean}
   */

  // hasOwnProperty shim by kangax needed for Safari 2.0 support
  var hasOwnProp;

  (function() {
    var _hasOwnProperty = ({}).hasOwnProperty;
    /* istanbul ignore else */
    /* we have no way of testing IE 5.5 or safari 2,
     * so just assume the else gets hit */
    if (!is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined')) {
      hasOwnProp = function(object, property) {
        return _hasOwnProperty.call(object, property);
      };
    }
    else {
      hasOwnProp = function(object, property) { /* yes, this can give false positives/negatives, but most of the time we don't care about those */
        return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
      };
    }
  })();




   // _l tracks listeners for async tests, as well as tests that execute after the initial run
  ModernizrProto._l = {};

  /**
   * Modernizr.on is a way to listen for the completion of async tests. Being
   * asynchronous, they may not finish before your scripts run. As a result you
   * will get a possibly false negative `undefined` value.
   *
   * @memberof Modernizr
   * @name Modernizr.on
   * @access public
   * @function on
   * @param {string} feature - String name of the feature detect
   * @param {function} cb - Callback function returning a Boolean - true if feature is supported, false if not
   * @example
   *
   * ```js
   * Modernizr.on('flash', function( result ) {
   *   if (result) {
   *    // the browser has flash
   *   } else {
   *     // the browser does not have flash
   *   }
   * });
   * ```
   */

  ModernizrProto.on = function(feature, cb) {
    // Create the list of listeners if it doesn't exist
    if (!this._l[feature]) {
      this._l[feature] = [];
    }

    // Push this test on to the listener list
    this._l[feature].push(cb);

    // If it's already been resolved, trigger it on next tick
    if (Modernizr.hasOwnProperty(feature)) {
      // Next Tick
      setTimeout(function() {
        Modernizr._trigger(feature, Modernizr[feature]);
      }, 0);
    }
  };

  /**
   * _trigger is the private function used to signal test completion and run any
   * callbacks registered through [Modernizr.on](#modernizr-on)
   *
   * @memberof Modernizr
   * @name Modernizr._trigger
   * @access private
   * @function _trigger
   * @param {string} feature - string name of the feature detect
   * @param {function|boolean} [res] - A feature detection function, or the boolean =
   * result of a feature detection function
   */

  ModernizrProto._trigger = function(feature, res) {
    if (!this._l[feature]) {
      return;
    }

    var cbs = this._l[feature];

    // Force async
    setTimeout(function() {
      var i, cb;
      for (i = 0; i < cbs.length; i++) {
        cb = cbs[i];
        cb(res);
      }
    }, 0);

    // Don't trigger these again
    delete this._l[feature];
  };

  /**
   * addTest allows you to define your own feature detects that are not currently
   * included in Modernizr (under the covers it's the exact same code Modernizr
   * uses for its own [feature detections](https://github.com/Modernizr/Modernizr/tree/master/feature-detects)). Just like the offical detects, the result
   * will be added onto the Modernizr object, as well as an appropriate className set on
   * the html element when configured to do so
   *
   * @memberof Modernizr
   * @name Modernizr.addTest
   * @optionName Modernizr.addTest()
   * @optionProp addTest
   * @access public
   * @function addTest
   * @param {string|object} feature - The string name of the feature detect, or an
   * object of feature detect names and test
   * @param {function|boolean} test - Function returning true if feature is supported,
   * false if not. Otherwise a boolean representing the results of a feature detection
   * @example
   *
   * The most common way of creating your own feature detects is by calling
   * `Modernizr.addTest` with a string (preferably just lowercase, without any
   * punctuation), and a function you want executed that will return a boolean result
   *
   * ```js
   * Modernizr.addTest('itsTuesday', function() {
   *  var d = new Date();
   *  return d.getDay() === 2;
   * });
   * ```
   *
   * When the above is run, it will set Modernizr.itstuesday to `true` when it is tuesday,
   * and to `false` every other day of the week. One thing to notice is that the names of
   * feature detect functions are always lowercased when added to the Modernizr object. That
   * means that `Modernizr.itsTuesday` will not exist, but `Modernizr.itstuesday` will.
   *
   *
   *  Since we only look at the returned value from any feature detection function,
   *  you do not need to actually use a function. For simple detections, just passing
   *  in a statement that will return a boolean value works just fine.
   *
   * ```js
   * Modernizr.addTest('hasJquery', 'jQuery' in window);
   * ```
   *
   * Just like before, when the above runs `Modernizr.hasjquery` will be true if
   * jQuery has been included on the page. Not using a function saves a small amount
   * of overhead for the browser, as well as making your code much more readable.
   *
   * Finally, you also have the ability to pass in an object of feature names and
   * their tests. This is handy if you want to add multiple detections in one go.
   * The keys should always be a string, and the value can be either a boolean or
   * function that returns a boolean.
   *
   * ```js
   * var detects = {
   *  'hasjquery': 'jQuery' in window,
   *  'itstuesday': function() {
   *    var d = new Date();
   *    return d.getDay() === 2;
   *  }
   * }
   *
   * Modernizr.addTest(detects);
   * ```
   *
   * There is really no difference between the first methods and this one, it is
   * just a convenience to let you write more readable code.
   */

  function addTest(feature, test) {

    if (typeof feature == 'object') {
      for (var key in feature) {
        if (hasOwnProp(feature, key)) {
          addTest(key, feature[ key ]);
        }
      }
    } else {

      feature = feature.toLowerCase();
      var featureNameSplit = feature.split('.');
      var last = Modernizr[featureNameSplit[0]];

      // Again, we don't check for parent test existence. Get that right, though.
      if (featureNameSplit.length == 2) {
        last = last[featureNameSplit[1]];
      }

      if (typeof last != 'undefined') {
        // we're going to quit if you're trying to overwrite an existing test
        // if we were to allow it, we'd do this:
        //   var re = new RegExp("\\b(no-)?" + feature + "\\b");
        //   docElement.className = docElement.className.replace( re, '' );
        // but, no rly, stuff 'em.
        return Modernizr;
      }

      test = typeof test == 'function' ? test() : test;

      // Set the value (this is the magic, right here).
      if (featureNameSplit.length == 1) {
        Modernizr[featureNameSplit[0]] = test;
      } else {
        // cast to a Boolean, if not one already
        /* jshint -W053 */
        if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
          Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
        }

        Modernizr[featureNameSplit[0]][featureNameSplit[1]] = test;
      }

      // Set a single class (either `feature` or `no-feature`)
      /* jshint -W041 */
      setClasses([(!!test && test != false ? '' : 'no-') + featureNameSplit.join('-')]);
      /* jshint +W041 */

      // Trigger the event
      Modernizr._trigger(feature, test);
    }

    return Modernizr; // allow chaining.
  }

  // After all the tests are run, add self to the Modernizr prototype
  Modernizr._q.push(function() {
    ModernizrProto.addTest = addTest;
  });




  var cssomPrefixes = (ModernizrProto._config.usePrefixes ? omPrefixes.split(' ') : []);
  ModernizrProto._cssomPrefixes = cssomPrefixes;


  /**
   * atRule returns a given CSS property at-rule (eg @keyframes), possibly in
   * some prefixed form, or false, in the case of an unsupported rule
   *
   * @memberof Modernizr
   * @name Modernizr.atRule
   * @optionName Modernizr.atRule()
   * @optionProp atRule
   * @access public
   * @function atRule
   * @param {string} prop - String name of the @-rule to test for
   * @returns {string|boolean} The string representing the (possibly prefixed)
   * valid version of the @-rule, or `false` when it is unsupported.
   * @example
   * ```js
   *  var keyframes = Modernizr.atRule('@keyframes');
   *
   *  if (keyframes) {
   *    // keyframes are supported
   *    // could be `@-webkit-keyframes` or `@keyframes`
   *  } else {
   *    // keyframes === `false`
   *  }
   * ```
   *
   */

  var atRule = function(prop) {
    var length = prefixes.length;
    var cssrule = window.CSSRule;
    var rule;

    if (typeof cssrule === 'undefined') {
      return undefined;
    }

    if (!prop) {
      return false;
    }

    // remove literal @ from beginning of provided property
    prop = prop.replace(/^@/, '');

    // CSSRules use underscores instead of dashes
    rule = prop.replace(/-/g, '_').toUpperCase() + '_RULE';

    if (rule in cssrule) {
      return '@' + prop;
    }

    for (var i = 0; i < length; i++) {
      // prefixes gives us something like -o-, and we want O_
      var prefix = prefixes[i];
      var thisRule = prefix.toUpperCase() + '_' + rule;

      if (thisRule in cssrule) {
        return '@-' + prefix.toLowerCase() + '-' + prop;
      }
    }

    return false;
  };

  ModernizrProto.atRule = atRule;



  /**
   * createElement is a convenience wrapper around document.createElement. Since we
   * use createElement all over the place, this allows for (slightly) smaller code
   * as well as abstracting away issues with creating elements in contexts other than
   * HTML documents (e.g. SVG documents).
   *
   * @access private
   * @function createElement
   * @returns {HTMLElement|SVGElement} An HTML or SVG element
   */

  function createElement() {
    if (typeof document.createElement !== 'function') {
      // This is the case in IE7, where the type of createElement is "object".
      // For this reason, we cannot call apply() as Object is not a Function.
      return document.createElement(arguments[0]);
    } else if (isSVG) {
      return document.createElementNS.call(document, 'http://www.w3.org/2000/svg', arguments[0]);
    } else {
      return document.createElement.apply(document, arguments);
    }
  }

  ;

  /**
   * Modernizr.hasEvent() detects support for a given event
   *
   * @memberof Modernizr
   * @name Modernizr.hasEvent
   * @optionName Modernizr.hasEvent()
   * @optionProp hasEvent
   * @access public
   * @function hasEvent
   * @param  {string|*} eventName - the name of an event to test for (e.g. "resize")
   * @param  {Element|string} [element=HTMLDivElement] - is the element|document|window|tagName to test on
   * @returns {boolean}
   * @example
   *  `Modernizr.hasEvent` lets you determine if the browser supports a supplied event.
   *  By default, it does this detection on a div element
   *
   * ```js
   *  hasEvent('blur') // true;
   * ```
   *
   * However, you are able to give an object as a second argument to hasEvent to
   * detect an event on something other than a div.
   *
   * ```js
   *  hasEvent('devicelight', window) // true;
   * ```
   *
   */

  var hasEvent = (function() {

    // Detect whether event support can be detected via `in`. Test on a DOM element
    // using the "blur" event b/c it should always exist. bit.ly/event-detection
    var needsFallback = !('onblur' in document.documentElement);

    function inner(eventName, element) {

      var isSupported;
      if (!eventName) { return false; }
      if (!element || typeof element === 'string') {
        element = createElement(element || 'div');
      }

      // Testing via the `in` operator is sufficient for modern browsers and IE.
      // When using `setAttribute`, IE skips "unload", WebKit skips "unload" and
      // "resize", whereas `in` "catches" those.
      eventName = 'on' + eventName;
      isSupported = eventName in element;

      // Fallback technique for old Firefox - bit.ly/event-detection
      if (!isSupported && needsFallback) {
        if (!element.setAttribute) {
          // Switch to generic element if it lacks `setAttribute`.
          // It could be the `document`, `window`, or something else.
          element = createElement('div');
        }

        element.setAttribute(eventName, '');
        isSupported = typeof element[eventName] === 'function';

        if (element[eventName] !== undefined) {
          // If property was created, "remove it" by setting value to `undefined`.
          element[eventName] = undefined;
        }
        element.removeAttribute(eventName);
      }

      return isSupported;
    }
    return inner;
  })();


  ModernizrProto.hasEvent = hasEvent;


  /**
   * prefixedCSSValue is a way test for prefixed css properties (e.g. display: -webkit-flex)
   *
   * @memberof Modernizr
   * @name Modernizr.prefixedCSSValue
   * @optionName Modernizr.prefixedCSSValue()
   * @optionProp prefixedCSSValue
   * @access public
   * @function prefixedCSSValue
   * @param {string} prop - String name of the property to test for
   * @param {string} value - String value of the non prefixed version of the value you want to test for
   * @returns {string|false} The string representing the (possibly prefixed)
   * valid version of the property, or `false` when it is unsupported.
   * @example
   *
   * `Modernizr.prefixedCSSValue` is a way test for prefixed css properties (e.g. display: -webkit-flex)
   *
   * ```js
   * Modernizr.prefixedCSSValue('background', 'linear-gradient(left, red, red)')
   * ```
   *
   */

  var prefixedCSSValue = function(prop, value) {
    var result = false;
    var elem = createElement('div');
    var style = elem.style;

    if (prop in style) {
      var i = domPrefixes.length;

      style[prop] = value;
      result = style[prop];

      while (i-- && !result) {
        style[prop] = '-' + domPrefixes[i] + '-' + value;
        result = style[prop];
      }
    }

    if (result === '') {
      result = false;
    }

    return result;
  };

  ModernizrProto.prefixedCSSValue = prefixedCSSValue;


  /**
   * cssToDOM takes a kebab-case string and converts it to camelCase
   * e.g. box-sizing -> boxSizing
   *
   * @access private
   * @function cssToDOM
   * @param {string} name - String name of kebab-case prop we want to convert
   * @returns {string} The camelCase version of the supplied name
   */

  function cssToDOM(name) {
    return name.replace(/([a-z])-([a-z])/g, function(str, m1, m2) {
      return m1 + m2.toUpperCase();
    }).replace(/^-/, '');
  }
  ;

  /**
   * domToCSS takes a camelCase string and converts it to kebab-case
   * e.g. boxSizing -> box-sizing
   *
   * @access private
   * @function domToCSS
   * @param {string} name - String name of camelCase prop we want to convert
   * @returns {string} The kebab-case version of the supplied name
   */

  function domToCSS(name) {
    return name.replace(/([A-Z])/g, function(str, m1) {
      return '-' + m1.toLowerCase();
    }).replace(/^ms-/, '-ms-');
  }
  ;

  /**
   * getBody returns the body of a document, or an element that can stand in for
   * the body if a real body does not exist
   *
   * @access private
   * @function getBody
   * @returns {HTMLElement|SVGElement} Returns the real body of a document, or an
   * artificially created element that stands in for the body
   */

  function getBody() {
    // After page load injecting a fake body doesn't work so check if body exists
    var body = document.body;

    if (!body) {
      // Can't use the real body create a fake one.
      body = createElement(isSVG ? 'svg' : 'body');
      body.fake = true;
    }

    return body;
  }

  ;

  /**
   * injectElementWithStyles injects an element with style element and some CSS rules
   *
   * @access private
   * @function injectElementWithStyles
   * @param {string} rule - String representing a css rule
   * @param {function} callback - A function that is used to test the injected element
   * @param {number} [nodes] - An integer representing the number of additional nodes you want injected
   * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes
   * @returns {boolean}
   */

  function injectElementWithStyles(rule, callback, nodes, testnames) {
    var mod = 'modernizr';
    var style;
    var ret;
    var node;
    var docOverflow;
    var div = createElement('div');
    var body = getBody();

    if (parseInt(nodes, 10)) {
      // In order not to give false positives we create a node for each test
      // This also allows the method to scale for unspecified uses
      while (nodes--) {
        node = createElement('div');
        node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
        div.appendChild(node);
      }
    }

    style = createElement('style');
    style.type = 'text/css';
    style.id = 's' + mod;

    // IE6 will false positive on some tests due to the style element inside the test div somehow interfering offsetHeight, so insert it into body or fakebody.
    // Opera will act all quirky when injecting elements in documentElement when page is served as xml, needs fakebody too. #270
    (!body.fake ? div : body).appendChild(style);
    body.appendChild(div);

    if (style.styleSheet) {
      style.styleSheet.cssText = rule;
    } else {
      style.appendChild(document.createTextNode(rule));
    }
    div.id = mod;

    if (body.fake) {
      //avoid crashing IE8, if background image is used
      body.style.background = '';
      //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
      body.style.overflow = 'hidden';
      docOverflow = docElement.style.overflow;
      docElement.style.overflow = 'hidden';
      docElement.appendChild(body);
    }

    ret = callback(div, rule);
    // If this is done after page load we don't want to remove the body so check if body exists
    if (body.fake) {
      body.parentNode.removeChild(body);
      docElement.style.overflow = docOverflow;
      // Trigger layout so kinetic scrolling isn't disabled in iOS6+
      docElement.offsetHeight;
    } else {
      div.parentNode.removeChild(div);
    }

    return !!ret;

  }

  ;

  /**
   * Modernizr.mq tests a given media query, live against the current state of the window
   * adapted from matchMedia polyfill by Scott Jehl and Paul Irish
   * gist.github.com/786768
   *
   * @memberof Modernizr
   * @name Modernizr.mq
   * @optionName Modernizr.mq()
   * @optionProp mq
   * @access public
   * @function mq
   * @param {string} mq - String of the media query we want to test
   * @returns {boolean}
   * @example
   * Modernizr.mq allows for you to programmatically check if the current browser
   * window state matches a media query.
   *
   * ```js
   *  var query = Modernizr.mq('(min-width: 900px)');
   *
   *  if (query) {
   *    // the browser window is larger than 900px
   *  }
   * ```
   *
   * Only valid media queries are supported, therefore you must always include values
   * with your media query
   *
   * ```js
   * // good
   *  Modernizr.mq('(min-width: 900px)');
   *
   * // bad
   *  Modernizr.mq('min-width');
   * ```
   *
   * If you would just like to test that media queries are supported in general, use
   *
   * ```js
   *  Modernizr.mq('only all'); // true if MQ are supported, false if not
   * ```
   *
   *
   * Note that if the browser does not support media queries (e.g. old IE) mq will
   * always return false.
   */

  var mq = (function() {
    var matchMedia = window.matchMedia || window.msMatchMedia;
    if (matchMedia) {
      return function(mq) {
        var mql = matchMedia(mq);
        return mql && mql.matches || false;
      };
    }

    return function(mq) {
      var bool = false;

      injectElementWithStyles('@media ' + mq + ' { #modernizr { position: absolute; } }', function(node) {
        bool = (window.getComputedStyle ?
                window.getComputedStyle(node, null) :
                node.currentStyle).position == 'absolute';
      });

      return bool;
    };
  })();


  ModernizrProto.mq = mq;



  /**
   * testStyles injects an element with style element and some CSS rules
   *
   * @memberof Modernizr
   * @name Modernizr.testStyles
   * @optionName Modernizr.testStyles()
   * @optionProp testStyles
   * @access public
   * @function testStyles
   * @param {string} rule - String representing a css rule
   * @param {function} callback - A function that is used to test the injected element
   * @param {number} [nodes] - An integer representing the number of additional nodes you want injected
   * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes
   * @returns {boolean}
   * @example
   *
   * `Modernizr.testStyles` takes a CSS rule and injects it onto the current page
   * along with (possibly multiple) DOM elements. This lets you check for features
   * that can not be detected by simply checking the [IDL](https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Interface_development_guide/IDL_interface_rules).
   *
   * ```js
   * Modernizr.testStyles('#modernizr { width: 9px; color: papayawhip; }', function(elem, rule) {
   *   // elem is the first DOM node in the page (by default #modernizr)
   *   // rule is the first argument you supplied - the CSS rule in string form
   *
   *   addTest('widthworks', elem.style.width === '9px')
   * });
   * ```
   *
   * If your test requires multiple nodes, you can include a third argument
   * indicating how many additional div elements to include on the page. The
   * additional nodes are injected as children of the `elem` that is returned as
   * the first argument to the callback.
   *
   * ```js
   * Modernizr.testStyles('#modernizr {width: 1px}; #modernizr2 {width: 2px}', function(elem) {
   *   document.getElementById('modernizr').style.width === '1px'; // true
   *   document.getElementById('modernizr2').style.width === '2px'; // true
   *   elem.firstChild === document.getElementById('modernizr2'); // true
   * }, 1);
   * ```
   *
   * By default, all of the additional elements have an ID of `modernizr[n]`, where
   * `n` is its index (e.g. the first additional, second overall is `#modernizr2`,
   * the second additional is `#modernizr3`, etc.).
   * If you want to have more meaningful IDs for your function, you can provide
   * them as the fourth argument, as an array of strings
   *
   * ```js
   * Modernizr.testStyles('#foo {width: 10px}; #bar {height: 20px}', function(elem) {
   *   elem.firstChild === document.getElementById('foo'); // true
   *   elem.lastChild === document.getElementById('bar'); // true
   * }, 2, ['foo', 'bar']);
   * ```
   *
   */

  var testStyles = ModernizrProto.testStyles = injectElementWithStyles;



  /**
   * contains checks to see if a string contains another string
   *
   * @access private
   * @function contains
   * @param {string} str - The string we want to check for substrings
   * @param {string} substr - The substring we want to search the first string for
   * @returns {boolean}
   */

  function contains(str, substr) {
    return !!~('' + str).indexOf(substr);
  }

  ;

  /**
   * nativeTestProps allows for us to use native feature detection functionality if available.
   * some prefixed form, or false, in the case of an unsupported rule
   *
   * @access private
   * @function nativeTestProps
   * @param {array} props - An array of property names
   * @param {string} value - A string representing the value we want to check via @supports
   * @returns {boolean|undefined} A boolean when @supports exists, undefined otherwise
   */

  // Accepts a list of property names and a single value
  // Returns `undefined` if native detection not available
  function nativeTestProps(props, value) {
    var i = props.length;
    // Start with the JS API: http://www.w3.org/TR/css3-conditional/#the-css-interface
    if ('CSS' in window && 'supports' in window.CSS) {
      // Try every prefixed variant of the property
      while (i--) {
        if (window.CSS.supports(domToCSS(props[i]), value)) {
          return true;
        }
      }
      return false;
    }
    // Otherwise fall back to at-rule (for Opera 12.x)
    else if ('CSSSupportsRule' in window) {
      // Build a condition string for every prefixed variant
      var conditionText = [];
      while (i--) {
        conditionText.push('(' + domToCSS(props[i]) + ':' + value + ')');
      }
      conditionText = conditionText.join(' or ');
      return injectElementWithStyles('@supports (' + conditionText + ') { #modernizr { position: absolute; } }', function(node) {
        return getComputedStyle(node, null).position == 'absolute';
      });
    }
    return undefined;
  }
  ;

  /**
   * fnBind is a super small [bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) polyfill.
   *
   * @access private
   * @function fnBind
   * @param {function} fn - a function you want to change `this` reference to
   * @param {object} that - the `this` you want to call the function with
   * @returns {function} The wrapped version of the supplied function
   */

  function fnBind(fn, that) {
    return function() {
      return fn.apply(that, arguments);
    };
  }

  ;

  /**
   * testDOMProps is a generic DOM property test; if a browser supports
   *   a certain property, it won't return undefined for it.
   *
   * @access private
   * @function testDOMProps
   * @param {array.<string>} props - An array of properties to test for
   * @param {object} obj - An object or Element you want to use to test the parameters again
   * @param {boolean|object} elem - An Element to bind the property lookup again. Use `false` to prevent the check
   */
  function testDOMProps(props, obj, elem) {
    var item;

    for (var i in props) {
      if (props[i] in obj) {

        // return the property name as a string
        if (elem === false) {
          return props[i];
        }

        item = obj[props[i]];

        // let's bind a function
        if (is(item, 'function')) {
          // bind to obj unless overriden
          return fnBind(item, elem || obj);
        }

        // return the unbound function or obj or value
        return item;
      }
    }
    return false;
  }

  ;

  /**
   * Create our "modernizr" element that we do most feature tests on.
   *
   * @access private
   */

  var modElem = {
    elem: createElement('modernizr')
  };

  // Clean up this element
  Modernizr._q.push(function() {
    delete modElem.elem;
  });



  var mStyle = {
    style: modElem.elem.style
  };

  // kill ref for gc, must happen before mod.elem is removed, so we unshift on to
  // the front of the queue.
  Modernizr._q.unshift(function() {
    delete mStyle.style;
  });



  // testProps is a generic CSS / DOM property test.

  // In testing support for a given CSS property, it's legit to test:
  //    `elem.style[styleName] !== undefined`
  // If the property is supported it will return an empty string,
  // if unsupported it will return undefined.

  // We'll take advantage of this quick test and skip setting a style
  // on our modernizr element, but instead just testing undefined vs
  // empty string.

  // Property names can be provided in either camelCase or kebab-case.

  function testProps(props, prefixed, value, skipValueTest) {
    skipValueTest = is(skipValueTest, 'undefined') ? false : skipValueTest;

    // Try native detect first
    if (!is(value, 'undefined')) {
      var result = nativeTestProps(props, value);
      if (!is(result, 'undefined')) {
        return result;
      }
    }

    // Otherwise do it properly
    var afterInit, i, propsLength, prop, before;

    // If we don't have a style element, that means we're running async or after
    // the core tests, so we'll need to create our own elements to use

    // inside of an SVG element, in certain browsers, the `style` element is only
    // defined for valid tags. Therefore, if `modernizr` does not have one, we
    // fall back to a less used element and hope for the best.
    var elems = ['modernizr', 'tspan'];
    while (!mStyle.style) {
      afterInit = true;
      mStyle.modElem = createElement(elems.shift());
      mStyle.style = mStyle.modElem.style;
    }

    // Delete the objects if we created them.
    function cleanElems() {
      if (afterInit) {
        delete mStyle.style;
        delete mStyle.modElem;
      }
    }

    propsLength = props.length;
    for (i = 0; i < propsLength; i++) {
      prop = props[i];
      before = mStyle.style[prop];

      if (contains(prop, '-')) {
        prop = cssToDOM(prop);
      }

      if (mStyle.style[prop] !== undefined) {

        // If value to test has been passed in, do a set-and-check test.
        // 0 (integer) is a valid property value, so check that `value` isn't
        // undefined, rather than just checking it's truthy.
        if (!skipValueTest && !is(value, 'undefined')) {

          // Needs a try catch block because of old IE. This is slow, but will
          // be avoided in most cases because `skipValueTest` will be used.
          try {
            mStyle.style[prop] = value;
          } catch (e) {}

          // If the property value has changed, we assume the value used is
          // supported. If `value` is empty string, it'll fail here (because
          // it hasn't changed), which matches how browsers have implemented
          // CSS.supports()
          if (mStyle.style[prop] != before) {
            cleanElems();
            return prefixed == 'pfx' ? prop : true;
          }
        }
        // Otherwise just return true, or the property name if this is a
        // `prefixed()` call
        else {
          cleanElems();
          return prefixed == 'pfx' ? prop : true;
        }
      }
    }
    cleanElems();
    return false;
  }

  ;

  /**
   * testProp() investigates whether a given style property is recognized
   * Property names can be provided in either camelCase or kebab-case.
   *
   * @memberof Modernizr
   * @name Modernizr.testProp
   * @access public
   * @optionName Modernizr.testProp()
   * @optionProp testProp
   * @function testProp
   * @param {string} prop - Name of the CSS property to check
   * @param {string} [value] - Name of the CSS value to check
   * @param {boolean} [useValue] - Whether or not to check the value if @supports isn't supported
   * @returns {boolean}
   * @example
   *
   * Just like [testAllProps](#modernizr-testallprops), only it does not check any vendor prefixed
   * version of the string.
   *
   * Note that the property name must be provided in camelCase (e.g. boxSizing not box-sizing)
   *
   * ```js
   * Modernizr.testProp('pointerEvents')  // true
   * ```
   *
   * You can also provide a value as an optional second argument to check if a
   * specific value is supported
   *
   * ```js
   * Modernizr.testProp('pointerEvents', 'none') // true
   * Modernizr.testProp('pointerEvents', 'penguin') // false
   * ```
   */

  var testProp = ModernizrProto.testProp = function(prop, value, useValue) {
    return testProps([prop], undefined, value, useValue);
  };


  /**
   * testPropsAll tests a list of DOM properties we want to check against.
   * We specify literally ALL possible (known and/or likely) properties on
   * the element including the non-vendor prefixed one, for forward-
   * compatibility.
   *
   * @access private
   * @function testPropsAll
   * @param {string} prop - A string of the property to test for
   * @param {string|object} [prefixed] - An object to check the prefixed properties on. Use a string to skip
   * @param {HTMLElement|SVGElement} [elem] - An element used to test the property and value against
   * @param {string} [value] - A string of a css value
   * @param {boolean} [skipValueTest] - An boolean representing if you want to test if value sticks when set
   */
  function testPropsAll(prop, prefixed, elem, value, skipValueTest) {

    var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
    props = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');

    // did they call .prefixed('boxSizing') or are we just testing a prop?
    if (is(prefixed, 'string') || is(prefixed, 'undefined')) {
      return testProps(props, prefixed, value, skipValueTest);

      // otherwise, they called .prefixed('requestAnimationFrame', window[, elem])
    } else {
      props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
      return testDOMProps(props, prefixed, elem);
    }
  }

  // Modernizr.testAllProps() investigates whether a given style property,
  // or any of its vendor-prefixed variants, is recognized
  //
  // Note that the property names must be provided in the camelCase variant.
  // Modernizr.testAllProps('boxSizing')
  ModernizrProto.testAllProps = testPropsAll;



  /**
   * prefixed returns the prefixed or nonprefixed property name variant of your input
   *
   * @memberof Modernizr
   * @name Modernizr.prefixed
   * @optionName Modernizr.prefixed()
   * @optionProp prefixed
   * @access public
   * @function prefixed
   * @param {string} prop - String name of the property to test for
   * @param {object} [obj] - An object to test for the prefixed properties on
   * @param {HTMLElement} [elem] - An element used to test specific properties against
   * @returns {string|false} The string representing the (possibly prefixed) valid
   * version of the property, or `false` when it is unsupported.
   * @example
   *
   * Modernizr.prefixed takes a string css value in the DOM style camelCase (as
   * opposed to the css style kebab-case) form and returns the (possibly prefixed)
   * version of that property that the browser actually supports.
   *
   * For example, in older Firefox...
   * ```js
   * prefixed('boxSizing')
   * ```
   * returns 'MozBoxSizing'
   *
   * In newer Firefox, as well as any other browser that support the unprefixed
   * version would simply return `boxSizing`. Any browser that does not support
   * the property at all, it will return `false`.
   *
   * By default, prefixed is checked against a DOM element. If you want to check
   * for a property on another object, just pass it as a second argument
   *
   * ```js
   * var rAF = prefixed('requestAnimationFrame', window);
   *
   * raf(function() {
   *  renderFunction();
   * })
   * ```
   *
   * Note that this will return _the actual function_ - not the name of the function.
   * If you need the actual name of the property, pass in `false` as a third argument
   *
   * ```js
   * var rAFProp = prefixed('requestAnimationFrame', window, false);
   *
   * rafProp === 'WebkitRequestAnimationFrame' // in older webkit
   * ```
   *
   * One common use case for prefixed is if you're trying to determine which transition
   * end event to bind to, you might do something like...
   * ```js
   * var transEndEventNames = {
   *     'WebkitTransition' : 'webkitTransitionEnd', * Saf 6, Android Browser
   *     'MozTransition'    : 'transitionend',       * only for FF < 15
   *     'transition'       : 'transitionend'        * IE10, Opera, Chrome, FF 15+, Saf 7+
   * };
   *
   * var transEndEventName = transEndEventNames[ Modernizr.prefixed('transition') ];
   * ```
   *
   * If you want a similar lookup, but in kebab-case, you can use [prefixedCSS](#modernizr-prefixedcss).
   */

  var prefixed = ModernizrProto.prefixed = function(prop, obj, elem) {
    if (prop.indexOf('@') === 0) {
      return atRule(prop);
    }

    if (prop.indexOf('-') != -1) {
      // Convert kebab-case to camelCase
      prop = cssToDOM(prop);
    }
    if (!obj) {
      return testPropsAll(prop, 'pfx');
    } else {
      // Testing DOM property e.g. Modernizr.prefixed('requestAnimationFrame', window) // 'mozRequestAnimationFrame'
      return testPropsAll(prop, obj, elem);
    }
  };



  /**
   * prefixedCSS is just like [prefixed](#modernizr-prefixed), but the returned values are in
   * kebab-case (e.g. `box-sizing`) rather than camelCase (boxSizing).
   *
   * @memberof Modernizr
   * @name Modernizr.prefixedCSS
   * @optionName Modernizr.prefixedCSS()
   * @optionProp prefixedCSS
   * @access public
   * @function prefixedCSS
   * @param {string} prop - String name of the property to test for
   * @returns {string|false} The string representing the (possibly prefixed)
   * valid version of the property, or `false` when it is unsupported.
   * @example
   *
   * `Modernizr.prefixedCSS` is like `Modernizr.prefixed`, but returns the result
   * in hyphenated form
   *
   * ```js
   * Modernizr.prefixedCSS('transition') // '-moz-transition' in old Firefox
   * ```
   *
   * Since it is only useful for CSS style properties, it can only be tested against
   * an HTMLElement.
   *
   * Properties can be passed as both the DOM style camelCase or CSS style kebab-case.
   */

  var prefixedCSS = ModernizrProto.prefixedCSS = function(prop) {
    var prefixedProp = prefixed(prop);
    return prefixedProp && domToCSS(prefixedProp);
  };


  /**
   * testAllProps determines whether a given CSS property is supported in the browser
   *
   * @memberof Modernizr
   * @name Modernizr.testAllProps
   * @optionName Modernizr.testAllProps()
   * @optionProp testAllProps
   * @access public
   * @function testAllProps
   * @param {string} prop - String naming the property to test (either camelCase or kebab-case)
   * @param {string} [value] - String of the value to test
   * @param {boolean} [skipValueTest=false] - Whether to skip testing that the value is supported when using non-native detection
   * @example
   *
   * testAllProps determines whether a given CSS property, in some prefixed form,
   * is supported by the browser.
   *
   * ```js
   * testAllProps('boxSizing')  // true
   * ```
   *
   * It can optionally be given a CSS value in string form to test if a property
   * value is valid
   *
   * ```js
   * testAllProps('display', 'block') // true
   * testAllProps('display', 'penguin') // false
   * ```
   *
   * A boolean can be passed as a third parameter to skip the value check when
   * native detection (@supports) isn't available.
   *
   * ```js
   * testAllProps('shapeOutside', 'content-box', true);
   * ```
   */

  function testAllProps(prop, value, skipValueTest) {
    return testPropsAll(prop, undefined, undefined, value, skipValueTest);
  }
  ModernizrProto.testAllProps = testAllProps;


  // Run each test
  testRunner();

  // Remove the "no-js" class if it exists
  setClasses(classes);

  delete ModernizrProto.addTest;
  delete ModernizrProto.addAsyncTest;

  // Run the things that are supposed to run after the tests
  for (var i = 0; i < Modernizr._q.length; i++) {
    Modernizr._q[i]();
  }

  // Leak Modernizr namespace
  window.Modernizr = Modernizr;


;

})(window, document);


// @optional ./vendor/modernizr.js

(function () { //FIXME: Pretty useless

  /* MODERNIZR */

  window.Modernizr = window.Modernizr;

}());


// @require ../init.js

(function ( Modernizr ) {

  /* CLIP PATH POLYGON */

  Modernizr.addTest ( 'clip-path-polygon', Modernizr.testAllProps ( 'clip-path', 'polygon( 0 0 )' ) );

}( window.Modernizr ));


// @require ../init.js

(function ( Modernizr ) {

  /* FLEXBOX */

  Modernizr.addTest ( 'flexbox', Modernizr.testAllProps ( 'flexBasis', '1px' ) );

}( window.Modernizr ));


// @require ../init.js

(function ( Modernizr ) {

  /* FLEXBOX LEGACY */

  Modernizr.addTest ( 'flexbox-legacy', Modernizr.testAllProps ( 'boxDirection', 'reverse' ) );

}( window.Modernizr ));


// @require ../init.js

(function ( Modernizr ) {

  /* FLEXBOX TWEENER */

  Modernizr.addTest ( 'flexbox-tweener', Modernizr.testAllProps ( 'flexAlign', 'end' ) );

}( window.Modernizr ));


// @require ../init.js

(function ( Modernizr ) {

  /* LOCAL STORAGE */

  function supportsLocalStorage () {

    const test = 'modernizr';

    try {

      localStorage.setItem ( test, test );
      localStorage.removeItem ( test );

      return true;

    } catch ( e ) {

      return false;

    }

  }

  Modernizr.addTest ( 'localstorage', supportsLocalStorage );

}( window.Modernizr ));


// @require ../init.js

(function ( Modernizr ) {

  /* POSITION STICKY */

  Modernizr.addTest ( 'position-sticky', Modernizr.testAllProps ( 'position', 'sticky' ) );

}( window.Modernizr ));


// @require ../init.js

(function ( Modernizr ) {

  /* SCROLLBAR */

  let size;

  Modernizr.testStyles ( '#modernizr {width:100px;height:100px;overflow:scroll;position:absolute;z-index:-1}', ele => size = ele.offsetWidth - ele.clientWidth ); // The absolute position ensures that the height is setted correctly (FF and IE bug)

  Modernizr.addTest ( 'overlay-scrollbars', !size );
  Modernizr.addTest ( 'scrollbar-size-' + size, true );

}( window.Modernizr ));


(function () {

  /* REQUEST ANIMATION FRAME */

  if ( window.requestAnimationFrame ) return;

  window.requestAnimationFrame = function ( callback ) {
    return setTimeout ( callback, 16 );
  };

  window.cancelAnimationFrame = function ( handle ) {
    return clearTimeout ( handle );
  };

}());


// @require ../init.js
// @require core/shims/shims/requestAnimationFrame.js

(function ( _ ) {

  /* FRAMES */

  _.frames = function ( fn ) {

    let wait, args;

    function proxy () {
      wait = false;
      fn.apply ( undefined, args );
    }

    function framed () {
      if ( wait ) return;
      wait = true;
      args = arguments;
      requestAnimationFrame ( proxy );
    }

    return framed;

  };

}( window._ ));


// @optional ./clone_deep.js
// @optional ./constants.js
// @optional ./css2dom.js
// @optional ./difference.js
// @optional ./extend.js
// @optional ./find_matches.js
// @optional ./flatten.js
// @optional ./format.js
// @optional ./frames.js
// @optional ./is_equal_json.js
// @optional ./merge.js
// @optional ./move.js
// @optional ./nat_sort.js
// @optional ./now_secs.js
// @optional ./omit.js
// @optional ./pick.js
// @optional ./prop.js
// @optional ./replace_all.js
// @optional ./round_closer.js
// @optional ./template.js
// @optional ./template_minify.js
// @optional ./template_settings.js
// @optional ./time_ago.js
// @optional ./uniq.js
// @optional ./upper_first.js
// @optional ./wait.js
// @optional ./xor.js


// @require ./init.js
// @require ./helpers/helpers.js


// @require ../init.js
// @require core/lodash/lodash.js
// @require core/shims/shims/requestAnimationFrame.js

// Pretty simple, lightweight, alternative of $.fn.animate implementing a subset of its functionalities
//FIXME: Doesn't work this css properties that don't accept pixel values

(function ( $, _ ) {

  /* DEFAULTS */

  const defaults = {
    easing: 'easeOutQuad',
    duration: 350,
    internals: {
      getProp: ( ele, prop ) => parseFloat ( getComputedStyle ( ele )[prop] ), //TODO: Precompute getComputedStyle maybe
      setProp: ( ele, prop, value ) => ele.style[prop] = `${value}px`
    },
    callbacks: {
      start: _.noop,
      tick: _.noop,
      end: _.noop
    }
  };

  /* ANIMATE */

  function animate ( eles, props, options ) {

    eles = _.castArray ( eles );
    options = _.merge ( {}, $.animate.defaults, options );

    let easing = $.animate.easings[options.easing],
        propsKeys = Object.keys ( props ),
        startTime = Date.now (),
        isStart = true,
        endedNr = 0;

    eles.forEach ( ele => {

      let startProps = {},
          deltaProps = {};

      propsKeys.forEach ( prop => {
        startProps[prop] = options.internals.getProp ( ele, prop );
        deltaProps[prop] = props[prop] - startProps[prop];
      });

      function tick () {

        /* START */

        if ( isStart ) {

          options.callbacks.start ();

          isStart = false;

        }

        /* TICK */

        let currTime = Date.now (),
            currDuration = Math.min ( options.duration, currTime - startTime );

        propsKeys.forEach ( prop => {

          let value = easing ( null, currDuration, startProps[prop], deltaProps[prop], options.duration );

          options.internals.setProp ( ele, prop, value );

        });

        options.callbacks.tick ();

        /* END */

        let isEnd = ( currDuration >= options.duration );

        if ( isEnd ) {

          endedNr += 1;

          if ( endedNr === eles.length ) {

            options.callbacks.end ();

          }

        } else {

          requestAnimationFrame ( tick );

        }

      }

      tick ();

    });

  }

  /* EASINGS */

  const easings = { // Any of the easings provided by http://gsgd.co.uk/sandbox/jquery/easing can be used
    easeInQuad ( x, t, b, c, d ) {
      return c * ( t /= d ) * t + b;
    },
    easeOutQuad ( x, t, b, c, d ) {
      return - c * ( t /= d ) * ( t - 2 ) + b;
    },
    easeInOutQuad ( x, t, b, c, d ) {
      if ( ( t /= d / 2 ) < 1 ) return c / 2 * t * t + b;
      return - c / 2 * ( ( --t ) * ( t - 2 ) - 1 ) + b;
    }
  };

  /* EXPORT */

  $.animate = animate;
  $.animate.defaults = defaults;
  $.animate.easings = easings;

}( window.$, window._ ));


// @require ./animate.js

// Alternative flavor of $.animate that by default animates props instead of css props

(function ( $, _ ) {

  /* DEFAULTS */

  const defaults = {
    internals: {
      getProp: ( ele, prop ) => parseFloat ( ele[prop] ),
      setProp: ( ele, prop, value ) => ele[prop] = value
    }
  };

  /* ANIMATE PROP */

  function animateProp ( eles, props, options ) {

    options = _.merge ( {}, $.animateProp.defaults, options );

    return $.animate ( eles, props, options );

  }

  /* EXPORT */

  $.animateProp = animateProp;
  $.animateProp.defaults = defaults;

}( window.$, window._ ));


// @require ../init.js
// @require core/lodash/lodash.js

(function ( $, _ ) {

  /* IS WIDGET */ // Checks if a variable is probably a widget //FIXME: Not very robust

  $.isWidget = function ( x ) {

    return _.isFunction ( x ) && _.isObject ( x.config ) && _.isString ( x.config.name );

  };

}( window.$, window._ ));


// @require ../init.js
// @require core/lodash/lodash.js

(function ( $, _ ) {

  /* UTILTIES */

  function parseEventName( fullName ) {
    const parts = fullName.split ( '.' );
    return [parts[0], parts.slice ( 1 ).join ( '.' )]; // [name, namespaces]
  }

  /* MAKE EVENT */ // Creates an event by name

  $.makeEvent = function ( fullName, originalEvent ) {

    let [name, namespaces] = parseEventName ( fullName ),
        event;

    if ( $.Event ) {

      event = new $.Event ( originalEvent || name );
      event.type = name;

    } else {

      event = document.createEvent ( 'HTMLEvents' );
      event.initEvent ( name, true, true );
      event.originalEvent = originalEvent;

    }

    event.namespace = namespaces;

    return event;

  };

}( window.$, window._ ));


// @require ../init.js
// @require ./animate_prop.js
// @require ./elements.js

(function ( $ ) {

  /* SCROLL */

  //TODO: Not working but probably needed, like for scrolling down a chat
  // $.fn.scrollBottom = function ( value ) {
  //
  //   if ( !this.length ) return null;
  //
  //   let height = this.innerHeight (),
  //       scrollHeight = this[0].scrollHeight || height;
  //
  //   return _.isUndefined ( value ) ? scrollHeight - height - this[0].scrollTop : this[0].scrollTop = scrollHeight - height - value;
  //
  // };
  //
  // $.fn.scrollRight = function ( value ) {
  //
  //   if ( !this.length ) return null;
  //
  //   let width = this.innerWidth (),
  //       scrollWidth = this[0].scrollWidth || width;
  //
  //   return _.isUndefined ( value ) ? scrollWidth - width - this[0].scrollLeft : this[0].scrollLeft = scrollWidth - width - value;
  //
  // };

  $.scrollTo = function ( target, ...args ) {

    let scrollTop = $(target).offset ().top,
        eles = [$.html, $.body];

    $.animateProp ( eles, { scrollTop }, ...args );

  };

  $.fn.scrollParent = function ( includeHidden ) { // Take from jQuery UI, optimized for performance

    let position = this.css ( 'position' );

    if ( position === 'fixed' ) return $.$document;

    let excludeStaticParent = ( position === 'absolute' ),
        overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
        $parents = this.parents ();

    for ( let i = 0, l = $parents.length; i < l; i++ ) {

      let $parent = $($parents[i]);

      if ( excludeStaticParent && $parent.css ( 'position' ) === 'static' ) continue;

      if ( overflowRegex.test ( $parent.css ( 'overflow' ) + $parent.css ( 'overflow-y' ) + $parent.css ( 'overflow-x' ) ) ) {

        return $parent;

      }

    }

    return $.$document;

  };

  $.hasScrollbars = function ( node, both = false ) {

    return both ? $.hasScrollbarY ( node ) && $.hasScrollbarX ( node ) : $.hasScrollbarY ( node ) || $.hasScrollbarX ( node );

  };

  $.fn.hasScrollbars = function () {

    return $.hasScrollbars ( this[0] );

  };

  $.hasScrollbarX = function ( node ) { //FIXME: Doesn't work on body

    if ( !node ) return false;

    let style = getComputedStyle ( node );

    if ( style.overflowX === 'scroll' ) return true;

    let isScrollable = node.scrollWidth > node.clientWidth;

    return isScrollable && style.overflowX === 'auto';

  };

  $.fn.hasScrollbarX = function () {

    return $.hasScrollbarX ( this[0] );

  };

  $.hasScrollbarY = function ( node ) {

    if ( !node ) return false;

    let style = getComputedStyle ( node );

    if ( style.overflowY === 'scroll' ) return true;

    let isScrollable = node.scrollHeight > node.clientHeight;

    return isScrollable && style.overflowY === 'auto';

  };

  $.fn.hasScrollbarY = function () {

    return $.hasScrollbarY ( this[0] );

  };

  $.fn.toggleScroll = function ( force = this.hasClass ( 'overflow-hidden' ), keepScrollbars ) {

    return force ? this.enableScroll () : this.disableScroll ( keepScrollbars );

  };

  $.fn.disableScroll = function ( keepScrollbars = true ) { //TODO: Implement keepScrollbars, we should prevent default scroll events behaviour

    return this.addClass ( 'overflow-hidden' );

  };

  $.fn.enableScroll = function () {

    return this.removeClass ( 'overflow-hidden' );

  };

}( window.$ ));


// @optional ./animate.js
// @optional ./animate_prop.js
// @optional ./diff.js
// @optional ./elements.js
// @optional ./event_namespacer.js
// @optional ./event_xy.js
// @optional ./find_all.js
// @optional ./get_rect.js
// @optional ./has_attribute.js
// @optional ./hsl.js
// @optional ./is_attached.js
// @optional ./is_default_prevented.js
// @optional ./is_editable.js
// @optional ./is_event.js
// @optional ./is_focused.js
// @optional ./is_visible.js
// @optional ./is_widget.js
// @optional ./make_event.js
// @optional ./remove.js
// @optional ./resize.js
// @optional ./scroll.js


// @require ./init.js
// @require ./helpers/helpers.js


// @require ../init.js
// @require core/jquery/jquery.js

(function ( Modernizr, $ ) {

  /* CLIP PATH URL */

  $(function () {

    /* SVG */

    let ns = 'http://www.w3.org/2000/svg',
        svg = document.createElementNS ( ns, 'svg' ),
        clip = document.createElementNS ( ns, 'clipPath' ),
        rect = document.createElementNS ( ns, 'rect' );

    clip.setAttribute ( 'id', 'ModernizrClipPath' );
    rect.setAttribute ( 'width', '0' );

    clip.appendChild ( rect );
    svg.appendChild ( clip );

    /* ELEMENT */

    let ele = document.createElement ( 'div' );

    ele.style.cssText = 'width:2px;height:2px;position:fixed;top:0;left:0;z-index:1000000000;opacity:0;';
    ele.style[Modernizr.prefixed ( 'clip-path' )] = 'url(#ModernizrClipPath)';

    /* APPENDING */

    document.body.appendChild ( svg );
    document.body.appendChild ( ele );

    /* CHECKING */

    let offset = ele.getBoundingClientRect (),
        supported = document.elementFromPoint ( offset.left + 1, offset.top + 1 ) !== ele;

    /* CLEANING */

    document.body.removeChild ( ele );
    document.body.removeChild ( svg );

    /* EXPORTING */

    Modernizr.addTest ( 'clip-path-url', supported );

  });

}( window.Modernizr, window.$ ));


// @optional ./clip_path_polygon.js
// @optional ./clip_path_url.js
// @optional ./flexbox.js
// @optional ./flexbox_legacy.js
// @optional ./flexbox_tweener.js
// @optional ./local_storage.js
// @optional ./position_sticky.js
// @optional ./scrollbar.js


// @require ./init.js
// @require ./tests/tests.js


// @require core/lodash/lodash.js
// @require core/modernizr/modernizr.js

(function ( _, Modernizr ) {

  /* LOCAL STORAGE */

  if ( Modernizr.localstorage ) return;

  window.localStorage = {
    key: _.null,
    removeItem: _.undefined,
    clear: _.undefined,
    getItem: _.null,
    setItem: _.undefined
  };

}( window._, window.Modernizr ));


// @optional ./localStorage.js
// @optional ./requestAnimationFrame.js


// @require ./shims/shims.js


// @optional core/polyfills/polyfills.js
// @optional core/shims/shims.js
// @require core/lodash/lodash.js
// @require core/jquery/jquery.js
// @require core/modernizr/modernizr.js

(function () {

  /* SVELTO */

  let Svelto = {

    VERSION: '1.0.0',
    ENVIRONMENT: 'development',
    DEVELOPMENT: 'development' === 'development',

    /* DEPENDENCIES */

    _: window._,
    $: window.$,
    Modernizr: window.Modernizr,

    /* NAMESPACES */

    Instances: {},
    Templates: {},
    Widgets: {}

  };

  /* EXPORT */

  window.Svelto = Svelto;

}());


// @priority 1000000
// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* DEBUG */

  window.log = console.log.bind ( console );

  const timeMarks = {};
  const timeComulatives = {};
  window.time = function ( mark = '?', cumulative = false ) {
    if ( cumulative && !timeComulatives[mark] ) {
      timeComulatives[mark] = { total: 0 };
    }
    if ( !timeMarks[mark] ) {
      timeMarks[mark] = true;
      if ( cumulative ) {
        timeComulatives[mark].start = performance.now ();
      }
      console.time ( mark );
    } else {
      if ( cumulative ) {
        timeComulatives[mark].total += performance.now () - timeComulatives[mark].start;
      }
      console.timeEnd ( mark );
      delete timeMarks[mark];
      if ( cumulative ) {
        console.log ( `${mark}: ${timeComulatives[mark].total}ms` );
      }
    }
  }

  window.hash = function ( str ) {
    let hash = 0;
    if ( !str.length ) return hash;
    for ( let i = 0, l = str.length; i < l; i++ ) {
      let char = str.charCodeAt ( i );
      hash = ( ( hash << 5 ) - hash ) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
  };

  _.debugger = function () {
    debugger;
  };

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* VARIABLES */

  let userAgent  = navigator.userAgent ? navigator.userAgent.toLowerCase () : '',
      vendor     = navigator.vendor ? navigator.vendor.toLowerCase () : '', // Fixes an IE10 bug, `navigator.vendor` it's `undefined` there
      appVersion = navigator.appVersion ? navigator.appVersion.toLowerCase () : '';

  /* CHECKS */

  let isOpera         = /^Opera\//i.test ( userAgent ) || /\x20OPR\//i.test ( userAgent ), /* Opera <= 12 || Opera >= 15 */
      isIpod          = /ipod/i.test ( userAgent ),
      isIphone        = !isIpod && /iphone/i.test ( userAgent ),
      isIpad          = /ipad/i.test ( userAgent ),
      isAndroid       = /android/i.test ( userAgent ),
      isAndroidPhone  = isAndroid && /mobile/i.test ( userAgent ),
      isAndroidTablet = isAndroid && !isAndroidPhone,
      isBlackberry    = /blackberry/i.test ( userAgent ) || /BB10/i.test ( userAgent ),
      isWindows       = /win/i.test ( appVersion ),
      isWindowsPhone  = isWindows && /phone/i.test ( userAgent ),
      isWindowsTablet = isWindows && !isWindowsPhone && /touch/i.test ( userAgent ),
      isMobile        = isIphone || isIpod || isAndroidPhone || isBlackberry || isWindowsPhone,
      isTablet        = isIpad || isAndroidTablet || isWindowsTablet;

  /* BROWSER */

  let Browser = {
    support: {
      browsers: ['chrome', 'firefox', 'edge', 'ie', 'opera', 'safari', 'uc'],
      devices: ['desktop', 'mobile', 'tablet'],
      oss: ['ios', 'android', 'blackberry', 'linux', 'mac', 'windows']
    },
    is: {
      chrome: !isOpera && /chrome|chromium/i.test ( userAgent ) && /google inc/.test ( vendor ),
      firefox: /firefox/i.test ( userAgent ),
      edge: /(edge)\/((\d+)?[\w\.]+)/i.test ( userAgent ),
      ie: /msie/i.test ( userAgent ) || 'ActiveXObject' in window, /* IE || EDGE */
      opera: isOpera,
      safari: /safari/i.test ( userAgent ) && /apple computer/i.test ( vendor ),
      uc: /ucbrowser/i.test ( userAgent ),
      iphone: isIphone,
      ipad: isIpad,
      ipod: isIpod,
      ios: isIphone || isIpad || isIpod,
      android: isAndroid,
      androidPhone: isAndroidPhone,
      androidTablet: isAndroidTablet,
      blackberry: isBlackberry,
      linux: /linux/i.test ( appVersion ),
      mac: !( isIphone || isIpad || isIpod ) && /mac/i.test ( appVersion ),
      windows: isWindows,
      windowsPhone: isWindowsPhone,
      windowsTablet: isWindowsTablet,
      mobile: isMobile,
      tablet: isTablet,
      desktop: !isMobile && !isTablet,
      online: () => navigator.onLine,
      offline: () => !navigator.onLine,
      touchDevice: 'ontouchstart' in window || ( 'DocumentTouch' in window && document instanceof window.DocumentTouch )
    }
  };

  /* EXPORT */

  Svelto.Browser = Browser;

}( Svelto.$, Svelto._, Svelto ));


// @require ../browser.js

(function ( Modernizr, Browser ) {

  /* BROWSERS */

  Browser.support.browsers.forEach ( browser => {

    Modernizr.addTest ( browser, Browser.is[browser] );

  });

}( Svelto.Modernizr, Svelto.Browser ));


// @require ../browser.js

(function ( Modernizr, Browser ) {

  /* DEVICES */

  Browser.support.devices.forEach ( device => {

    Modernizr.addTest ( device, Browser.is[device] );

  });

}( Svelto.Modernizr, Svelto.Browser ));


// @require ../browser.js

(function ( Modernizr, Browser ) {

  /* OSS */

  Browser.support.oss.forEach ( os => {

    Modernizr.addTest ( os, Browser.is[os] );

  });

}( Svelto.Modernizr, Svelto.Browser ));


// @priority 900
// @optional ./browsers.js
// @optional ./devices.js
// @optional ./oss.js


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* BREAKPOINTS */

  let Breakpoints = {
    xsmall: 'xs',
    small: 'sm',
    medium: 'md',
    large: 'lg',
    xlarge: 'xl',
    widths: {
      xsmall: 0,
      small: 512,
      medium: 768,
      large: 1024,
      xlarge: 1216
    }
  };

  /* EXPORT */

  Svelto.Breakpoints = Breakpoints;

}( Svelto.$, Svelto._, Svelto ));


// @require core/browser/browser.js
// @require core/svelto/svelto.js

(function ( $, _, Svelto, Browser ) {

  /* KEYBOARD */

  let Keyboard = {
    keys: {
      BACKSPACE: 8,
      COMMA: 188,
      DEL: 46,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESC: 27,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38
    },
    keystroke: {

      match ( event, keystroke ) {

        // `ctmd` is treated as `cmd` on Mac, and as `ctrl` elsewhere

        let specialKeys = ['ctrl', 'cmd', 'ctmd', 'alt', 'shift'],
            keys = keystroke.split ( '+' ).map ( key => key.trim ().toLowerCase () );

        if ( keys.includes ( 'ctmd' ) ) {

          if ( !Keyboard.keystroke.hasCtrlOrCmd ( event ) ) return false;

        } else {

          if ( keys.includes ( 'ctrl' ) !== event.ctrlKey ) return false;
          if ( keys.includes ( 'cmd' ) !== event.metaKey ) return false;

        }

        if ( keys.includes ( 'alt' ) !== event.altKey ) return false;
        if ( keys.includes ( 'shift' ) !== event.shiftKey ) return false;

        for ( let i = 0, l = keys.length; i < l; i++ ) {

          let key = keys[i];

          if ( !specialKeys.includes ( key ) ) {

            if ( !( event.keyCode === Keyboard.keys[key.toUpperCase ()] || String.fromCharCode ( event.keyCode ).toLowerCase () === key ) ) return false;

          }

        }

        return true;

      },

      hasCtrlOrCmd ( event ) {

        return ( !Browser.is.mac && event.ctrlKey ) || ( Browser.is.mac && event.metaKey );

      }

    }

  };

  /* EXPORT */

  Svelto.Keyboard = Keyboard;

}( Svelto.$, Svelto._, Svelto, Svelto.Browser ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* MOUSE */

  let Mouse = {
    buttons: {
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2
    },
    hasButton ( event, button, orNone = false ) {

      if ( 'originalEvent' in event ) {

        return Mouse.hasButton ( event.originalEvent, button, orNone );

      }

      return ( orNone && !('button' in event) ) || event.button === button;

    }
  };

  /* EXPORT */

  Svelto.Mouse = Mouse;

}( Svelto.$, Svelto._, Svelto ));


// @require core/browser/browser.js
// @require core/mouse/mouse.js
// @require core/svelto/svelto.js

// Basically it exists other than to provide the convinient `Pointer` global also for removing the 300ms delay on click by providing the `tap` event

(function ( $, _, Svelto, Browser, Mouse ) {

  /* VARIABLES */

  let prefix = 'spointer';

  /* POINTER */

  let Pointer = {

    /* OPTIONS */

    options: {
      events: {
        prefix,
        emulated: {
          tune: true, // Whether to fine-tune the timeout or not
          tuned: false, // Whether the timeout has been tuned or not
          timeout: 2500, // Milliseconds to wait for an emulated event
          min: 500, // Minimum fine-tuned timeout
          multiplier: 2.5 // The detected timeout will be multiplied by this
        }
      },
      tap: {
        threshold: 6 // Over this distance threshold the touch event won't be considered a tap
      },
      dbltap: {
        interval: 300 // 2 taps within this interval will trigger a dbltap event
      },
    },

    /* EVENTS */

    tap: `${prefix}tap`,
    dbltap: `${prefix}dbltap`,
    click: 'click',
    dblclick: 'dblclick',
    down: Browser.is.touchDevice ? 'touchstart mousedown' : 'mousedown',
    move: Browser.is.touchDevice ? 'touchmove mousemove' : 'mousemove',
    up: Browser.is.touchDevice ? 'touchend mouseup' : 'mouseup',
    cancel: Browser.is.touchDevice ? 'touchcancel mouseleave' : 'mouseleave',
    over: 'mouseover',
    enter: 'mouseenter',
    out: 'mouseout',
    leave: 'mouseleave',

    /* METHODS */

    isDeviceEvent ( event, device ) {
      return event.type.startsWith ( device.toLowerCase () );
    },
    isPointerEvent ( event ) {
      return Pointer.isDeviceEvent ( event, Pointer.options.events.prefix );
    },
    isMouseEvent ( event ) {
      return Pointer.isDeviceEvent ( event, 'mouse' );
    },
    isTouchEvent ( event ) {
      return Pointer.isDeviceEvent ( event, 'touch' );
    }

  };

  /* EVENTS METHODS */

  ['tap', 'dbltap'].forEach ( name => {

    $.fn[name] = function ( data, fn ) {

      return arguments.length ? this.on ( Pointer[name], null, data, fn ) : this.triggger ( name );

    };

  });

  /* ----- POINTER LOGIC ----- */

  /* VARIABLES */

  let canTouch = Browser.is.touchDevice,
      isTouch,
      delta = 0,
      skipping,
      scrolled,
      timeoutId,
      downEvent,
      emulatedTimeoutTimestamp,
      prevTapTimestamp = 0,
      dbltapTriggerable = true;

  /* HANDLERS */

  function downHandler ( event ) {

    if ( canTouch ) {

      isTouch = Pointer.isTouchEvent ( event );

      if ( isTouch ) {

        if ( !emulatedTimeoutTimestamp && Pointer.options.events.emulated.tune ) emulatedTimeoutTimestamp = Date.now ();

        scrolled = false;

        window.onscroll = scrollHandler;

        delta++;

      } else if ( delta > 0 ) {

        if ( emulatedTimeoutTimestamp && !Pointer.options.events.emulated.tuned && Pointer.options.events.emulated.tune ) {

          Pointer.options.events.emulated.timeout = Math.ceil ( Math.max ( Pointer.options.events.emulated.min, ( Date.now () - emulatedTimeoutTimestamp ) * Pointer.options.events.emulated.multiplier ) );

          Pointer.options.events.emulated.tuned = true;

        }

        skipping = true;

        delta--;

        return;

      }

      skipping = false;

    }

    downEvent = event;

  }

  function upHandler ( event ) {

    if ( skipping ) return;
    if ( !downEvent ) return;

    reset ();

    if ( isTouch && scrolled ) return;
    if ( !isTouch && !Mouse.hasButton ( event, Mouse.buttons.LEFT, true ) ) return;
    if ( downEvent.target !== event.target ) return;

    if ( isTouch ) {

      let downXY = $.eventXY ( downEvent ),
          upXY = $.eventXY ( event ),
          threshold = Pointer.options.tap.threshold;

      if ( Math.abs ( downXY.x - upXY.x ) > threshold || Math.abs ( downXY.y - upXY.y ) > threshold ) return;

    }

    let tapTimestamp = event.timeStamp || Date.now (),
        tapEvent = $.makeEvent ( Pointer.tap, event ),
        $target = $(downEvent.target);

    $target.trigger ( tapEvent );

    if ( tapTimestamp - prevTapTimestamp <= Pointer.options.dbltap.interval ) {

      if ( dbltapTriggerable ) {

        const dbltapEvent = $.makeEvent ( Pointer.dbltap, event );

        $target.trigger ( dbltapEvent );

        dbltapTriggerable = false;

      }

    } else {

      dbltapTriggerable = true;

    }

    prevTapTimestamp = tapTimestamp;

  }

  function scrollHandler () {

    scrolled = true;

    window.onscroll = null;

  }

  /* RESET */

  function reset () {

    setTimeout ( resetEvents, 0 );

    if ( isTouch ) {

      if ( !scrolled ) window.onscroll = null;

      if ( timeoutId ) clearTimeout ( timeoutId );

      timeoutId = setTimeout ( resetDelta, Pointer.options.events.emulated.timeout );

    }

  }

  function resetEvents () {

    downEvent = undefined;

  }

  function resetDelta () {

    delta = 0;

    timeoutId = false;

  }

  /* INIT */

  $.$document.on ( Pointer.down, downHandler );
  $.$document.on ( Pointer.up, upHandler );
  $.$document.on ( Pointer.cancel, reset );

  /* EXPORT */

  Svelto.Pointer = Pointer;

}( Svelto.$, Svelto._, Svelto, Svelto.Browser, Svelto.Mouse ));


// @require core/svelto/svelto.js

//TODO: Maybe rename it, `Readify` doesn't sound right
//FIXME: We actually `require` Widget, but requiring it creates a circular dependency...

(function ( $, _, Svelto ) {

  /* READIFY */

  class Readify {

    constructor () {

      this.queue = [];
      this._isReady = !!window.__svelto_readify_ready;

    }

    /* METHODS */

    get () {

      return this.queue;

    }

    add ( fn, ready = false ) {

      if ( ready || this._isReady ) {

        this.worker ( fn );

      } else {

        this.queue.push ( fn );

      }

    }

    remove ( fn ) {

      _.pull ( this.queue, fn );

    }

    isReady () {

      return this._isReady;

    }

    ready () {

      if ( this._isReady ) return;

      this._isReady = true;

      this.queue.forEach ( this.worker.bind ( this ) );

      this.queue = [];

    }

    worker ( fn ) {

      if ( $.isWidget ( fn ) ) {

        let Widget = fn,
            ready = Widget.ready || Widget.__proto__.ready || Svelto.Widget.ready, //IE10 support -- static property
            setReady = Widget._setReady || Widget.__proto__._setReady || Svelto.Widget._setReady; //IE10 support -- static property

        ready.call ( Widget, setReady.bind ( Widget ) );

      } else {

        fn ();

      }

    }

  }

  /* EXPORT */

  Svelto.Readify = new Readify ();

  /* READY */

  if ( !Svelto.Readify.isReady () ) {

    $( Svelto.Readify.ready.bind ( Svelto.Readify ) );

  }

}( Svelto.$, Svelto._, Svelto ));


// @require core/breakpoints/breakpoints.js
// @require core/readify/readify.js

(function ( $, _, Svelto, Breakpoints, Readify ) {

  /* BREAKPOINT */

  let Breakpoint = {

    /* VARIABLES */

    previous: undefined, // Previous breakpoint
    current: undefined, // Current breakpoint

    /* RESIZE */

    __resize () {

      let current = this.get ();

      if ( current === this.current ) return;

      this.previous = this.current;
      this.current = current;

      $.$window.trigger ( 'breakpoint:change' );

    },

    /* API */

    init () {

      Breakpoint.current = Breakpoint.get ();

      $.$window.on ( 'resize:width', _.frames ( Breakpoint.__resize.bind ( Breakpoint ) ) );

    },

    get () {

      this._widths = this._widths || _.natSort ( Object.values ( Breakpoints.widths ) );
      this._width2breakpoint = this._width2breakpoint || _.invert ( Breakpoints.widths );

      let width = $.window.innerWidth;

      for ( let i = 0, l = this._widths.length; i < l; i++ ) {

        if ( width >= this._widths[i] && ( i === l - 1 || width < this._widths[i+1] ) ) {

          return this._width2breakpoint[this._widths[i]];

        }

      }

    }

  };

  /* INIT */

  Breakpoint.init ();

  /* EXPORT */

  Svelto.Breakpoint = Breakpoint;

}( Svelto.$, Svelto._, Svelto, Svelto.Breakpoints, Svelto.Readify ));


// @require core/readify/readify.js
// @require core/svelto/svelto.js

// `body` is used as a fallback

(function ( $, _, Svelto, Readify ) {

  /* LAYOUT */

  Readify.add ( function () {

    $.$layout = $.$layout || $('.layout, body').first ();

  });

  $.getLayoutOf = function ( ele ) {

    if ( ele ) {

      const $ele = $(ele),
            $layout = $ele[0] === $.body ? $.$body : $ele.parent ().closest ( '.layout, body' );

      if ( $layout.length ) return $layout;

    }

    return $.$layout;

  };

}( Svelto.$, Svelto._, Svelto, Svelto.Readify ));


// @require core/readify/readify.js

// Monkey patching `history.pushState` so that it will trigger an event that we can then use to properly trigger a `route` event

(function ( $, _, Svelto, Readify, history ) {

  /* PUSH STATE */

  Readify.add ( function () {

    let pushState = history.pushState;

    history.pushState = function ( state ) {

      if ( _.isFunction ( history.onpushstate ) ) {

        history.onpushstate ({ state });

      }

      $.$window.trigger ( 'pushstate' );

      return pushState.apply ( history, arguments );

    };

  });

})( Svelto.$, Svelto._, Svelto, Svelto.Readify, window.history );


// @require core/push_state/push_state.js
// @require core/readify/readify.js

/* ROUTE */

(function ( $, _, Svelto, Readify ) {

  Readify.add ( function () {

    let previous = window.location.href.split ( '#' )[0];

    $.$window.on ( 'popstate pushstate', function () {

      setTimeout ( function () { // We need the `window.location.href` to get updated before

        let current = window.location.href.split ( '#' )[0];

        if ( current !== previous ) {

          previous = current;

          $.$window.trigger ( 'route' );

        }

      });

    });

  });

})( Svelto.$, Svelto._, Svelto, Svelto.Readify );


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* WIDGET */

  let widget = {

    new ( Widget, element, options ) {

      return new Widget ( options, element );

    },

    is ( element, Widget, loose = false ) { // `loose` controls whether we strictly require an instance of it or just a selector match

      if ( loose && Widget.config.selector && $(element).is ( Widget.config.selector ) ) return true;

      return !!widget.get ( element, Widget, undefined, false );

    },

    get ( element, Widget, options, instanciate = true ) {

      return element[`_${Widget.config.name}`] || instanciate && widget.new ( Widget, element, options );

    },

    set ( element, instance ) {

      element[`_${instance.name}`] = instance;

    },

    remove ( element, instance ) { // Both widgets and instances can be passed

      let name = $.isWidget ( instance ) ? instance.config.name : instance.name;

      delete element[`_${name}`];

    }

  }

  /* EXPORT */

  $.widget = widget;

}( Svelto.$, Svelto._, Svelto ));


// @require core/widget/helpers.js

(function ( $, _, Svelto ) {

  /* PLUGIN */

  let Plugin = {

    call ( Widget, $ele, args ) {

      let options = args[0],
          isMethodCall = ( _.isString ( options ) && options.charAt ( 0 ) !== '_' ); // Methods starting with '_' are private

      for ( let i = 0, l = $ele.length; i < l; i++ ) {

        let instance = $.widget.get ( $ele[i], Widget, options );

        if ( isMethodCall && _.isFunction ( instance[options] ) ) {

          let returnValue = args.length > 1 ? instance[options]( ...Array.prototype.slice.call ( args, 1 ) ) : instance[options]();

          if ( !_.isNil ( returnValue ) ) return returnValue;

        }

      }

      return $ele;

    },

    make ( Widget ) {

      if ( !Widget.config.plugin ) return;

      $.fn[Widget.config.name] = function () {
        return Plugin.call ( Widget, this, arguments );
      };

    },

    unmake ( Widget ) {

      if ( !Widget.config.plugin ) return;

      delete $.fn[Widget.config.name];

    }

  };

  /* EXPORT */

  Svelto.Plugin = Plugin;

}( Svelto.$, Svelto._, Svelto ));


// @require core/readify/readify.js

//FIXME: We actually `require` Widget, but requiring it creates a circular dependency...

(function ( $, _, Svelto, Readify ) {

  /* WIDGETIZE */

  class Widgetize {

    constructor () {

      this.widgetizers = {};

    }

    /* METHODS */

    get () {

      return this.widgetizers;

    }

    add ( selector, widgetizer, data, ready = false ) {

      if ( _.isObject ( selector ) ) {

        let Widget = selector;

        if ( !Widget.config.plugin || !_.isString ( Widget.config.selector ) ) return;

        let widgetize = Widget.widgetize || Widget.__proto__.widgetize || Svelto.Widget.widgetize; //IE10 support -- static property

        return this.add ( Widget.config.selector, widgetize, Widget, widgetizer );

      }

      if ( !(selector in this.widgetizers) ) {

        this.widgetizers[selector] = [];

      }

      this.widgetizers[selector].push ( [widgetizer, data] );

      if ( ready || Readify.isReady () ) {

        let $widgets = $.$html.findAll ( selector );

        this.worker ( [[widgetizer, data]], $widgets );

      }

    }

    remove ( selector, widgetizer ) {

      if ( _.isObject ( selector ) ) {

        let Widget = selector;

        if ( !Widget.config.plugin || !_.isString ( Widget.config.selector ) ) return;

        let widgetize = Widget.widgetize || Widget.__proto__.widgetize || Svelto.Widget.widgetize; //IE10 support -- static property

        return this.remove ( Widget.config.selector, widgetize );

      }

      if ( selector in this.widgetizers ) {

        if ( widgetizer ) {

          for ( let i = 0, l = this.widgetizers[selector].length; i < l; i++ ) {

            if ( this.widgetizers[selector][i][0] === widgetizer ) {

              this.widgetizers[selector].splice ( i, 1 );

            }

          }

        }

        if ( !widgetizer || !this.widgetizers[selector].length ) {

          delete this.widgetizers[selector];

        }

      }

    }

    ready () {

      this.on ( $.$body );

    }

    on ( $root ) {

      for ( let selector in this.widgetizers ) {

        if ( !this.widgetizers.hasOwnProperty ( selector ) ) continue;

        let widgetizers = this.widgetizers[selector],
            $widgets = $root.findAll ( selector );

        this.worker ( widgetizers, $widgets );

      }

    }

    worker ( widgetizers, $widgets ) {

      for ( let ei = 0, el = $widgets.length; ei < el; ei++ ) {

        const widget = $widgets[ei];

        for ( let wi = 0, wl = widgetizers.length; wi < wl; wi++ ) {

          widgetizers[wi][0] ( widget, widgetizers[wi][1] );

        }

      }

    }

  }

  /* EXPORT */

  Svelto.Widgetize = new Widgetize ();

  /* PLUGIN */

  $.fn.widgetize = function () {

    for ( let i = 0, l = this.length; i < l; i++ ) {

      if ( this[i].nodeType !== 1 ) continue; // It doesn't make sense to widgetize other type of nodes

      Svelto.Widgetize.on ( $(this[i]) );

    }

    return this;

  };

  /* READY */

  if ( !Readify.isReady () ) {

    Readify.add ( Svelto.Widgetize.ready.bind ( Svelto.Widgetize ) );

  }

}( Svelto.$, Svelto._, Svelto, Svelto.Readify ));


// @require core/plugin/plugin.js
// @require core/readify/readify.js
// @require core/widgetize/widgetize.js

(function ( $, _, Svelto, Instances, Widgets, Plugin, Readify, Widgetize ) {

  /* FACTORY */

  let Factory = {

    /* API */

    make ( Widget, config, namespace = Widgets, instances = Instances ) {

      for ( let i = 0, l = this.makers.order.length; i < l; i++ ) {

        this.makers[this.makers.order[i]]( Widget, config, namespace, instances );

      }

    },

    unmake ( Widget, namespace = Widgets, instances = Instances ) {

      for ( let i = 0, l = this.unmakers.order.length; i < l; i++ ) {

        this.unmakers[this.unmakers.order[i]]( Widget, namespace, instances );

      }

    },

    ready ( Widget, namespace = Widgets, instances = Instances ) {

      for ( let i = 0, l = this.readifiers.order.length; i < l; i++ ) {

        this.readifiers[this.readifiers.order[i]]( Widget, namespace, instances );

      }

    },

    /* MAKERS */

    makers: {

      order: ['configure', 'namespace', 'instances', 'plugin', 'ready', 'widgetize'], // The order in which the makers will be called

      configure ( Widget, config = {} ) {

        config.Name = _.upperFirst ( config.name );

        Widget.config = config;

      },

      namespace ( Widget, config, namespace ) {

        if ( !_.isObject ( namespace ) ) return;

        namespace[Widget.config.Name] = Widget;

      },

      instances ( Widget, config, namespace, instances ) {

        if ( !_.isObject ( instances ) ) return;

        instances[Widget.config.Name] = [];

      },

      plugin ( Widget ) {

        Plugin.make ( Widget );

      },

      ready ( Widget, config ) {

        const initReady = Widget._initReady || Widget.__proto__._initReady || Svelto.Widget._initReady; //IE10 support -- static property

        initReady.call ( Widget );

        Readify.add ( Widget, config.ready );

      },

      widgetize ( Widget, config ) {

        Widgetize.add ( Widget, config.ready );

      }

    },

    /* UNMAKERS */

    unmakers: {

      order: ['widgetize', 'ready', 'plugin', 'instances', 'namespace', 'configure'], // The order in which the unmakers will be called

      configure ( Widget ) {

        delete Widget.config.Name;
        delete Widget.config;

      },

      namespace ( Widget, namespace ) {

        if ( !_.isObject ( namespace ) ) return;

        delete namespace[Widget.config.Name];

      },

      instances ( Widget, namespace, instances ) {

        if ( !_.isObject ( instances ) ) return;

        instances[Widget.config.Name].forEach ( instance => instance.destroy () );

        delete instances[Widget.config.Name];

      },

      plugin ( Widget ) {

        Plugin.unmake ( Widget );

      },

      ready ( Widget ) {

        Readify.remove ( Widget );

      },

      widgetize ( Widget ) {

        Widgetize.remove ( Widget );

      }

    },

    /* READIFIERS */

    readifiers: {

      order: ['ready', 'widgetize'], // The order in which the readifiers will be called

      ready ( Widget ) {

        Factory.unmakers.ready ( Widget );

      },

      widgetize ( Widget ) { //TODO: Code duplication, look at `Widgetize.add`

        let widgetize = Widget.widgetize || Widget.__proto__.widgetize || Svelto.Widget.widgetize, //IE10 support -- static property
            $widgets = $.$html.findAll ( Widget.config.selector );

        Widgetize.worker ( [[widgetize, Widget]], $widgets );

      }

    }

  };

  /* EXPORT */

  Svelto.Factory = Factory;

}( Svelto.$, Svelto._, Svelto, Svelto.Instances, Svelto.Widgets, Svelto.Plugin, Svelto.Readify, Svelto.Widgetize ));


// @require ./helpers.js
// @require core/breakpoint/breakpoint.js
// @require core/breakpoints/breakpoints.js
// @require core/factory/factory.js
// @require core/keyboard/keyboard.js
// @require core/layout/helpers.js
// @require core/pointer/pointer.js
// @require core/route/route.js
// @require core/svelto/svelto.js

(function ( $, _, Svelto, Instances, Templates, Widgets, Factory, Pointer, Keyboard, Breakpoints, Breakpoint ) {

  /* CONFIG */

  let config = {
    name: 'widget', // The name of widget, it will be used for the the jQuery pluing `$.fn[name]` and for triggering widget events `name + ':' + event`
    plugin: false, // A boolean that defines wheter the Widget is also a jQuery plugin or not
    selector: false, // The selector used to select the website in the DOM, used for `Svelto.Widgetize`
    ready: false, // If ready `Widgetize` will be triggered right away, without waiting for `Readify.isReady ()`
    templates: { // Object containing lodash template strings
      base: false // It will be used as the constructor if no element is provided
    },
    options: {
      characters: {}, // Used to store some characters needed by the widget
      regexes: {}, // Contains the used regexes
      messages: { // Messages that the widget somewhere outputs, maybe with a `$.toast`, maybe just logs it
        error: 'An error occurred, please try again later'
      },
      attributes: {}, // Attributes used by the widget
      datas: {}, // CSS data-* names
      classes: { // CSS classes to attach inside the widget
        disabled: 'disabled', // Attached to disabled widgets
        hidden: 'hidden', // Used to hide an element
        priorityZIndex: 'priority-z-index', // Used for giving a priority z-index to an element
        layout: {
          priorityZIndex: 'layout-priority-z-index' // Used when there's an element with priority z-index
        }
      },
      selectors: {}, // Selectors to use inside the widget
      animations: {}, // Object storing all the milliseconds required for each animation to occur
      breakpoints: { // Actions to be executed at specifc breakpoints, every key/val pair should be in the form of `breakpoint-name`: `action`, where `breakpoint-name` is a key of `Breakpoints` and `action` in a defined method (e.g. `xsmall`: `close`). In addition to this every pair must be specified under one of the following keys: `up`, `down`, `only`, mimicking the respective SCSS mixins
        up: false,
        down: false,
        only: false
      },
      keyboard: true, // Enable or disable the use of the keyboard, basically disables keystrokes and other keyboard-based interaction
      keystrokes: {}, // Easy way to automatically bind keystrokes to specific methods calls. For example: `{ 'ctrl + o': 'open', Keyaboard.keys.UP: 'up' }`. You can also pass variables to the method. For example: `{ 'ctrl + o': ['open', true], Keyaboard.keys.UP: ['open', array ( 1, 2 )] }`
      callbacks: {} // Callbacks to trigger on specific events
    }
  };

  /* WIDGET */

  class Widget {

    /* WIDGETIZE */

    static widgetize ( ele, Widget ) { // Called for widgetizing an element

      $.widget.get ( ele, Widget );

    }

    /* READY */

    static ready ( done ) { // Called when the DOM is `ready`

      done ();

    }

    static isReady () {

      return !!this._ready;

    }

    static whenReady ( callback ) {

      let isReady = this.isReady || this.__proto__.isReady || Widget.isReady; //IE10 support -- static property

      if ( isReady.bind ( this )() ) {

        return callback ();

      } else {

        this._readyQueue.push ( callback );

      }

    }

    static _initReady () {

      this._ready = !!this.config.ready;
      this._readyQueue = [];

    }

    static _setReady () {

      this._ready = true;

      this._readyQueue.forEach ( callback => callback () );

      this._readyQueue = [];

    }

    /* CONSTRUCTION */

    constructor ( options, element ) {

      /* ATTACH CONFIG */

      options = _.isObject ( options ) ? options : undefined;

      _.extend ( this, this._getConfig ( options, element ) );

      /* INSTANCES */

      Instances[this.Name].push ( this );

      /* CACHE TEMPLATES */

      if ( !( this.Name in Templates ) ) {

        Templates[this.Name] = {};

        let options = { //TODO: Maybe export them
          imports: {
            Svelto,
            Templates,
            self: Templates[this.Name]
          }
        };

        for ( let template in this.templates ) {

          const source = this.templates[template];

          if ( !this.templates.hasOwnProperty ( template ) || !source ) continue;

          Templates[this.Name][template] = _.isFunction ( source ) ? source : _.template ( source, options );

        }

      }

      /* ELEMENT */

      this.$element = $( element ||  ( this.templates.base ? this._template ( 'base', this.options ) : undefined ) );
      this.element = this.$element[0];

      /* LAYOUT */

      this.$layout = $.getLayoutOf ( this.$element );
      this.layout = this.$layout[0];

      /* BINDINGS */

      this.$bindings = $.$empty;

      /* ATTACH INSTANCE */

      if ( this.element ) {

        $.widget.set ( this.element, this );

      }

      /* SET GUID / GUC */

      this.guid = $.guid++;
      this.guc = this.name + '-' + this.guid;

      /* EVENT NAMESPACE */

      this.eventNamespace = `.swns-${this.guid}`;

      /* LOCKS */

      this._locks = {};
      this._lockQueues = {};

      /* CALLBACKS */

      if ( this._make ()      === false ) return this.destroy ();
      if ( this._variables () === false ) return this.destroy ();
      if ( this._init ()      === false ) return this.destroy ();
      if ( this._events ()    === false ) return this.destroy ();

      /* BREAKPOINT */

      let {up, down, only} = this.options.breakpoints;

      if ( up || down || only ) {

        this.___breakpoint (); // It must be inited before calling `__breakpoint`, since that when `__breakpoint` gets called it may want to reset it (not inited yet) and init it again (with a result of double binding)
        this.__breakpoint ();

      }

      /* REMOVE */

      this.___remove ();

    }

    _getConfig ( options, element ) {

      /* VARIABLES */

      let config = this._getConfigInherited (),
          configs = [config];

      /* DATA OPTIONS */

      if ( element ) {

        let dataOptions = element.getAttribute ( 'data-options' );

        if ( dataOptions ) {

          configs.push ({ options: JSON.parse ( dataOptions ) });

        }

        let dataNameOptions = element.getAttribute ( `data-${config.name}-options` );

        if ( dataNameOptions ) {

          configs.push ({ options: JSON.parse ( dataNameOptions ) });

        }

      }

      /* OPTIONS */

      if ( options ) {

        configs.push ({ options });

      }

      /* CREATE OPTIONS */

      let createOptions = this._createOptions ();

      if ( createOptions ) {

        configs.push ({ options: createOptions });

      }

      /* RETURN */

      return configs.length > 1 ? _.cloneDeep ( _.merge ( {}, ...configs ) ) : _.cloneDeep ( config );

    }

    _getConfigInherited () {

      /* BASE */

      let prototype = Object.getPrototypeOf ( this ),
          constructor = prototype.constructor,
          config = constructor.config;

      if ( config._inherited ) return config;

      /* CONFIGS */

      let configs = [config];

      /* INHERITANCE CHAIN CHAIN */

      prototype = Object.getPrototypeOf ( prototype );

      while ( prototype ) {

        if ( !prototype.constructor.config ) break;

        configs.push ( prototype.constructor.config );

        prototype = Object.getPrototypeOf ( prototype );

      }

      configs.push ( {} ); // So that we merge them into a new object

      configs.reverse ();

      /* RETURN */

      config = _.merge ( ...configs );

      config._inherited = true;

      constructor.config = config;

      return config;

    }

    _createOptions () {} // Used to pass extra options

    /* DESTROY */

    destroy () {

      this._reset ();

      this._destroy ();

      _.pull ( Instances[this.Name], this );

      if ( this.element ) {

        $.widget.remove ( this.element, this );

      }

    }

    _destroy () {} // Clean the stuff, remove possible memory leaks

    /* SPECIAL */

    _make () {} // Creates the widget, if necessary
    _variables () {} // Init your variables inside this function
    _init () {} // Perform the init stuff inside this function
    _events () {} // Bind the event handlers inside this function

    _reset () { //TODO: Maybe remove or rename it, I don't like it but I currently need its functionality

      this.$bindings.off ( this.eventNamespace );

    }

    /* WIDGET */

    widget () {

      return this.$element;

    }

    /* INSTANCE */

    instance () {

      return this;

    }

    /* OPTIONS */

    // We cannot have a `options` alias to `option`, since `options` is already defined in the config

    option ( selector, value ) {

      if ( !selector ) {

        return _.cloneDeep ( this.options );

      } else if ( _.isString ( selector ) ) {

        if ( _.isUndefined ( value ) ) {

          return _.cloneDeep ( _.get ( this.options, selector ) );

        } else {

          this._setOption ( selector, value );

        }

      } else if ( _.isPlainObject ( selector ) ) {

        for ( let prop in selector ) {

          if ( !selector.hasOwnProperty ( prop ) ) continue;

          this._setOption ( selector, value );

        }

      }

    }

    _setOption ( selector, value ) {

      _.set ( this.options, selector, value );

    }

    /* ENABLED */

    enable () {

      this.$element.removeClass ( this.options.classes.disabled );

    }

    isEnabled () {

      return !this.isDisabled ();

    }

    /* DISABLED */

    disable () {

      this.$element.addClass ( this.options.classes.disabled );

    }

    isDisabled () {

      return this.$element.hasClass ( this.options.classes.disabled );

    }

    /* LOCKING */

    lock ( namespace ) {

      this._locks[namespace] = true;

    }

    unlock ( namespace ) {

      delete this._locks[namespace];

      if ( this._lockQueues[namespace] ) {

        this._lockQueues[namespace].forEach ( callback => callback () );

        delete this._lockQueues[namespace];

      }

    }

    isLocked ( namespace ) {

      return !!this._locks[namespace];

    }

    whenUnlocked ( namespace, callback ) {

      if ( !callback ) {

        callback = namespace;
        namespace = undefined;

      }

      if ( !this.isLocked ( namespace ) ) {

        callback ();

      } else {

        if ( !this._lockQueues[namespace] ) this._lockQueues[namespace] = [];

        this._lockQueues[namespace].push ( callback );

      }

    }

    /* EVENTS */

    //TODO: Add support for custom data

    _on ( suppressDisabledCheck, $element, events, selector, handler, _onlyOne ) {

      /* NORMALIZATION */

      if ( !_.isBoolean ( suppressDisabledCheck ) ) {

        _onlyOne = handler;
        handler = selector;
        selector = events;
        events = $element;
        $element = suppressDisabledCheck;
        suppressDisabledCheck = false;

      }

      if ( !( $element instanceof $ ) ) {

        _onlyOne = handler;
        handler = selector;
        selector = events;
        events = $element;
        $element = this.$element;

      }

      if ( !_.isString ( selector ) ) {

        _onlyOne = handler;
        handler = selector;
        selector = false;

      }

      /* BINDINGS */

      this.$bindings = this.$bindings.add ( $element );

      /* PROXY */

      let proxyCallback = ( event, data ) => {

        if ( !suppressDisabledCheck && this.$element.hasClass ( this.options.classes.disabled ) ) return;

        return handler.call ( this, event, data || event.data );

      };

      /* PROXY GUID */

      proxyCallback.guid = handler.guid = ( handler.guid || $.guid++ );

      /* EVENTS NAMESPACING */

      events = $.eventNamespacer ( events, this.eventNamespace );

      /* TRIGGERING */

      $element[_onlyOne ? 'one' : 'on'] ( events, selector, proxyCallback );

    }

    _one ( ...args ) {

      return this._on ( ...args, true );

    }

    _onHover ( $element, args ) {

      /* NORMALIZATION */

      if ( !args ) {

        args = $element;
        $element = this.$element;

      }

      /* BINDING */

      this._on ( $element, Pointer.enter, () => this._on ( ...args ) );
      this._on ( $element, Pointer.leave, () => this._off ( ...args ) );

    }

    //TODO: Maybe add a _offHover, is it needed?

    _off ( $element, events, handler ) {

      /* NORMALIZATION */

      if ( !handler && !($element instanceof $) ) {

        handler = events;
        events = $element;
        $element = this.$element;

      }

      /* EVENTS NAMESPACING */

      events = $.eventNamespacer ( events, this.eventNamespace );

      /* REMOVING HANDLER */

      $element.off ( events, handler );

    }

    _trigger ( type, event, data ) {

      /* NORMALIZATION */

      if ( !data ) {

        if ( $.isEvent ( event ) ) {

          data = event.data || {};

        } else {

          data = event || {};
          event = undefined;

        }

      }

      /* EVENT */

      const name = ( this.name + ':' + type ).toLowerCase ();

      event = $.makeEvent ( name, event );

      /* TRIGGERING */

      this.$element.trigger ( event, data );

      return !( this.options.callbacks[type].apply ( this.element, [event].concat ( data ) ) === false || $.isDefaultPrevented ( event ) );

    }

    /* ROUTE */

    ___route () {

      this._on ( true, $.$window, 'route', this.__route );

    }

    /* BREAKPOINT */

    ___breakpoint () {

      this._on ( true, $.$window, 'breakpoint:change', this.__breakpoint );

    }

    __breakpoint () {

      let width = Breakpoints.widths[Breakpoint.current];

      /* UP */

      if ( this.options.breakpoints.up ) {

        for ( let breakpoint in this.options.breakpoints.up ) {

          if ( !this.options.breakpoints.up.hasOwnProperty ( breakpoint ) ) continue;

          if ( width >= Breakpoints.widths[breakpoint] ) {

            this[this.options.breakpoints.up[breakpoint]]();

          }

        }

      }

      /* DOWN */

      if ( this.options.breakpoints.down ) {

        for ( let breakpoint in this.options.breakpoints.down ) {

          if ( !this.options.breakpoints.down.hasOwnProperty ( breakpoint ) ) continue;

          if ( width <= Breakpoints.widths[breakpoint] ) {

            this[this.options.breakpoints.down[breakpoint]]();

          }

        }

      }

      /* ONLY */

      if ( this.options.breakpoints.only ) {

        for ( let breakpoint in this.options.breakpoints.only ) {

          if ( !this.options.breakpoints.only.hasOwnProperty ( breakpoint ) ) continue;

          if ( width === Breakpoints.widths[breakpoint] ) {

            this[this.options.breakpoints.only[breakpoint]]();

          }

        }

      }

    }

    /* KEYDOWN */

    ___keydown () {

      this._on ( $.$document, 'keydown', this.__keydown );

    }

    __keydown ( event ) {

      if ( !this.options.keyboard ) return;

      if ( $.isEditable ( document.activeElement ) && !this.element.contains ( document.activeElement ) ) return;

      for ( let keystrokes in this.options.keystrokes ) {

        if ( !this.options.keystrokes.hasOwnProperty ( keystrokes ) ) continue;

        let keystrokesParts = keystrokes.split ( ',' );

        for ( let i = 0, l = keystrokesParts.length; i < l; i++ ) {

          let keystroke = keystrokesParts[i];

          if ( !Keyboard.keystroke.match ( event, keystroke ) ) continue;

          let toCall = this.options.keystrokes[keystrokes],
              method = _.isArray ( toCall ) ? toCall[0] : toCall,
              args   = _.isArray ( toCall ) ? _.castArray ( toCall[1] ) : [];

          if ( this[method].apply ( this, args ) !== null ) {

            event.preventDefault ();
            event.stopImmediatePropagation ();

          }

          return;

        }

      }

    }

    /* REMOVE */

    ___remove () {

      if ( this.element ) {

        this._one ( true, 'remove', this.__remove );

      }

    }

    __remove ( event ) {

      if ( !event || event.target === this.element ) {

        this.destroy ();

      }

    }

    /* DELAYING */

    _delay ( fn, delay ) {

      return setTimeout ( () => fn.apply ( this ), delay || 0 );

    }

    /* DEFER */

    _defer ( fn ) {

      return this._delay ( fn );

    }

    /* FRAME */

    _frame ( fn ) {

      return requestAnimationFrame ( fn.bind ( this ) );

    }

    /* FRAMES */

    _frames ( fn ) {

      let framed = _.frames ( fn );

      framed.guid = fn.guid = ( fn.guid || $.guid++ );

      return framed;

    }

    /* THROW */

    _throw ( msg ) {

      throw new Error ( msg );

    }

    /* THROTTLING */

    _throttle ( fn, wait, options ) {

      let throttled = _.throttle ( fn, wait, options );

      throttled.guid = fn.guid = ( fn.guid || $.guid++ );

      return throttled;

    }

    /* DEBOUNCING */

    _debounce ( fn, wait, options ) {

      let debounced = _.debounce ( fn, wait, options );

      debounced.guid = fn.guid = ( fn.guid || $.guid++ );

      return debounced;

    }

    /* TEMPLATE */

    _template ( name, options = {} ) {

      return Templates[this.Name][name] ( options );

    }

    /* INSERTION */

    before ( ...content ) {

      this.$element.before ( ...content );

    }

    insertBefore ( target ) {

      this.$element.insertBefore ( target );

    }

    after ( ...content ) {

      this.$element.after ( ...content );

    }

    insertAfter ( target ) {

      this.$element.insertAfter ( target );

    }

    prependTo ( target ) {

      this.$element.prependTo ( target );

    }

    appendTo ( target ) {

      this.$element.appendTo ( target );

    }

  }

  /* EXPORT */

  Svelto.Widget = Widget;

  /* FACTORY */

  Factory.make ( Widget, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Instances, Svelto.Templates, Svelto.Widgets, Svelto.Factory, Svelto.Pointer, Svelto.Keyboard, Svelto.Breakpoints, Svelto.Breakpoint ));


// @priority 800
// @require core/widget/widget.js

//TODO: Maybe rename it

(function ( $, _, Svelto, Factory, Breakpoints, Breakpoint ) {

  /* CONFIG */

  let config = {
    name: 'classSwitch',
    plugin: true,
    selector: '.class-switch',
    options: {
      switch: { // Classes to attach at specifc breakpoints, every key/val pair should be in the form of `breakpoint-name`: `class`, where `breakpoint-name` is a key of `Breakpoints` and `class` can be any class string. In addition to this every pair must be specified under one of the following keys: `up`, `down`, `only`, mimicking the respective SCSS mixins
        up: {},
        down: {},
        only: {}
      }
    }
  };

  /* CLASS SWITCH */

  class ClassSwitch extends Svelto.Widget {

    /* SPECIAL */

    _init () {

      this.status = { up: {}, down: {}, only: {} };

      this._populate ();

      this.__classSwitch ();

    }

    _events () {

      this.___classSwitch ();

    }

    /* POPULATE */

    _populateBreakpoint ( breakpoint ) {

      let name = Breakpoints[breakpoint];

      /* UP */

      let up = this.$element.data ( `${name}-up` );

      if ( _.isString ( up ) ) {

        this.options.switch.up[breakpoint] = up;

      }

      /* DOWN */

      let down = this.$element.data ( `${name}-down` );

      if ( _.isString ( down ) ) {

        this.options.switch.down[breakpoint] = down;

      }

      /* ONLY */

      let specific = this.$element.data ( `${name}-only` ),
          general = this.$element.data ( name ),
          only = _.isString ( specific ) ? specific : ( _.isString ( general ) ? general : undefined );

      if ( _.isString ( only ) ) {

        this.options.switch.only[breakpoint] = only;

      }

    }

    _populate () {

      for ( let key in Breakpoints ) {

        if ( !Breakpoints.hasOwnProperty ( key ) ) continue;

        if ( !_.isString ( Breakpoints[key] ) ) continue;

        this._populateBreakpoint ( key );

      }

    }

    /* STATUS */

    _getStatus () {

      let status = { up: {}, down: {}, only: {} },
          width = Breakpoints.widths[Breakpoint.current];

      /* UP */

      for ( let breakpoint in this.options.switch.up ) {

        if ( !this.options.switch.up.hasOwnProperty ( breakpoint ) ) continue;

        let active = ( width >= Breakpoints.widths[breakpoint] );

        status.up[breakpoint] = active;

      }

      /* DOWN */

      for ( let breakpoint in this.options.switch.down ) {

        if ( !this.options.switch.down.hasOwnProperty ( breakpoint ) ) continue;

        let active = ( width <= Breakpoints.widths[breakpoint] );

        status.down[breakpoint] = active;

      }

      /* ONLY */

      for ( let breakpoint in this.options.switch.only ) {

        if ( !this.options.switch.only.hasOwnProperty ( breakpoint ) ) continue;

        let active = ( width === Breakpoints.widths[breakpoint] );

        status.only[breakpoint] = active;

      }

      return status;

    }

    _getDeltaStatus ( previous, current ) {

      let delta = { up: {}, down: {}, only: {} };

      for ( let type in current ) {

        if ( !current.hasOwnProperty ( type ) ) continue;

        for ( let breakpoint in current[type] ) {

          if ( !current[type].hasOwnProperty ( breakpoint ) ) continue;

          if ( !!previous[type][breakpoint] !== !!current[type][breakpoint] ) {

            delta[type][breakpoint] = !!current[type][breakpoint];

          }

        }

      }

      return delta;

    }

    /* CLASS SWITCH */

    ___classSwitch () {

      this._on ( true, $.$window, 'breakpoint:change', this.__classSwitch );

    }

    __classSwitch () {

      let status = this._getStatus (),
          delta = this._getDeltaStatus ( this.status, status );

      for ( let type in delta ) {

        if ( !delta.hasOwnProperty ( type ) ) continue;

        for ( let breakpoint in delta[type] ) {

          if ( !delta[type].hasOwnProperty ( breakpoint ) ) continue;

          this.$element.toggleClass ( this.options.switch[type][breakpoint], delta[type][breakpoint] );

        }

      }

      this.status = status;

    }

  }

  /* FACTORY */

  Factory.make ( ClassSwitch, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Breakpoints, Svelto.Breakpoint ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* ANIMATIONS */

  let Animations = {
    xslow: 900,
    slow: 500,
    normal: 350,
    fast: 150,
    xfast: 75
  };

  /* EXPORT */

  Svelto.Animations = Animations;

}( Svelto.$, Svelto._, Svelto ));


// @priority 500
// @require core/animations/animations.js
// @require core/widget/widget.js

(function ( $, _, Svelto, Factory, Pointer, Animations ) {

  /* CONFIG */

  let config = {
    name: 'ripple',
    plugin: true,
    selector: '.ripple',
    templates: {
      circle: _.template ( '<div class="ripple-circle"></div>' )
    },
    options: {
      classes: {
        center: 'ripple-center'
      },
      animations: {
        show: Animations.slow
      },
      callbacks: {
        show: _.noop,
        hide: _.noop
      }
    }
  };

  /* RIPPLE */

  class Ripple extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$ripple = this.$element;

    }

    _events () {

      this.___up ();

    }

    /* UP */

    ___up () {

      this._on ( `${Pointer.up}`, this.__up );

    }

    __up ( event ) {

      if ( this.$ripple.hasClass ( this.options.classes.center ) ) {

        let offset = this.$ripple.offset ();

        this._show ({
          x: offset.left + ( this.$ripple.outerWidth () / 2 ),
          y: offset.top + ( this.$ripple.outerHeight () / 2 )
        });

      } else {

        this._show ( $.eventXY ( event ) );

      }

    }

    /* SHOW */

    _show ( XY ) {

      let $circle = $(this._template ( 'circle' ));

      /* SIZE */

      let offset = this.$ripple.offset (),
          insetX = XY.x - offset.left,
          insetY = XY.y - offset.top,
          sideX = Math.max ( insetX, this.$ripple.outerWidth () - insetX ),
          sideY = Math.max ( insetY, this.$ripple.outerHeight () - insetY ),
          radius = Math.sqrt ( Math.pow ( sideX, 2 ) + Math.pow ( sideY, 2 ) ), // Basically the max the distances from the point to the corners
          diameter = radius * 2;

      /* SHOW */

      $circle.css ({
        width: diameter,
        height: diameter,
        top: insetY,
        left: insetX,
      }).prependTo ( this.$ripple );

      this._trigger ( 'show' );

      /* HIDE */

      $circle.one ( 'animationend', () => {

        $circle.remove ();

        this._trigger ( 'hide' );

      }, this.options.animations.show );

    }

  }

  /* FACTORY */

  Factory.make ( Ripple, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Pointer, Svelto.Animations ));


// @require core/browser/browser.js
// @require core/readify/readify.js

(function ( $, _, Svelto, Browser, Readify ) {

  /* AUTOFOCUS */

  let Autofocus = {

    /* VARIABLES */

    enabled: Browser.is.desktop, // On touch devices the keyboard will pop up
    history: [], // List of autofocused elements
    historySize: 3, // How many elements to keep in the history
    restore: false, // Switch focus to the previously focused element
    selectionTypeRe: /text|search|url|tel|password/i,

    /* INIT */

    init () {

      Autofocus.focus ( $.$html );

    },

    /* API */

    set ( ele ) {

      if ( !Autofocus.enabled ) return;

      Autofocus.history.unshift ( ele );
      Autofocus.history = _.uniq ( Autofocus.history ).slice ( 0, Autofocus.historySize );

      ele.focus ();

      /* CARET TO THE END */

      if ( ele.setSelectionRange && Autofocus.selectionTypeRe.test ( ele.type ) ) {

        let length = ele.value.length * 2; // Double the length because Opera is inconsistent about whether a carriage return is one character or two

        if ( !length ) return;

        setTimeout ( () => ele.setSelectionRange ( length, length ), 1 ); // Timeout seems to be required for Blink

        ele.scrollTop = 1000000; // In case it's a tall textarea

      }

    },

    find ( $parent = $.$html, focused ) {

      let $focusable = $parent.find ( '[autofocus], .autofocus' ).filter ( ( i, ele ) => $.isVisible ( ele ) );

      if ( _.isBoolean ( focused ) ) {

        $focusable = $focusable.filter ( ( index, ele ) => $.isFocused ( ele ) === focused );

      }

      return $focusable.length ? $focusable[0] : null;

    },

    focus ( $parent ) {

      if ( !Autofocus.enabled ) return;

      let focusable = Autofocus.find ( $parent );

      if ( !focusable || $.isFocused ( focusable ) ) return;

      Autofocus.set ( focusable );

    },

    blur ( $parent, restore = Autofocus.restore ) {

      if ( !Autofocus.enabled || !Autofocus.history[0] || !$parent[0].contains ( Autofocus.history[0] ) ) return;

      if ( restore ) {

        let previous = Autofocus.history.find ( $.isVisible ) || Autofocus.find ( $.$html );

        if ( previous && !$.isFocused ( previous ) && $.isVisible ( previous ) ) {

          Autofocus.set ( previous );

          return;

        }

      }

      Autofocus.history[0].blur ();

    }

  };

  /* EXPORT */

  Svelto.Autofocus = Autofocus;

  /* READY */

  Readify.add ( Autofocus.init.bind ( Autofocus ) );

}( Svelto.$, Svelto._, Svelto, Svelto.Browser, Svelto.Readify ));


// @priority 400
// @require core/widget/widget.js
// @require lib/autofocus/autofocus.js

(function ( $, _, Svelto, Factory, Autofocus ) {

  /* CONFIG */

  let config = {
    name: 'autofocusable'
  };

  /* AUTOFOCUSABLE */

  class Autofocusable extends Svelto.Widget {

    /* API */

    autofocus () {

      Autofocus.focus ( this.$element );

    }

    autoblur () {

      Autofocus.blur ( this.$element );

    }

  }

  /* FACTORY */

  Factory.make ( Autofocusable, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Autofocus ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* COLORS */

  let Colors = {
    primary: 'primary',
    secondary: 'secondary',
    tertiary: 'tertiary',
    quaternary: 'quaternary',

    black: 'black',
    blue: 'blue',
    brown: 'brown',
    gray: 'gray',
    green: 'green',
    olive: 'olive',
    orange: 'orange',
    pink: 'pink',
    purple: 'purple',
    red: 'red',
    teal: 'teal',
    violet: 'violet',
    white: 'white',
    yellow: 'yellow',

    error: 'error',
    success: 'success',
    warning: 'warning',

    base: 'base',
    inherit: 'inherit',
    transparent: 'transparent'
  };

  /* EXPORT */

  Svelto.Colors = Colors;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

/* COOKIE */

(function ( $, _, Svelto ) {

  /* COOKIE */

  let Cookie = {

    /* VARIABLES */

    encoder: encodeURIComponent,
    decoder: decodeURIComponent,

    /* API */

    get ( key ) {

      if ( !key ) return null;

      return this.decoder ( document.cookie.replace ( new RegExp ( '(?:(?:^|.*;)\\s*' + this.encoder ( key ).replace ( /[\-\.\+\*]/g, '\\$&' ) + '\\s*\\=\\s*([^;]*).*$)|^.*$' ), '$1' ) ) || null;

    },

    set ( key, value, end, path, domain, secure ) {

      if ( !key || /^(?:expires|max\-age|path|domain|secure)$/i.test ( key ) ) return false;

      let expires = '';

      if ( end ) {

        switch ( end.constructor ) {

          case Number:
            expires = ( end === Infinity ) ? '; expires=Fri, 31 Dec 9999 23:59:59 GMT' : `; max-age=${end}`;
            break;

          case String:
            expires = `; expires=${end}`;
            break;

          case Date:
            expires = '; expires=' + end.toUTCString ();
            break;

        }

      }

      document.cookie = this.encoder ( key ) + '=' + this.encoder ( value ) + expires + ( domain ? `; domain=${domain}` : '' ) + ( path ? `; path=${path}` : '' ) + ( secure ? '; secure' : '' );

      return true;

    },

    remove ( key, path, domain ) {

      if ( !this.has ( key ) ) return false;

      document.cookie = this.encoder ( key ) + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT' + ( domain ? `; domain=${domain}` : '' ) + ( path ? `; path=${path}` : '' );

      return true;

    },

    has ( key ) {

      if ( !key ) return false;

      return ( new RegExp ( '(?:^|;\\s*)' + this.encoder ( key ).replace ( /[\-\.\+\*]/g, '\\$&' ) + '\\s*\\=' ) ).test ( document.cookie );

    },

    keys () {

      let keys = document.cookie.replace ( /((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, '' ).split ( /\s*(?:\=[^;]*)?;\s*/ );

      return keys.map ( this.decoder );

    }

  };

  /* EXPORT */

  Svelto.Cookie = Cookie;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* SIZES */

  let Sizes = {
    xxxxsmall: 'xxxxsmall',
    xxxsmall: 'xxxsmall',
    xxsmall: 'xxsmall',
    xsmall: 'xsmall',
    small: 'small',
    medium: 'medium',
    large: 'large',
    xlarge: 'xlarge',
    xxlarge: 'xxlarge',
    xxxlarge: 'xxxlarge',
    xxxxlarge: 'xxxxlarge'
  };

  /* EXPORT */

  Svelto.Sizes = Sizes;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* Z-DEPTHS */

  let ZDepths = {};

  for ( let i = 0, l = 24; i <= l; i++ ) {

    ZDepths[i] = `z-depth-${i}`;

  }

  /* EXPORT */

  Svelto.ZDepths = ZDepths;

}( Svelto.$, Svelto._, Svelto ));


// @require ./autofocus.js

(function ( $, _, Svelto, Autofocus ) {

  /* AUTOFOCUS */

  $.fn.autofocus = function () {

    Autofocus.focus ( this );

    return this;

  };

  /* BLUR */

  $.fn.autoblur = function () {

    Autofocus.blur ( this );

    return this;

  };

}( Svelto.$, Svelto._, Svelto, Svelto.Autofocus ));


// @require core/svelto/svelto.js

//TODO: Add support for the alpha channel
//TODO: Maybe add better support for hex color provided as string, basically Color.hex2hsl should also accept an hex color in string format

(function ( $, _, Svelto ) {

  /* COLOR */

  let Color = class {

    constructor ( color, colorspace ) {

      this.set ( color, colorspace );

    }

    /* SET */

    set ( color, colorspace ) {

      if ( colorspace ) {

        switch ( colorspace.toLowerCase () ) {

          case 'hex':
            return this.setHex ( color );

          case 'rgb':
            return this.setRgb ( color );

          case 'hsv':
            return this.setHsv ( color );

          case 'hsl':
            return this.setHsl ( color );

        }

      }

      if ( _.isPlainObject ( color ) ) {

        if ( 'r' in color && 'g' in color && 'b' in color ) {

          if ( Number ( color.r ) > 99 || Number ( color.g ) > 99 || Number ( color.b ) > 99 ) {

            return this.setRgb ( color );

          } else {

            return this.setHex ( color );

          }

        } else if ( 'h' in color && 's' in color ) {

          if ( 'l' in color ) {

            return this.setHsl ( color );

          } else if ( 'v' in color ) {

            return this.setHsv ( color );

          }

        }

      } else if ( _.isString ( color ) ) {

        color = color.slice ( -6 );

        if ( /^[0-9a-f]{6}$/i.test ( color ) ) { // Full 6-chars hex color notation

          return this.setHex ({
            r: color[0] + color[1],
            g: color[2] + color[3],
            b: color[4] + color[5]
          });

        } else if ( /^[0-9a-f]{3}$/i.test ( color ) ) { // Shorthand 3-chars hex color notation

          return this.setHex ({
            r: color[0].repeat ( 2 ),
            g: color[1].repeat ( 2 ),
            b: color[2].repeat ( 2 )
          });

        }

      }

      throw new Error ( 'Invalid color' );

    }

    setHex ( color ) {

      this.hex = _.cloneDeep ( color );

    }

    setRgb ( color ) {

      this.hex = Color.rgb2hex ( color );

    }

    setHsv ( color ) {

      this.hex = Color.hsv2hex ( color );

    }

    setHsl ( color ) {

      this.hex = Color.hsl2hex ( color );

    }

    /* GET */

    getHex () {

      return this.hex;

    }

    getRgb () {

      return Color.hex2rgb ( this.hex );

    }

    getHsv () {

      return Color.hex2hsv ( this.hex );

    }

    getHsl () {

      return Color.hex2hsl ( this.hex );

    }

    /* ----- STATICS ----- */

    /* HEX */

    static hex2rgb ( hex ) {

      return {
        r: Color.hex2dec ( hex.r ),
        g: Color.hex2dec ( hex.g ),
        b: Color.hex2dec ( hex.b )
      };

    }

    static hex2hsv ( hex ) {

      return Color.rgb2hsv ( Color.hex2rgb ( hex ) );

    }

    static hex2hsl ( hex ) {

      return Color.hsv2hsl ( Color.hex2hsv ( hex ) );

    }

    /* RGB */

    static rgb2hex ( rgb ) {

      return {
        r: Color.dec2hex ( rgb.r ),
        g: Color.dec2hex ( rgb.g ),
        b: Color.dec2hex ( rgb.b )
      };

    }

    static rgb2hsv ( rgb ) {

      let r = rgb.r / 255,
          g = rgb.g / 255,
          b = rgb.b / 255,
          h,
          s,
          v = Math.max ( r, g, b ),
          diff = v - Math.min ( r, g, b ),
          diffc = function ( c ) {
            return ( v - c ) / 6 / diff + 1 / 2;
          };

      if ( diff === 0 ) {

        h = s = 0;

      } else {

        s = diff / v;

        let rr = diffc ( r ),
            gg = diffc ( g ),
            bb = diffc ( b );

        if ( r === v ) {

          h = bb - gg;

        } else if ( g === v ) {

          h = ( 1 / 3 ) + rr - bb;

        } else if ( b === v ) {

          h = ( 2 / 3 ) + gg - rr;

        }

        if ( h < 0 ) {

          h += 1;

        } else if ( h > 1 ) {

          h -= 1;
        }

      }

      return {
        h: h * 360,
        s: s * 100,
        v: v * 100
      };

    }

    static rgb2hsl ( rgb ) {

      return Color.hsv2hsl ( Color.rgb2hsv ( rgb ) );

    }

    /* HSV */

    static hsv2hex ( hsv ) {

      return Color.rgb2hex ( Color.hsv2rgb ( hsv ) );

    }

    static hsv2rgb ( hsv ) {

      let r,
          g,
          b,
          h = hsv.h,
          s = hsv.s,
          v = hsv.v;

      s /= 100;
      v /= 100;

      if ( s === 0 ) {

        r = g = b = v;

      } else {

        let i, f, p, q, t;

        h /= 60;
        i = Math.floor ( h );
        f = h - i;
        p = v * ( 1 - s );
        q = v * ( 1 - s * f );
        t = v * ( 1 - s * ( 1 - f ) );

        switch ( i ) {

          case 0:
            r = v;
            g = t;
            b = p;
            break;

          case 1:
            r = q;
            g = v;
            b = p;
            break;

          case 2:
            r = p;
            g = v;
            b = t;
            break;

          case 3:
            r = p;
            g = q;
            b = v;
            break;

          case 4:
            r = t;
            g = p;
            b = v;
            break;

          default:
            r = v;
            g = p;
            b = q;

        }

      }

      return {
        r: Math.round ( r * 255 ),
        g: Math.round ( g * 255 ),
        b: Math.round ( b * 255 )
      };

    }

    static hsv2hsl ( hsv ) {

      let s = hsv.s / 100,
          v = hsv.v / 100,
          tempL = ( 2 - s ) * v,
          tempS = s * v;

      return {
        h: hsv.h,
        s: ( tempS !== 0 ) ? ( tempS / ( ( tempL <= 1 ) ? tempL : 2 - tempL ) ) * 100 : 0,
        l: ( tempL / 2 ) * 100
      };

    }

    /* HSL */

    static hsl2hex ( hsl ) {

      return Color.hsv2hex ( Color.hsl2hsv ( hsl ) );

    }

    static hsl2rgb ( hsl ) {

      return Color.hsv2rgb ( Color.hsl2hsv ( hsl ) );

    }

    static hsl2hsv ( hsl ) {

      let l = hsl.l / 100 * 2,
          s = ( hsl.s / 100 ) * ( l <= 1 ? l : 2 - l );

      return {
        h: hsl.h,
        s: ( l + s !== 0 ) ? ( 2 * s ) / ( l + s ) * 100 : 0,
        v: ( l + s ) / 2 * 100
      };

    }

    /* DECIMAL / HEX */

    static dec2hex ( dec ) {

      return parseInt ( dec, 10 ).toString ( 16 ).padStart ( 2, '0' );

    }

    static hex2dec ( hex ) {

      return parseInt ( hex, 16 );

    }

  };

  /* EXPORT */

  Svelto.Color = Color;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* DIRECTIONS */

  let Directions = {

    get () {

      return ['top', 'bottom', 'left', 'right'];

    },

    getOpposite ( direction ) {

      return {
        'top': 'bottom',
        'bottom': 'top',
        'left': 'right',
        'right': 'left'
      }[direction];

    }

  };

  /* EXPORT */

  Svelto.Directions = Directions;

}( Svelto.$, Svelto._, Svelto ));


// @require core/readify/readify.js

/* EMBEDDED CSS */

//TODO: Lazily instanciate this

(function ( $, _, Svelto, Readify ) {

  /* EMBEDDED CSS */

  class EmbeddedCSS {

    constructor () {

      this.$stylesheet = $(`<style class="svelto-embedded svelto-embedded-${$.guid++}">`);
      this.tree = {};

    }

    /* PRIVATE */

    _cssfy () {

      let css = '';

      for ( let selector in this.tree ) {

        if ( !this.tree.hasOwnProperty ( selector ) ) continue;

        css += selector + '{';

        if ( _.isPlainObject ( this.tree[selector] ) ) {

          for ( let property in this.tree[selector] ) {

            if ( !this.tree[selector].hasOwnProperty ( property ) ) continue;

            css += property + ':' + this.tree[selector][property] + ';';

          }

        } else if ( _.isString ( this.tree[selector] ) ) {

          css += this.tree[selector] + ';';

        }

        css += '}';

      }

      return css;

    }

    _refresh () {

      this.$stylesheet.text ( this._cssfy () );

    }

    /* API */

    get ( selector ) {

      return this.tree[selector];

    }

    set ( selector, property, value ) {

      if ( property === false ) {

        return this.remove ( selector );

      }

      if ( _.isPlainObject ( property ) ) {

        this.tree[selector] = _.extend ( _.isPlainObject ( this.tree[selector] ) ? this.tree[selector] : {}, property );

      } else if ( _.isString ( property ) ) {

        if ( !value ) {

          this.tree[selector] = property;

        } else {

          return this.set ( selector, { [property]: value } );

        }

      }

      this._refresh ();

    }

    remove ( selector ) {

      if ( selector in this.tree ) {

        delete this.tree[selector];

        this._refresh ();

      }

    }

    clear () {

      if ( Object.keys ( this.tree ).length ) {

        this.tree = {};

        this._refresh ();

      }

    }

    attach () {

      this.$stylesheet.appendTo ( $.$head );

    }

    detach () {

      this.$stylesheet.remove ();

    }

  }

  /* EXPORT */

  Svelto.EmbeddedCSS = new EmbeddedCSS ();

  /* READY */

  Readify.add ( Svelto.EmbeddedCSS.attach.bind ( Svelto.EmbeddedCSS ) );

}( Svelto.$, Svelto._, Svelto, Svelto.Readify ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* VARIABLES */

  let html = document.documentElement,
      keyboardAllowed = ( typeof Element !== 'undefined' && 'ALLOW_KEYBOARD_INPUT' in Element ),
      apis = [
        ['requestFullscreen',       'exitFullscreen',       'fullscreenElement',       'fullscreenEnabled',       'fullscreenchange',       'fullscreenerror'],
        ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],
        ['mozRequestFullScreen',    'mozCancelFullScreen',  'mozFullScreenElement',    'mozFullScreenEnabled',    'mozfullscreenchange',    'mozfullscreenerror'],
        ['msRequestFullscreen',     'msExitFullscreen',     'msFullscreenElement',     'msFullscreenEnabled',     'MSFullscreenChange',     'MSFullscreenError']
      ],
      api = apis.find ( methods => methods[1] in document ),
      raw = {};

  if ( api ) api.forEach ( ( method, index ) => raw[apis[0][index]] = method );

  /* FULLSCREEN */

  let Fullscreen = {
    request ( ele = html ) {
      if ( !raw.requestFullscreen ) return;
      ele[raw.requestFullscreen]( keyboardAllowed && Element.ALLOW_KEYBOARD_INPUT );
    },
    exit () {
      if ( !raw.exitFullscreen ) return;
      document[raw.exitFullscreen]();
    },
    toggle ( ele ) {
      Fullscreen.isFullscreen ? Fullscreen.exit () : Fullscreen.request ( ele );
    },
    get isFullscreen () {
      return !!Fullscreen.element;
    },
    get element () {
      return document[raw.fullscreenElement];
    },
    get enabled () {
      return !!document[raw.fullscreenEnabled];
    },
    raw
  };

  /* EXPORT */

  Svelto.Fullscreen = Fullscreen;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* FUZZY */

  let Fuzzy = {

    match ( str, search, isCaseSensitive = true ) {

      if ( !isCaseSensitive ) {

        str = str.toLowerCase ();
        search = search.toLowerCase ();

      }

      let currentIndex = -1,
          str_i,
          str_l = str.length;

      for ( let search_i = 0, search_l = search.length; search_i < search_l; search_i++ ) {

        for ( str_i = currentIndex + 1; str_i < str_l; str_i++ ) {

          if ( str[str_i] === search[search_i] ) {

            currentIndex = str_i;
            str_i = str_l + 1;

          }

        }

        if ( str_i === str_l ) {

          return false;

        }

      }

      return true;

    }

  };

  /* EXPORT */

  Svelto.Fuzzy = Fuzzy;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* GET SCRIPT */

  function getScript ( url ) {

    return new Promise ( ( resolve, reject ) => {

      let script = document.createElement ( 'script' ),
          anchor = document.getElementsByTagName ( 'script' )[0];

      script.async = true;

      script.onload = resolve;
      script.onerror = reject;
      script.src = url;

      anchor.parentNode.insertBefore ( script, anchor );

    });

  }

  /* EXPORT */

  Svelto.getScript = getScript;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* REGEXES */

  let Regexes = {

    /* TYPE */

    alpha: /^[a-zA-Z]+$/,
    alphanumeric: /^[a-zA-Z0-9]+$/,
    hexadecimal: /^[a-fA-F0-9]+$/,
    integer: /^(?:-?(?:[0-9]*))$/,
    float: /^-?(?:(?:\d+)(?:\.\d*)?|(?:\.\d+)+)$/,

    /* THINGS */

    email: /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i,
    creditCard: /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/,
    ssn: /^(?!000|666)[0-8][0-9]{2}-(?!00)[0-9]{2}-(?!0000)[0-9]{4}$/,
    ipv4: /^(?:(?:\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])\.){3}(?:\d|[1-9]\d|1\d{2}|2[0-4]\d|25[0-5])$/,
    url: /^(?:(?:https?|ftp):\/\/)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/\S*)?$/i

  };

  /* EXPORT */

  Svelto.Regexes = Regexes;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

// TTL is expressed in seconds

(function ( $, _, Svelto ) {

  /* STORAGE */

  let Storage = {
    key ( nr ) {
      return localStorage.key ( nr );
    },
    remove ( key ) {
      return localStorage.removeItem ( key );
    },
    clear () {
      return localStorage.clear ();
    },
    get ( key ) {

      let val = localStorage.getItem ( key ),
          obj = _.attempt ( JSON.parse, val );

      if ( _.isPlainObject ( obj ) ) {

        if ( 'exp' in obj && obj.exp < _.nowSecs () ) {

          Storage.remove ( key );
          return null;

        }

        return 'val' in obj ? obj.val : obj;

      }

      return val;

    },
    set ( key, val, ttl ) {

      let obj = {val};

      if ( ttl ) obj.exp = _.nowSecs () + ttl;

      try {

        localStorage.setItem ( key, JSON.stringify ( obj ) );

      } catch ( e ) {}

    }
  };

  /* EXPORT */

  Svelto.Storage = Storage;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* TIMER */

  let Timer = class {

    constructor ( ...args ) {

      this.set ( ...args );

    }

    set ( callback, time, autostart ) {

      this.init = true;
      this.action = callback;

      if ( !isNaN ( time ) ) {

        this.intervalTime = time;

      }

      if ( autostart && !this.isActive ) {

        this.isActive = true;
        this.setTimer ();

      }

      return this;

    }

    once ( time ) {

      if ( isNaN ( time ) ) {

        time = 0;

      }

      setTimeout ( () => this.action (), time );

      return this;

    }

    play ( reset ) {

      if ( !this.isActive ) {

        if ( reset ) {

          this.setTimer ();

        } else {

          this.setTimer ( this.remainingTime );

        }

        this.isActive = true;

      }

      return this;

    }

    pause () {

      if ( this.isActive ) {

        this.isActive = false;
        this.remainingTime -= Date.now () - this.last;
        this.clearTimer ();

      }

      return this;

    }

    stop () {

      this.isActive = false;
      this.remainingTime = this.intervalTime;
      this.clearTimer ();

      return this;

    }

    toggle ( reset ) {

      if ( this.isActive ) {

        this.pause ();

      } else if ( reset ) {

        this.play ( true );

      } else {

        this.play ();

      }

      return this;

    }

    reset () {

      this.isActive = false;

      this.play ( true );

      return this;

    }

    clearTimer () {

      clearTimeout ( this.timeoutObject );

    }

    setTimer ( time ) {

      if ( isNaN ( time ) ) {

        time = this.intervalTime;

      }

      this.remainingTime = time;
      this.last = Date.now ();
      this.clearTimer ();

      this.timeoutObject = setTimeout ( () => this.go (), time );

    }

    go () {

      if ( this.isActive ) {

        this.action ();
        this.setTimer ();

      }

    }

    remaining ( value ) {

      if ( _.isUndefined ( value ) ) {

        return this.remainingTime;

      }

      this.remainingTime = value;

      return this;

    }

  };

  /* EXPORT */

  Svelto.Timer = Timer;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* UTILITIES */

  let getOverlappingArea = function ( rect1, rect2 ) {

    let overlapX = Math.max ( 0, Math.min ( rect1.right, rect2.right ) - Math.max ( rect1.left, rect2.left ) ),
        overlapY = Math.max ( 0, Math.min ( rect1.bottom, rect2.bottom ) - Math.max ( rect1.top, rect2.top ) );

    return overlapX * overlapY;

  };

  /* DEFAULTS */

  let defaults = {
    point: false, // Used for the punctual search
    $comparer: false, // Used for the overlapping search
    $not: false,
    onlyBest: false
  };

  /* TOUCHING */

  $.fn.touching = function ( options ) {

    /* OPTIONS */

    options = _.extend ( {}, $.fn.touching.defaults, options );

    /* SEARCHABLE */

    let $searchable = options.$not ? this.not ( options.$not ) : this;

    /* COMPARER */

    if ( options.$comparer ) {

      let rect1 = options.$comparer.getRect (),
          nodes = [],
          areas = [];

      for ( let i = 0, l = $searchable.length; i < l; i++ ) {

        let searchable = $searchable[i],
            rect2 = $.getRect ( searchable ),
            area = getOverlappingArea ( rect1, rect2 );

        if ( area > 0 ) {

          nodes.push ( searchable );
          areas.push ( area );

        }

      }

      return nodes.length
               ? options.onlyBest
                 ? $(nodes[ areas.indexOf ( Math.max ( ...areas ) ) ])
                 : $(nodes)
               : false;

    }

    /* PUNCTUAL */

    if ( options.point ) {

      for ( let i = 0, l = $searchable.length; i < l; i++ ) {

        let searchable = $searchable[i],
            rect = $.getRect ( searchable );

        if ( options.point.y >= rect.top && options.point.y <= rect.bottom && options.point.x >= rect.left && options.point.x <= rect.right ) {

          return $(searchable);

        }

      }

    }

    /* DEFAULT */

    return false;

  };

  /* BINDING */

  $.fn.touching.defaults = defaults;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js

/* TRANSFORM UTILITIES */

(function ( $, _, Modernizr, Svelto ) {

  /* MATRIX */

  let property = _.CSS2DOM ( Modernizr.prefixedCSS ( 'transform' ) ),
      precision = 3; // Or sometimes we may get weird values like `2.4492935982947064e-16` on Safari

  $.fn.matrix = function ( values ) { //TODO: Add not jquery-wrapped version fo this maybe

    if ( values ) {

      values = values.map ( val => parseFloat ( parseFloat ( val ).toFixed ( precision ) ) ).join ( ',' );

      this[0].style[property] = `matrix(${values})`;

      return this;

    } else {

      let transformStr = getComputedStyle ( this[0], null )[property];

      return ( transformStr && transformStr !== 'none' ) ? transformStr.match ( /[0-9., e-]+/ )[0].split ( ', ' ).map ( value => parseFloat ( parseFloat ( value ).toFixed ( precision ) ) ) : [1, 0, 0, 1, 0, 0];

    }

  };

  /* TRANSFORMATIONS */

  let transformations = ['scaleX', 'skewY', 'skewX', 'scaleY', 'translateX', 'translateY']; // Their index is also the corresponsing index when applying `transform: matrix()`

  for ( let i = 0, l = transformations.length; i < l; i++ ) {

    $.fn[transformations[i]] = (function ( index ) { //TODO: Add not jquery-wrapped version fo this maybe

       return function ( value ) { //TODO: Maybe add an optional `_matrix` argument, so that we can batch reads and writes

         let matrix = this.matrix ();

         if ( !_.isUndefined ( value ) ) {

           matrix[index] = value;

           return this.matrix ( matrix );

         } else {

           return matrix[index];

         }

       };

     })( i );

  }

  /* 2D TRANSFORMATIONS */

  let transformations2D = ['scale', 'skew', 'translate'],
      indexes2D = [[0, 3], [2, 1], [4, 5]];

  for ( let i = 0, l = transformations2D.length; i < l; i++ ) {

    $.fn[transformations2D[i]] = (function ( index ) { //TODO: Add not jquery-wrapped version fo this maybe

      return function ( X, Y = X ) { //TODO: Maybe add an optional `_matrix` argument, so that we can batch reads and writes

        let matrix = this.matrix (),
            indexes = indexes2D[index];

        if ( !_.isUndefined ( X ) && !_.isUndefined ( Y ) ) {

          matrix[indexes[0]] = X;
          matrix[indexes[1]] = Y;

          return this.matrix ( matrix );

        } else {

          return {
            x: matrix[indexes[0]],
            y: matrix[indexes[1]]
          };

        }

      }

    })( i );

  }

}( Svelto.$, Svelto._, Svelto.Modernizr, Svelto ));


// @require core/svelto/svelto.js
// @require lib/directions/directions.js
// @require lib/embedded_css/embedded_css.js
// @require lib/transform/transform.js

//FIXME: If the positionable element is less than half of the anchor, and it must be pointed, than the pointer may be not well positionated (expecially if we are not aligning to the center)

(function ( $, _, Svelto, Directions, EmbeddedCSS ) {

  /* DEFAULTS */

  let defaults = {
    axis: false, // Set a preferred axis
    strict: false, // If enabled only use the setted axis/direction, even if it won't be the optimial choice
    $anchor: false, // Positionate next to an $anchor element
    point: false, // Positionate at coordinates, ex: { x: number, y: number }
    pointer: false, // The element pointing to the anchor, can be: false -> no pointer, 'auto' -> pointer using the `pointing` decorator, $element -> element used as pointer
    spacing: 0, // Extra space to leave around the positionable element
    constrainer: { // Constrain the $positionable inside the $element
      $element: false, // If we want to keep the $positionable inside this $element
      center: false, // Set the constrain type, it will constrain the whole shape, or the center
      tolerance: { // The amount of pixel flexibility that a constrainer has
        x: 0,
        y: 0
      }
    },
    directions: { // How the directions should be prioritized when selecting the `x` axis, the `y` axis, or all of them
      x: ['right', 'left'],
      y: ['bottom', 'top'],
      all: ['bottom', 'right', 'left', 'top']
    },
    alignment: { // Set the alignment of the positionable relative to the anchor
      x: 'center', // `left`, center`, `right`
      y: 'center' // `top`, center`, `bottom`
    },
    callbacks: {
      change: _.noop
    }
  };

  /* POSITIONATE */

  $.fn.positionate = function ( options ) {

    /* NO ELEMENTS */

    if ( !this.length ) return this;

    /* OPTIONS */

    options = _.merge ( {}, $.fn.positionate.defaults, options );

    /* VARIABLES */

    let positionable = this[0],
        $positionable = $(positionable),
        positionableRect = $positionable.getRect (),
        windowWidth = window.innerWidth,
        windowHeight = window.innerHeight,
        directions = _.uniq ( [].concat ( options.direction ? [options.direction] : [], options.axis ? options.directions[options.axis] : [], !options.strict || !options.direction && !options.axis ? options.directions.all : [] ) ),
        anchorRect = options.$anchor ? options.$anchor.getRect () : { top: options.point.y - window.scrollY, bottom: options.point.y - window.scrollY, left: options.point.x - window.scrollX, right: options.point.x - window.scrollX, width: 0, height: 0 };

    /* ID */

    positionable._positionateGuid = positionable._positionateGuid || $.guid++;
    positionable._positionateGuc = `positionate-${positionable._positionateGuid}`;

    $positionable.addClass ( positionable._positionateGuc );

    /* SPACES */

    let spaces = directions.map ( direction => {

      switch ( direction ) {

        case 'top':
          return anchorRect.top;

        case 'bottom':
          return windowHeight - anchorRect.bottom;

        case 'left':
          return anchorRect.left;

        case 'right':
          return windowWidth - anchorRect.right;

      }

    });

    /* SPACES PRIORITIZATION */

    spaces.forEach ( ( space, index ) => {

      if ( space < 0 ) {

        let opposite = Directions.getOpposite ( directions[index] ),
            oppositeIndex = directions.indexOf ( opposite );

        if ( oppositeIndex !== -1 ) {

          _.move ( directions, oppositeIndex, 0 );
          _.move ( spaces, oppositeIndex, 0 );

        }

      }

    });

    /* AREAS */

    let areas = directions.map ( ( direction, index ) => {

      switch ( direction ) {

        case 'top':
        case 'bottom':
          return Math.min ( positionableRect.height, spaces[index] ) * Math.min ( windowWidth, positionableRect.width );

        case 'left':
        case 'right':
          return Math.min ( positionableRect.width, spaces[index] ) * Math.min ( windowHeight, positionableRect.height );

      }

    });

    /* BEST DIRECTION */

    let bestIndex = areas.indexOf ( Math.max ( ...areas ) ),
        bestDirection = directions[bestIndex],
        coordinates = {};

    /* TOP / LEFT */

    switch ( bestDirection ) {

      case 'top':
        coordinates.top = anchorRect.top - positionableRect.height - options.spacing;
        break;

      case 'bottom':
        coordinates.top = anchorRect.bottom + options.spacing;
        break;

      case 'left':
        coordinates.left = anchorRect.left - positionableRect.width - options.spacing;
        break;

      case 'right':
        coordinates.left = anchorRect.right + options.spacing;
        break;

    }

    switch ( bestDirection ) {

      case 'top':
      case 'bottom':
        switch ( options.alignment.x ) {
          case 'left':
            coordinates.left = anchorRect.left;
            break;
          case 'center':
            coordinates.left = anchorRect.left + ( anchorRect.width / 2 ) - ( positionableRect.width / 2 );
            break;
          case 'right':
            coordinates.left = anchorRect.right - positionableRect.width;
            break;
        }
        break;

      case 'left':
      case 'right':
        switch ( options.alignment.y ) {
          case 'top':
            coordinates.top = anchorRect.top;
            break;
          case 'center':
            coordinates.top = anchorRect.top + ( anchorRect.height / 2 ) - ( positionableRect.height / 2 );
            break;
          case 'bottom':
            coordinates.top = anchorRect.bottom - positionableRect.height;
            break;
        }
        break;

    }

    /* CONSTRAIN */

    if ( options.$anchor ) {

      let oppositeSpace = spaces[bestIndex],
          isExtendedX = anchorRect.top + anchorRect.height >= 0 && anchorRect.top <= windowHeight,
          isExtendedY = anchorRect.left + anchorRect.width >= 0 && anchorRect.left <= windowWidth;

      if ( isExtendedX ) coordinates.top = _.clamp ( coordinates.top, options.spacing, windowHeight - positionableRect.height - options.spacing );
      if ( isExtendedY ) coordinates.left = _.clamp ( coordinates.left, options.spacing, windowWidth - positionableRect.width - options.spacing );

    } else if ( options.constrainer.$element ) {

      let constrainerRect = options.constrainer.$element.getRect (),
          halfWidth = options.constrainer.center ? positionableRect.width / 2 : 0,
          halfHeight = options.constrainer.center ? positionableRect.height / 2 : 0;

      /* COORDINATES */

      coordinates.top = _.clamp ( coordinates.top, constrainerRect.top - halfHeight - options.constrainer.tolerance.y + options.spacing, constrainerRect.bottom - positionableRect.height + halfHeight + options.constrainer.tolerance.y - options.spacing );
      coordinates.left = _.clamp ( coordinates.left, constrainerRect.left - halfWidth - options.constrainer.tolerance.x + options.spacing, constrainerRect.right - positionableRect.width + halfWidth + options.constrainer.tolerance.x - options.spacing );

    }

    /* DATAS */

    let data = {
      positionable: positionable,
      coordinates: coordinates,
      direction: bestDirection
    };

    /* TRANSLATE */

    $positionable.translate ( coordinates.left, coordinates.top );

    /* CSS CLASS */

    let prevDirection = positionable._positionatePrevDirection;

    positionable._positionatePrevDirection = bestDirection;

    if ( prevDirection !== bestDirection ) {

      $positionable.removeClass ( `position-${prevDirection}` ).addClass ( `position-${bestDirection}` );

    }

    /* POINTER */

    let prevPointer = positionable._positionatePrevPointer;

    positionable._positionatePrevPointer = options.pointer;

    if ( prevPointer === 'auto' && ( options.pointer !== 'auto' || bestDirection !== prevDirection ) ) {

      let oppositeDirection = Directions.getOpposite ( prevDirection );

      $positionable.removeClass ( `pointing-${oppositeDirection}` );

    }

    if ( options.pointer ) {

      if ( options.pointer === 'auto' ) {

        let oppositeDirection = Directions.getOpposite ( bestDirection );

        $positionable.addClass ( `pointing-${oppositeDirection}` );

      }

      /* MOVING */

      switch ( bestDirection ) {

        case 'top':
        case 'bottom':
          let deltaX = _.clamp ( anchorRect.left - coordinates.left + ( anchorRect.width / 2 ), 0, positionableRect.width );
          if ( options.pointer instanceof $ ) {
            options.pointer.translate ( deltaX, 0 );
          } else if ( options.pointer === 'auto' ) {
            EmbeddedCSS.set ( `.${positionable._positionateGuc}:after`, `left:${deltaX}px !important;` ); //TODO: Maybe use `transform` instead, since it lead to improved performances
          }
          break;

        case 'left':
        case 'right':
          let deltaY = _.clamp ( positionableRect.height, anchorRect.top - coordinates.top + ( anchorRect.height / 2 ), 0, positionableRect.height );
          if ( options.pointer instanceof $ ) {
            options.pointer.translate ( 0, deltaY );
          } else if ( options.pointer === 'auto' ) {
            EmbeddedCSS.set ( `.${positionable._positionateGuc}:after`, `top:${deltaY}px !important;` ); //TODO: Maybe use `transform` instead, since it lead to improved performances
          }
          break;

      }

    }

    /* CALLBACK */

    options.callbacks.change ( data );

    /* RETURN */

    return this;

  };

  /* BINDING */

  $.fn.positionate.defaults = defaults;

}( Svelto.$, Svelto._, Svelto, Svelto.Directions, Svelto.EmbeddedCSS ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* URL */

  let URL = {
    trailingSlashRe: /\/$/,
    targetRe: /#(.*)$/,
    isEqual ( url1, url2, stripTarget = false ) {
      if ( !_.isString ( url1 ) || !_.isString ( url2 ) ) return url1 === url2;
      url1 = stripTarget ? url1.replace ( URL.targetRe, '' ) : url1;
      url2 = stripTarget ? url2.replace ( URL.targetRe, '' ) : url2;
      return url1.replace ( URL.trailingSlashRe, '' ) === url2.replace ( URL.trailingSlashRe, '' );
    },
    makeAbsolute ( url ) {
      if ( url.startsWith ( '/' ) || url.includes ( '://' ) ) return url;
      return `/${url}`;
    }
  };

  /* EXPORT */

  Svelto.URL = URL;

}( Svelto.$, Svelto._, Svelto ));


// @require core/svelto/svelto.js
// @require lib/regexes/regexes.js

//TODO: Most of them will return false for empty strings, is this the wanted behaviour?

// `value` is supposed to be a string
// Strings will be trimmed inside some validators

(function ( $, _, Svelto, Regexes ) {

  /* VALIDATOR */

  let Validator = {

    /* TYPE */

    alpha ( value ) {
      return !!value.match ( Regexes.alpha );
    },
    alphanumeric ( value ) {
      return !!value.match ( Regexes.alphanumeric );
    },
    hexadecimal ( value ) {
      return !!value.match ( Regexes.hexadecimal );
    },
    number ( value ) {
      return !!value.match ( Regexes.integer ) || !!value.match ( Regexes.float );
    },
    integer ( value ) {
      return !!value.match ( Regexes.integer );
    },
    float ( value ) {
      return !!value.match ( Regexes.float );
    },

    /* NUMBER */

    min ( value, min ) {
      return ( Number ( value ) >= Number ( min ) );
    },
    max ( value, max ) {
      return ( Number ( value ) <= Number ( max ) );
    },
    range ( value, min, max ) {
      value = Number ( value );
      return ( value >= Number ( min ) && value <= Number ( max ) );
    },

    /* LENGTH */

    minLength ( value, minLength ) {
      return ( value.trim ().length >= Number ( minLength ) );
    },
    maxLength ( value, maxLength ) {
      return ( value.trim ().length <= Number ( maxLength ) );
    },
    rangeLength ( value, minLength, maxLength ) {
      value = value.trim ();
      return ( value.length >= Number ( minLength ) && value.length <= Number ( maxLength ) );
    },
    exactLength ( value, length ) {
      return ( value.trim ().length === Number ( length ) );
    },

    /* THINGS */

    email ( value ) {
      return !!value.match ( Regexes.email );
    },
    creditCard ( value ) {
      return !!value.match ( Regexes.creditCard );
    },
    ssn ( value ) {
      return !!value.match ( Regexes.ssn );
    },
    ipv4 ( value ) {
      return !!value.match ( Regexes.ipv4 );
    },
    url ( value ) {
      return !!value.match ( Regexes.url );
    },

    /* OTHERS */

    empty ( value ) {
      return !value.trim ().length;
    },
    included ( value, values ) {
      value = value.toLowerCase ();
      values = values.map ( value => value.toLowerCase () );
      return values.includes ( value );
    }

  };

  /* EXPORT */

  Svelto.Validator = Validator;

}( Svelto.$, Svelto._, Svelto, Svelto.Regexes ));


// @require core/widget/widget.js

// When using using an incomplete-information format (those where not all the info are exported, like YYYYMMDD) the behaviour when used in combination with, for instance, `formSync` would be broken: at GTM+5 it may be the day 10, but at UTC may actually be day 9, and when syncing we won't get the right date synced between both datepickers
// Accordion to ISO-8601 the first day of the week is Monday

//FIXME: When using the arrows the prev day still remains hovered even if it's not below the cursor (chrome) //TODO: Make a SO question, maybe we can workaround it
//FIXME: `today` button doesn't work when the same month is active but the wrong day is selected

(function ( $, _, Svelto, Factory, Pointer ) {

  /* CONFIG */

  let config = {
    name: 'datepicker',
    plugin: true,
    selector: '.datepicker',
    options: {
      exporters: {
        YYYYMMDD ( date, data ) {
          return [date.getUTCFullYear ().toString ().padStart ( 4, '0' ), ( parseInt ( date.getUTCMonth (), 10 ) + 1 ).toString ().padStart ( 2, '0' ), date.getUTCDate ().toString ().padStart ( 2, '0' )].join ( data.separator );
        },
        UNIXTIMESTAMP ( date ) {
          return Math.floor ( date.getTime () / 1000 );
        },
        ISO ( date ) {
          return date.toISOString ();
        },
        UTC ( date ) {
          return date.toUTCString ();
        }
      },
      importers: {
        YYYYMMDD ( date, data ) {
          let segments = date.split ( data.separator );
          return new Date ( Date.UTC ( parseInt ( segments[0], 10 ), parseInt ( segments[1], 10 ) - 1, parseInt ( segments[2], 10 ) ) );
        },
        UNIXTIMESTAMP ( date ) {
          return new Date ( ( _.isString ( date ) && date.length ) ? date * 1000 : NaN );
        },
        ISO ( date ) {
          return new Date ( date );
        },
        UTC ( date ) {
          return new Date ( date );
        }
      },
      months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
      firstDayOfWeek: 0, // Corresponding to the index in this array: `['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']`, setted to 0 since that to ISO-8601 the first day of the week is Monday
      date: {
        min: false, // Minimum selectable date
        max: false, // Maximum selectable date
        today: false, // Today date
        current: false, // Current date visible in the datepicker (basically the month we are viewing)
        selected: false // The selcted date
      },
      format: {
        type: 'UNIXTIMESTAMP', // One of the formats implemented in the exporters
        data: { // Passed to the called importer and exporter
          separator: '/'
        }
      },
      classes: {
        today: 'datepicker-day-today',
        selected: 'datepicker-day-selected',
        clamped: 'datepicker-day-clamped'
      },
      selectors: {
        navigation: {
          previous: '.datepicker-navigation .previous',
          next: '.datepicker-navigation .next',
          today: '.datepicker-navigation .today'
        },
        day: {
          previous: '.datepicker-days .previous',
          current: '.datepicker-days *:not(.previous):not(.next)',
          next: '.datepicker-days .next',
          today: '.datepicker-day-today',
          selected: '.datepicker-day-selected',
          clamped: '.datepicker-day-clamped'
        },
        title: '.datepicker-title',
        input: 'input'
      },
      keystrokes: {
        'up, left': 'previousMonth',
        'right, down': 'nextMonth'
      },
      callbacks: {
        change: _.noop,
        render: _.noop
      }
    }
  };

  /* DATEPICKER */

  class Datepicker extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$datepicker = this.$element;
      this.$input = this.$datepicker.find ( this.options.selectors.input );

      this.$navigationPrev = this.$datepicker.find ( this.options.selectors.navigation.previous );
      this.$navigationNext = this.$datepicker.find ( this.options.selectors.navigation.next );
      this.$navigationToday = this.$datepicker.find ( this.options.selectors.navigation.today );
      this.$navigationTitle = this.$datepicker.find ( this.options.selectors.title );

      this.$daysPrev = this.$datepicker.find ( this.options.selectors.day.previous );
      this.$daysCurrent = this.$datepicker.find ( this.options.selectors.day.current );
      this.$daysNext = this.$datepicker.find ( this.options.selectors.day.next );
      this.$daysAll = this.$daysPrev.add ( this.$daysCurrent ).add ( this.$daysNext );

      this.$daySelected = this.$daysAll.filter ( this.options.selectors.day.selected );
      this.$dayToday = this.$daysAll.filter ( this.options.selectors.day.today );

    }

    _init () {

      /* RESETTING HIGHLIGHT */

      this._unhighlightSelected ();
      this._unhighlightToday ();

      /* TODAY */

      if ( !(this.options.date.today instanceof Date) ) {

        this.options.date.today = new Date ();

      }

      /* INITIAL VALUE */

      this.set ( this.$input.val () );

      /* CURRENT */

      this.options.date.current = this._clampDate ( this.options.date.current || this.options.date.selected || this.options.date.today );

      /* REFRESH */

      this._refresh ();

    }

    _events () {

      this.___change ();
      this.___keydown ();
      this.___navigation ();
      this.___dayTap ();

    }

    /* PRIVATE */

    _cloneDate ( date ) {

      return new Date ( date.getTime () );

    }

    _clampDate ( date ) {

      return new Date ( _.clamp ( date.getTime (), this.options.date.min ? this.options.date.min.getTime () : undefined, this.options.date.max ? this.options.date.max.getTime () : undefined ) );

    }

    /* CHANGE */

    ___change () {

      this._on ( true, this.$input, 'change', this.__change );

    }

    __change ( event, data ) {

      if ( data && data._datepickerId === this.guid ) return;

      this.set ( this.$input.val () );

    }

    /* KEYDOWN */

    ___keydown () {

      this._onHover ( [$.$document, 'keydown', this.__keydown] );

    }

    /* NAVIGATION */

    ___navigation () {

      this._on ( this.$navigationPrev, Pointer.tap, event => this.__navigation ( 'previousMonth', event ) );
      this._on ( this.$navigationNext, Pointer.tap, event => this.__navigation ( 'nextMonth', event ) );
      this._on ( this.$navigationToday, Pointer.tap, event => this.__navigation ( 'navigateToToday', event ) );

    }

    __navigation ( method, event ) {

      event.preventDefault ();
      event.stopImmediatePropagation ();

      this[method]();

    }

    /* DAY TAP */

    ___dayTap () {

      this._on ( Pointer.tap, this.options.selectors.day.current, this.__dayTap );

    }

    __dayTap ( event ) {

      let $day = $(event.target).closest ( this.$daysCurrent );

      if ( $day.is ( this.options.selectors.day.selected ) || $day.is ( this.options.selectors.day.clamped ) ) return;

      let day = parseInt ( $day.text (), 10 ),
          date = new Date ( this.options.date.current.getFullYear (), this.options.date.current.getMonth (), day, 12 );

      this.set ( date );

    }

    /* BUILD */

    _buildCalendar () {

      /* NUMBERS */

      let prevMonthDays = new Date ( this.options.date.current.getFullYear (), this.options.date.current.getMonth (), 0 ).getDate (),
          currentMonthDays = new Date ( this.options.date.current.getFullYear (), this.options.date.current.getMonth () + 1, 0 ).getDate (),
          initialDayOfWeek = new Date ( this.options.date.current.getFullYear (), this.options.date.current.getMonth (), 1 ).getDay ();

      initialDayOfWeek = ( initialDayOfWeek === 0 ) ? 6 : initialDayOfWeek - 1; // Normalizing to 0 -> Monday
      initialDayOfWeek -= ( this.options.firstDayOfWeek % 7 ); // Offsetting according to the provided setting
      initialDayOfWeek = ( initialDayOfWeek < 0 ) ? 7 + initialDayOfWeek : initialDayOfWeek; // Moving to the other side in case of negative offsetting

      /* PREV */

      let exceedingDays = 31 - prevMonthDays,
          neededDays = initialDayOfWeek,
          leftDays = 9 - exceedingDays - neededDays;

      this.$daysPrev.slice ( 0, leftDays ).addClass ( this.options.classes.hidden );
      this.$daysPrev.slice ( leftDays, leftDays + neededDays ).removeClass ( this.options.classes.hidden );
      this.$daysPrev.slice ( leftDays + neededDays ).addClass ( this.options.classes.hidden );

      /* CURRENT */

      this.$daysCurrent.slice ( 28, currentMonthDays ).removeClass ( this.options.classes.hidden );
      this.$daysCurrent.slice ( currentMonthDays ).addClass ( this.options.classes.hidden );

      /* CURRENT CLAMPED */

      this.$daysCurrent.removeClass ( this.options.classes.clamped );

      if ( this.options.date.min && this.options.date.current.getFullYear () === this.options.date.min.getFullYear () && this.options.date.current.getMonth () === this.options.date.min.getMonth () ) {

        this.$daysCurrent.slice ( 0, this.options.date.min.getDate () - 1 ).addClass ( this.options.classes.clamped );

      }

      if ( this.options.date.max && this.options.date.current.getFullYear () === this.options.date.max.getFullYear () && this.options.date.current.getMonth () === this.options.date.max.getMonth () ) {

        this.$daysCurrent.slice ( this.options.date.max.getDate () ).addClass ( this.options.classes.clamped );

      }

      /* NEXT */

      neededDays = ( ( currentMonthDays + initialDayOfWeek ) % 7 );
      neededDays = ( neededDays === 0 ) ? 0 : 7 - neededDays;

      this.$daysNext.slice ( 0, neededDays ).removeClass ( this.options.classes.hidden );
      this.$daysNext.slice ( neededDays ).addClass ( this.options.classes.hidden );

    }

    /* HIGHLIGHT */

    _highlightDay ( day, cssClass ) {

      if ( day instanceof Date ) {

        let deltaMonths = ( day.getFullYear () * 12 + day.getMonth () ) - ( this.options.date.current.getFullYear () * 12 + this.options.date.current.getMonth () );

        switch ( deltaMonths ) {

          case -1:
            return this.$daysPrev.eq ( day.getDate () - 23 ).addClass ( cssClass );

          case 0:
            return this.$daysCurrent.eq ( day.getDate () - 1 ).addClass ( cssClass );

          case 1:
            return this.$daysNext.eq ( day.getDate () - 1 ).addClass ( cssClass );

        }

      }

      return false;

    }

    _unhighlightSelected () {

      if ( !this.$daySelected.length ) return;

      this.$daySelected.removeClass ( this.options.classes.selected );

    }

    _highlightSelected () {

      if ( this.options.date.selected ) {

        this.$daySelected = this._highlightDay ( this.options.date.selected, this.options.classes.selected );

      }

    }

    _unhighlightToday () {

      if ( !this.$dayToday.length ) return;

      this.$dayToday.removeClass ( this.options.classes.today );

    }

    _highlightToday () {

      if ( this.options.date.today ) {

        this.$dayToday = this._highlightDay ( this.options.date.today, this.options.classes.today );

      }

    }

    /* UPDATE */

    _updateNavigation () {

      /* PREVIOUS */

      if ( this.options.date.min && this.$navigationPrev.length ) {

        let lastDayPrevMonth = new Date ( this.options.date.current.getFullYear (), this.options.date.current.getMonth (), 0 );

        this.$navigationPrev.toggleClass ( this.options.classes.disabled, lastDayPrevMonth.getTime () < this.options.date.min.getTime () );

      }

      /* NEXT */

      if ( this.options.date.max && this.$navigationNext.length ) {

        let firstDayNextMonth = new Date ( this.options.date.current.getFullYear (), this.options.date.current.getMonth () + 1, 1 );

        this.$navigationNext.toggleClass ( this.options.classes.disabled, firstDayNextMonth.getTime () > this.options.date.max.getTime () );

      }

      /* TODAY */

      if ( this.$navigationToday.length ) {

        this.$navigationToday.toggleClass ( this.options.classes.disabled, this.options.date.current.getFullYear () === this.options.date.today.getFullYear () && this.options.date.current.getMonth () === this.options.date.today.getMonth () );

      }

    }

    _updateTitle () {

      this.$navigationTitle.text ( this.options.months[this.options.date.current.getMonth ()] + ' ' + this.options.date.current.getFullYear () );

    }

    _updateInput () {

      if ( this.options.date.selected ) {

        this.$input.val ( this._export ( this.options.date.selected ) ).trigger ( 'change', { _datepickerId: this.guid } );

      }

    }

    /* EXPORT */

    _export ( date )  {

      return this.options.exporters[this.options.format.type] ( date, this.options.format.data );

    }

    /* REQUIRE */

    _import ( date )  {

      return this.options.importers[this.options.format.type] ( date, this.options.format.data );

    }

    _refresh () {

      this._unhighlightSelected ();
      this._unhighlightToday ();

      this._buildCalendar ();

      this._updateNavigation ();

      this._highlightSelected ();
      this._highlightToday ();

      this._updateTitle ();

      this._trigger ( 'render' );

    }

    /* API */

    get ( formatted ) {

      return this.options.date.selected ? ( formatted ? this._export ( this.options.date.selected ) : this._cloneDate ( this.options.date.selected ) ) : false;

    }

    set ( date ) {

      date = ( date instanceof Date ) ? date : this._import ( date );

      if ( _.isNaN ( date.valueOf () ) ) return;

      date = this._clampDate ( date );

      if ( this.options.date.selected && date.getTime () === this.options.date.selected.getTime () ) return;

      if ( this.options.date.selected ) {

        this._unhighlightSelected ();

      }

      this.options.date.selected = date;

      if ( this.options.date.current ) {

        if ( this.options.date.selected.getFullYear () === this.options.date.current.getFullYear () && this.options.date.selected.getMonth () === this.options.date.current.getMonth () ) {

          this._highlightSelected ();

        } else {

          this.options.date.current = this._cloneDate ( this.options.date.selected );

          this._refresh ();

        }

      }

      this._updateInput ();

      this._trigger ( 'change' );

    }

    navigateToToday () {

      if ( this.options.date.current.getFullYear () !== this.options.date.today.getFullYear () || this.options.date.current.getMonth () !== this.options.date.today.getMonth () ) {

        this.options.date.current = this._clampDate ( this.options.date.today );

        this._refresh ();

      }

    }

    navigateMonth ( modifier ) {

      if ( _.isNaN ( modifier ) ) return;

      this.options.date.current.setMonth ( this.options.date.current.getMonth () + modifier );

      this.options.date.current = this._clampDate ( this.options.date.current );

      this._refresh ();

    }

    previousMonth () {

      this.navigateMonth ( -1 );

    }

    nextMonth () {

      this.navigateMonth ( 1 );

    }

  }

  /* FACTORY */

  Factory.make ( Datepicker, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Pointer ));


// @require core/widget/widget.js

//FIXME: Reposition the draggable properly when autoscrolling inside a container (not document/html)
//FIXME: On iOS, if the draggable is too close to the left edge of the screen dragging it will cause a `scroll to go back` event/animation on safari

(function ( $, _, Svelto, Factory, Animations, Browser, Pointer, Mouse ) {

  /* CONFIG */

  let config = {
    name: 'draggable',
    plugin: true,
    selector: '.draggable',
    options: {
      draggable: _.true, // Checks if we can drag it or not
      multitouch: { // Multitouch-related options
        enabled: false // Whether to abort on multitouch events or not
      },
      threshold: { // Minimum moving threshold for triggering a drag. They can also be functions that return the threshold
        touch () { // Enabled on touch events
          return this.options.axis ? 0 : 5; // If an axis is specified we disable the threshold, in order to enable scrolling
        },
        mouse: 0 // Enabled on mouse events
      },
      tolerance: { // If an axis is set, the draggable didn't move yet, and we drag by more than tolerance in the wrong axis we won't be able to drag it anymore. They can also be functions that return the tolerance
        touch: 0, // Enabled on touch events, it should be 0 since we want to black any scrolling from happeing
        mouse: 5 // Enabled on mouse events
      },
      onlyHandlers: false, // Only an handler can drag it around
      revert: false, // On dragend take it back to the starting position
      axis: false, // Limit the movements to this axis
      $helper: false, // An element to drag around instead of the draggable, can be `false` (in case the draggable will be dragged), a jQuery object or a function yiedling a jQuery object
      proxy: {
        $element: false, // Drag the element also when we are triggering a drag from this element
        noMotion: true // If enabled even if there's no motion the proxied draggable will get positionated to the dragend point event (e.g. just a tap)
      },
      constrainer: { // Constrain the drag inside the $element
        $element: false, // If we want to keep the draggable inside this $element
        center: false, // Set the constrain type, it will constrain the whole shape, or the center
        tolerance: { // The amount of pixel flexibility that a constrainer has
          x: 0,
          y: 0
        }
      },
      modifiers: { // It can modify the setted X and Y translation values
        x: _.true,
        y: _.true
      },
      scroll: { // Autoscroll the window when near the border
        active: false, // Active it or not
        speed: 20, // The amount of autoscroll
        sensitivity: 50 // How close it should be to tbe borders
      },
      classes: {
        dragging: 'draggable-dragging',
        reverting: 'draggable-reverting'
      },
      selectors: {
        handler: '.draggable-handler'
      },
      animations: {
        revert: Animations.fast
      },
      callbacks: {
        start: _.noop,
        move: _.noop,
        end: _.noop
      }
    }
  };

  /* DRAGGABLE */

  class Draggable extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.draggable = this.element;
      this.$draggable = this.$element;
      this.$movable = this.$draggable;

      this.$handlers = this.options.onlyHandlers ? this.$draggable.find ( this.options.selectors.handler ) : this.$draggable;

      this.__doMove = this._frames ( this.__doMove.bind ( this ) ); // For performance reasons

    }

    _events () {

      this.___down ();
      this.___proxy ();

    }

    /* UTILITIES */

    _getThreshold () {

      let threshold = this.isTouch ? this.options.threshold.touch : this.options.threshold.mouse;

      return _.isFunction ( threshold ) ? threshold.call ( this ) : threshold;

    }

    _getTolerance () {

      let tolerance = this.isTouch ? this.options.tolerance.touch : this.options.tolerance.mouse;

      return _.isFunction ( tolerance ) ? tolerance.call ( this ) : tolerance;

    }

    /* DOWN */

    ___down () {

      this._on ( this.$handlers, Pointer.down, this.__down );

    }

    /* PROXY */

    ___proxy () {

      if ( this.options.proxy.$element ) {

        this._on ( this.options.proxy.$element, Pointer.down, this.__down );

      }

    }

    /* ACTIONS */

    _centerToPoint ( XY, suppressClasses ) {

      let offset = this.$movable.offset (),
          rect = this.$movable.getRect (),
          deltaXY = {
            x: XY.x - ( offset.left + ( rect.width / 2 ) ),
            y: XY.y - ( offset.top + ( rect.height / 2 ) )
          };

      return this._actionMove ( deltaXY, suppressClasses );

    }

    _actionMove ( deltaXY, suppressClasses ) {

      /* INITIAL */

      this.initialXY = this.initialXY || this.$movable.translate ();

      /* INIT */

      if ( !this.inited ) {

        this.inited = true;

        /* CLAMPING VALUES */

        if ( this.options.constrainer.$element ) {

          let constrainerRect = this.options.constrainer.$element.getRect (),
              movableRect = this.$movable.getRect ();

          if ( this.options.axis !== 'y' ) {

            let halfWidth = this.options.constrainer.center ? movableRect.width / 2 : 0;

            this.translateX_min = constrainerRect.left - ( movableRect.left - this.initialXY.x ) - halfWidth;
            this.translateX_max = constrainerRect.left + constrainerRect.width - ( ( movableRect.left - this.initialXY.x ) + movableRect.width ) + halfWidth;

          }

          if ( this.options.axis !== 'x' ) {

            let halfHeight = this.options.constrainer.center ? movableRect.height / 2 : 0;

            this.translateY_min = constrainerRect.top - ( movableRect.top - this.initialXY.y ) - halfHeight;
            this.translateY_max = constrainerRect.top + constrainerRect.height - ( ( movableRect.top - this.initialXY.y ) + movableRect.height ) + halfHeight;

          }

        }

        /* CLASSES */

        if ( !suppressClasses ) {

          this._addClasses ();

        }

      }

      /* CLAMPING */

      let translateX = this.initialXY.x,
          translateY = this.initialXY.y;

      if ( this.options.axis !== 'y' ) {

        translateX += deltaXY.x;

        if ( this.options.constrainer.$element ) {

          translateX = _.clamp ( translateX, this.translateX_min - this.options.constrainer.tolerance.x, this.translateX_max + this.options.constrainer.tolerance.x );

        }

      }

      if ( this.options.axis !== 'x' ) {

        translateY += deltaXY.y;

        if ( this.options.constrainer.$element ) {

          translateY = _.clamp ( translateY, this.translateY_min - this.options.constrainer.tolerance.y, this.translateY_max + this.options.constrainer.tolerance.y );

        }

      }

      /* MODIFYING */

      let modifiedXY = {
            x: this.options.axis !== 'y' ? this.options.modifiers.x ( translateX ) : false,
            y: this.options.axis !== 'x' ? this.options.modifiers.y ( translateY ) : false
          };

      /* ABORTION */

      if ( modifiedXY.x === false && modifiedXY.y === false ) return this.initialXY;

      /* SETTING */

      let endXY = {
        x: _.isBoolean ( modifiedXY.x ) ? ( modifiedXY.x ? translateX : this.initialXY.x ) : modifiedXY.x,
        y: _.isBoolean ( modifiedXY.y ) ? ( modifiedXY.y ? translateY : this.initialXY.y ) : modifiedXY.y
      };

      this.$movable.translate ( endXY.x, endXY.y );

      /* MOTION */

      this.motion = true;

      /* RETURNING */

      return endXY;

    }

    /* CLASSES */

    _toggleClasses ( force ) {

      this.$layout.toggleClass ( this.options.classes.layout.priorityZIndex, force );
      this.$movable.toggleClass ( this.options.classes.dragging, force ).toggleClass ( this.options.classes.priorityZIndex, force );

    }

    _addClasses () {

      this._toggleClasses ( true );

    }

    _removeClasses () {

      this._toggleClasses ( false );

    }

    /* HELPER */

    _getHelper ( $draggable ) {

      return _.isFunction ( this.options.$helper )
               ? this.options.$helper ( $draggable )
               : this.options.$helper instanceof $ && this.options.$helper.length
                 ? this.options.$helper
                 : false;

    }

    _initHelper () {

      this.$helper.appendTo ( this.$layout );

    }

    _destroyHelper () {

      this.$helper.remove ();

    }

    /* AUTOSCROLL */

    _autoscroll ( pointXY ) {

      if ( !this.options.scroll.active ) return;

      if ( !this.scrollInited ) {

        this.$scrollParent = this.$movable.scrollParent ();
        this.scrollParent = this.$scrollParent[0];

        this.scrollParentIsDocument = ( this.scrollParent === document || this.scrollParent.tagName === 'HTML' );

        this.scrollInited = true;

      }

      // Logic taken from jQuery UI

  		if ( this.scrollParentIsDocument ) {

  			if ( this.options.axis !== 'x' ) {

          let scrollTop = $.document.scrollTop;

  				if ( pointXY.y - scrollTop <= this.options.scroll.sensitivity ) {

          	$.document.scrollTop = scrollTop - this.options.scroll.speed;

          } else if ( $.window.innerHeight - ( pointXY.y - scrollTop ) <= this.options.scroll.sensitivity ) {

          	$.document.scrollTop = scrollTop + this.options.scroll.speed;

          }

  			}

  			if ( this.options.axis !== 'y' ) {

          let scrollLeft = $.document.scrollLeft;

  				if ( pointXY.x - scrollLeft <= this.options.scroll.sensitivity ) {

          	$.document.scrollLeft = scrollLeft - this.options.scroll.speed;

          } else if ( $.window.innerWidth - ( pointXY.x - scrollLeft ) <= this.options.scroll.sensitivity ) {

          	$.document.scrollLeft = scrollLeft + this.options.scroll.speed;

          }

  			}

  		} else {

        let parentOffset = this.$scrollParent.offset ();

  			if ( this.options.axis !== 'x' ) {

  				if ( ( parentOffset.top + this.scrollParent.offsetHeight ) - pointXY.y <= this.options.scroll.sensitivity ) {

  					this.scrollParent.scrollTop += this.options.scroll.speed;

  				} else if ( pointXY.y - parentOffset.top <= this.options.scroll.sensitivity ) {

  					this.scrollParent.scrollTop -= this.options.scroll.speed;

  				}

  			}

  			if ( this.options.axis !== 'y' ) {

  				if ( ( parentOffset.left + this.scrollParent.offsetWidth ) - pointXY.x <= this.options.scroll.sensitivity ) {

  					this.scrollParent.scrollLeft += this.options.scroll.speed;

  				} else if ( pointXY.x - parentOffset.left <= this.options.scroll.sensitivity ) {

  					this.scrollParent.scrollLeft -= this.options.scroll.speed;

  				}

  			}

  		}

    }

    /* REVERT */

    _revert () {

      this.lock ();

      this._frame ( function () {

        this.$movable.addClass ( this.options.classes.reverting );

        this._frame ( function () {

          this.$movable.translate ( this.initialXY.x, this.initialXY.y );

          this._delay ( function () {

            this.$movable.removeClass ( this.options.classes.reverting );

            if ( this.$helper ) {

              this._destroyHelper ();

            }

            this.unlock ();

          }, this.options.animations.revert );

        });

      });

    }

    /* CLICK */

    __click ( event ) {

      if ( !this.motion ) return;

      event.preventDefault ();
      event.stopImmediatePropagation ();

    }

    /* DRAG START */

    __dragStart ( event ) { // We have to catch it or dragging `img`s on Firefox won't work reliably

      event.preventDefault ();
      event.stopImmediatePropagation ();

    }

    /* DRAG HANDLERS */

    __down ( event ) {

      if ( this.isLocked () || !this.options.draggable ( this ) || Mouse.hasButton ( event, Mouse.buttons.RIGHT ) ) return;

      if ( this.__isAbortable ( event ) ) return this.__abort ( event );

      event.stopImmediatePropagation ();

      this.inited = false;
      this.motion = false;
      this.skippable = true;
      this.scrollInited = false;
      this.ended = false;

      this.$helper = this._getHelper ( this.$draggable );
      this.helper = this.$helper ? this.$helper[0] : false;

      this.$movable = ( this.$helper || this.$draggable );

      this.startEvent = event;
      this.startXY = $.eventXY ( event );

      this.isProxyed = ( this.options.proxy.$element && event.currentTarget === this.options.proxy.$element[0] );

      this.initialXY = false;

      this._trigger ( 'start', { draggable: this.draggable, helper: this.helper, isProxyed: this.isProxyed, startEvent: this.startEvent, startXY: this.startXY } );

      this._on ( true, $.$document, Pointer.move, this.__move );
      this._one ( true, $.$document, Pointer.up, this.__up );
      this._one ( true, $.$document, Pointer.cancel, this.__cancel );
      this._one ( true, Pointer.click, this.__click );
      this._one ( true, $.$document, 'dragstart', this.__dragStart );

    }

    __move ( event ) {

      if ( this.__isAbortable ( event ) ) return this.__abort ( event );

      this.moveEvent = event;
      this.moveXY = $.eventXY ( event ),
      this.deltaXY = {
        x: this.moveXY.x - this.startXY.x,
        y: this.moveXY.y - this.startXY.y
      };

      if ( this.skippable ) {

        this.isTouch = Pointer.isTouchEvent ( event );

        let x = Math.abs ( this.deltaXY.x ),
            y = Math.abs ( this.deltaXY.y );

        /* TOLERANCE */

        if ( this.options.axis ) {

          let tolerance = this._getTolerance (),
              exceeded = ( this.options.axis === 'x' && y > tolerance && y > x ) || ( this.options.axis === 'y' && x > tolerance && x > y );

          if ( exceeded ) return this._off ( $.$document, Pointer.move, this.__move );

        }

        /* THRESHOLD */

        let threshold = this._getThreshold ();

        switch ( this.options.axis ) {
          case 'x':
            if ( x < threshold ) return;
            break;
          case 'y':
            if ( y < threshold ) return;
            break;
          default:
            if ( x < threshold && y < threshold ) return;
            break;
        }

        this.skippable = false;

      }

      event.preventDefault ();
      event.stopImmediatePropagation ();

      this.__doMove ();

    }

    __doMove () {

      if ( this.ended ) return;

      if ( !this.inited ) {

        if ( this.$helper ) {

          this._initHelper ();

        }

        if ( this.$helper || this.isProxyed ) {

          this.initialXY = this._centerToPoint ( this.startXY );

        }

      }

      let dragXY = this._actionMove ( this.deltaXY );

      this._autoscroll ( this.moveXY );

      this._trigger ( 'move', { draggable: this.draggable, helper: this.helper,isProxyed: this.isProxyed, initialXY: this.initialXY, startEvent: this.startEvent, startXY: this.startXY, moveEvent: this.moveEvent, moveXY: this.moveXY, dragXY: dragXY } );

    }

    __up ( event ) {

      event.preventDefault ();
      event.stopImmediatePropagation ();

      this.ended = true;

      let endXY = $.eventXY ( event ),
          dragXY = this.initialXY;

      if ( this.inited ) {

        this._removeClasses ();

      }

      if ( this.motion ) {

        if ( this.options.revert ) {

          this._revert ();

        } else if ( this.$helper ) {

          this._destroyHelper ();

        } else {

          dragXY = this.$movable.translate ();

        }

      } else if ( this.isProxyed && !this.$helper ) {

        if ( ( _.isFunction ( this.options.proxy.noMotion ) ? this.options.proxy.noMotion () : this.options.proxy.noMotion ) && Mouse.hasButton ( event, Mouse.buttons.LEFT, true ) ) {

          dragXY = this._centerToPoint ( endXY, true );

        }

      }

      this._off ( $.$document, Pointer.move, this.__move );
      this._off ( $.$document, Pointer.cancel, this.__cancel );
      this._off ( $.$document, 'dragstart', this.__dragStart );

      if ( this.startEvent.target !== event.target ) this._off ( Pointer.click, this.__click );

      this._trigger ( 'end', { draggable: this.draggable, helper: this.helper, isProxyed: this.isProxyed, initialXY: this.initialXY, startEvent: this.startEvent, startXY: this.startXY, endEvent: event, endXY: endXY, dragXY: dragXY, motion: this.motion } );

    }

    __cancel ( event ) {

      event.stopImmediatePropagation ();

      this.ended = true;

      let endXY = $.eventXY ( event ),
          dragXY = this.$movable.translate ();

      if ( this.inited ) {

        this._removeClasses ();

      }

      if ( this.motion ) {

        if ( this.options.revert ) {

          this._revert ();

          dragXY = this.initialXY;

        } else if ( this.$helper ) {

          this._destroyHelper ();

        }

      }

      this._off ( $.$document, Pointer.move, this.__move );
      this._off ( $.$document, Pointer.up, this.__up );
      this._off ( Pointer.click, this.__click );
      this._off ( $.$document, 'dragstart', this.__dragStart );

      this._trigger ( 'end', { draggable: this.draggable, helper: this.helper, initialXY: this.initialXY, startEvent: this.startEvent, startXY: this.startXY, endEvent: event, endXY: endXY, dragXY: dragXY, motion: this.motion, cancelled: true } );

    }

    __isAbortable ( event ) {

      if ( !this.options.multitouch.enabled ) {

        let originalEvent = event.originalEvent || event;

        if ( 'touches' in originalEvent && originalEvent.touches.length > 1 ) return true;

      }

      return false;

    }

    __abort ( event ) {

      this._off ( $.$document, Pointer.cancel, this.__cancel );

      this.__cancel ( event );

    }

  }

  /* FACTORY */

  Factory.make ( Draggable, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Animations, Svelto.Browser, Svelto.Pointer, Svelto.Mouse ));


// @require core/widget/widget.js
// @require lib/touching/touching.js
// @require widgets/draggable/draggable.js

(function ( $, _, Svelto, Factory ) {

  /* CONFIG */

  let config = {
    name: 'droppable',
    plugin: true,
    selector: '.droppable',
    options: {
      selector: '*', // Only Draggables matching this selector will be able to drop inside this Droppable
      classes: {
        target: undefined, // The class to attach to the Droppable if the Draggable can be dropped inside of it
        hover: undefined // The class to attach to the Droppable when hovered by a Draggable
      },
      callbacks: {
        enter: _.noop,
        leave: _.noop,
        drop: _.noop
      }
    }
  };

  /* DROPPABLE */

  class Droppable extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.droppable = this.element;
      this.$droppable = this.$element;

      this.__isCompatible = undefined;
      this._wasHovering = false;

    }

    _events () {

      this.___drag ();

    }

    /* PRIVATE */

    _isCompatible ( element ) {

      if ( _.isUndefined ( this.__isCompatible ) ) {

        this.__isCompatible = $(element).is ( this.options.selector );

        if ( this.__isCompatible ) {

          this.$droppable.addClass ( this.options.classes.target );

        }

      }

      return this.__isCompatible;

    }

    _isPointHovering ( pointXY, event  ) {

      let point = pointXY || $.eventXY ( event, 'clientX', 'clientY' );

      return !!this.$droppable.touching ({ point }).length;

    }

    /* DRAG */

    ___drag () {

      this.___dragMove ();
      this.___dragEnd ();

    }

    /* DRAG MOVE */

    ___dragMove () {

      this._on ( this.$layout, 'draggable:move', this._frames ( this.__dragMove.bind ( this ) ) );

    }

    __dragMove ( event, data ) {

      if ( !this._isCompatible ( data.draggable ) ) return;

      let isHovering = this._isPointHovering ( false, data.moveEvent );

      if ( isHovering !== this._wasHovering ) {

        this.$droppable.toggleClass ( this.options.classes.hover, isHovering );

        this._trigger ( isHovering ? 'enter' : 'leave', { draggable: data.draggable, helper: data.helper, droppable: this.droppable } );

      }

      this._wasHovering = isHovering;

    }

    /* DRAG END */

    ___dragEnd () {

      this._on ( this.$layout, 'draggable:end', this.__dragEnd );

    }

    __dragEnd ( event, data ) {

      if ( this._isCompatible ( data.draggable ) ) {

        this.$droppable.removeClass ( this.options.classes.target );

        if ( this._isPointHovering ( false, data.endEvent ) ) {

          if ( this._wasHovering ) {

            this.$droppable.removeClass ( this.options.classes.hover );

          }

          this._trigger ( 'drop', { draggable: data.draggable, helper: data.helper, droppable: this.droppable } );

        }

      }

      this.__isCompatible = undefined;

    }

  }

  /* FACTORY */

  Factory.make ( Droppable, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory ));


// @require core/widget/widget.js

(function ( $, _, Svelto, Factory, Pointer ) {

  /* CONFIG */

  let config = {
    name: 'flickable',
    plugin: true,
    selector: '.flickable',
    options: {
      duration: 150, // Maximum duration of the flick gesture
      threshold: 5, // Minimum moving threshold of the flick gesture
      callbacks: {
        flick: _.noop
      }
    }
  };

  /* FLICKABLE */

  class Flickable extends Svelto.Widget {

    /* SPECIAL */

    _events () {

      this.___down ();

    }

    /* DOWN */

    ___down () {

      this._on ( Pointer.down, this.__down );

    }

    __down ( event ) {

      this._startXY = $.eventXY ( event );
      this._startTimestamp = event.timeStamp || Date.now ();

      this._motion = false;

      this.___move ();
      this.___up ();
      this.___cancel ();

    }

    /* MOVE */

    ___move () {

      this._one ( true, $.$document, Pointer.move, this.__move );

    }

    __move () {

      this._motion = true;

    }

    /* UP */

    ___up () {

      this._one ( true, $.$document, Pointer.up, this.__up );

    }

    __up ( event ) {

      this._endTimestamp = event.timeStamp || Date.now ();

      if ( this._motion && ( this._endTimestamp - this._startTimestamp <= this.options.duration ) ) {

        let endXY = $.eventXY ( event ),
            deltaXY = {
              x: endXY.x - this._startXY.x,
              y: endXY.y - this._startXY.y
            },
            absDeltaXY = {
              x: Math.abs ( deltaXY.x ),
              y: Math.abs ( deltaXY.y )
            };

        if ( absDeltaXY.x >= this.options.threshold || absDeltaXY.y >= this.options.threshold ) {

          let orientation,
              direction;

          if ( absDeltaXY.x > absDeltaXY.y ) {

            orientation = 'horizontal';
            direction = ( deltaXY.x > 0 ) ? 'right' : 'left';

          } else {

            orientation = 'vertical';
            direction = ( deltaXY.y > 0 ) ? 'bottom' : 'top';

          }

          this._trigger ( 'flick', {
            orientation: orientation,
            direction: direction,
            startEvent: this._startEvent,
            startXY: this._startXY,
            endEvent: event,
            endXY: endXY
          });

        }

      }

      if ( !this._motion ) {

        this._off ( $.$document, Pointer.move, this.__move );

      }

      this._off ( $.$document, Pointer.cancel, this.__cancel );

    }

    /* CANCEL */

    ___cancel () {

      this._one ( true, $.$document, Pointer.cancel, this.__cancel );

    }

    __cancel () {

      if ( !this._motion ) {

        this._off ( $.$document, Pointer.move, this.__move );

      }

      this._off ( $.$document, Pointer.up, this.__up );

    }

  }

  /* FACTORY */

  Factory.make ( Flickable, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Pointer ));


// @require core/widget/widget.js

//TODO: Maybe add the ability to trigger a sync when widgetizing a new form in the group, so that if we are appending a new one it gets synced (as a base or not, if not maybe we can get a data-target or the first of othe others in the group as a base)

(function ( $, _, Svelto, Factory ) {

  /* CONFIG */

  let config = {
    name: 'formSync',
    plugin: true,
    selector: 'form[data-sync-group]',
    options: {
      live: false, // Basically it triggers the syncing also when the `input` event is fired
      attributes: {
        name: 'name'
      },
      datas: {
        group: 'sync-group'
      },
      selectors: {
        form: 'form',
        elements: 'input:not([type="button"]), textarea, select',
        checkable: '[type="radio"], [type="checkbox"]',
        radio: '[type="radio"]',
        checkbox: '[type="checkbox"]',
        textfield: 'input:not([type="button"]):not([type="checkbox"]):not([type="radio"]), textarea'
      }
    }
  };

  /* FORM SYNC */

  class FormSync extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$form = this.$element;
      this.$elements = this.$form.find ( this.options.selectors.elements );

      this.group = this.$form.data ( this.options.datas.group );

    }

    _events () {

      this.___change ();
      this.___input ();

    }

    /* CHANGE */

    ___change () {

      this._on ( true, this.$elements, 'change', this._debounce ( this.__sync, 100 ) );

    }

    /* INPUT */

    ___input () {

      if ( this.options.live ) {

        let $textfields = this.$elements.filter ( this.options.selectors.textfield );

        this._on ( true, $textfields, 'input', this._debounce ( this.__sync, 100 ) );

      }

    }

    /* SYNC */

    __sync ( event, data ) {

      if ( data && data._formSynced === this.group ) return;

      let $element = $(event.target),
          name = $element.attr ( this.options.attributes.name ),
          $otherElements = $(this.options.selectors.form + '[data-' + this.options.datas.group + '="' + this.group + '"]').not ( this.$form ).find ( '[' + this.options.attributes.name + '="' + name + '"]').not ( $element );

      if ( !$otherElements.length ) return;

      let value = $element.val (),
          checked = !!$element.prop ( 'checked' );

      for ( let i = 0, l = $otherElements.length; i < l; i++ ) {

        let otherElement = $otherElements[i],
            $otherElement = $(otherElement),
            otherValue = $otherElement.val (),
            otherChecked = !!$otherElement.prop ( 'checked' );

        if ( value === otherValue && checked === otherChecked ) continue;

        if ( $element.is ( this.options.selectors.radio ) && ( value !== otherValue || checked === otherChecked ) ) continue;

        if ( $element.is ( this.options.selectors.checkable ) ) {

          $otherElement.prop ( 'checked', checked ).trigger ( 'change', { _formSynced: this.group } );

        } else {

          $otherElement.val ( value ).trigger ( 'change', { _formSynced: this.group } );

        }

      }

    }

  }

  /* FACTORY */

  Factory.make ( FormSync, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory ));


// @require core/widget/widget.js
// @require lib/fullscreen/fullscreen.js

(function ( $, _, Svelto, Factory, Fullscreen ) {

  /* CONFIG */

  let config = {
    name: 'fullscreenable',
    plugin: true,
    selector: '.fullscreenable'
  };

  /* FULLSCREENABLE */

  class Fullscreenable extends Svelto.Widget {

    /* API */

    isFullscreen () {

      return Fullscreen.isFullscreen;

    }

    toggle ( force = !Fullscreen.isFullscreen ) {

      if ( !!force !== Fullscreen.isFullscreen ) {

        force ? this.request () : this.exit ();

      }

    }

    request () {

      Fullscreen.request ( this.element );

    }

    exit () {

      Fullscreen.exit ();

    }

  }

  /* FACTORY */

  Factory.make ( Fullscreenable, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Fullscreen ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto ) {

  /* ICON */

  let Icons = { // Maps each icon to its ligature/html entity, required for a  custom icon font
    'car': 'directions_car',
    'chevron-left': 'chevron_left',
    'chevron-right': 'chevron_right',
    'clock': 'access_time',
    'close': 'close',
    'cutlery': 'restaurant',
    'dots-horizontal': 'more_horiz',
    'emoticon': 'insert_emoticon',
    'flag': 'flag',
    'gym': 'fitness_center',
    'heart': 'favorite',
    'objects': 'devices_other',
    'page-first': 'first_page',
    'page-last': 'last_page',
    'paw': 'pets',
    'search': 'search'
  };

  let Icon = name => Icons[name];

  /* EXPORT */

  Svelto.Icons = Icons;
  Svelto.Icon = Icon;

}( Svelto.$, Svelto._, Svelto ));


// @require core/widget/widget.js

(function ( $, _, Svelto, Factory ) {

  /* CONFIG */

  let config = {
    name: 'infobar',
    plugin: true,
    selector: '.infobar',
    options: {
      callbacks: {
        close: _.noop
      }
    }
  };

  /* INFOBAR */

  class Infobar extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$infobar = this.$element;

    }

    /* API */

    close () {

      this.$infobar.detach ();

      this._trigger ( 'close' );

    }

  }

  /* FACTORY */

  Factory.make ( Infobar, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory ));


// @require core/browser/browser.js
// @require core/widget/widget.js

// It supports only `box-sizing: border-box` inputs

(function ( $, _, Svelto, Factory, Browser ) {

  /* CONFIG */

  let config = {
    name: 'inputAutogrow',
    plugin: true,
    selector: 'input.autogrow',
    options: {
      minWidth: 1, // So that the cursor will get displayed even when empty
      callbacks: {
        change: _.noop
      }
    }
  };

  /* INPUT AUTOGROW */

  class InputAutogrow extends Svelto.Widget {

    /* WIDGETIZE */

    static widgetize ( ele, Widget ) {

      /* SKIP IE/EDGE */

      //FIXME: input.scrollWidth is not supported by them, find another reliable way of implementing it

      if ( Browser.is.ie || Browser.is.edge ) return;

      /* WIDGETIZE */

      $.widget.get ( ele, Widget );

    }

    /* SPECIAL */

    _variables () {

      this.$input = this.$element;

      this.$tempInput = $('<input>').css ({
                          'position': 'fixed',
                          'visibility': 'hidden',
                          'padding': 0,
                          'min-width': 0,
                          'width': 0
                        });

    }

    _init () {

      this._update ();

    }

    _events () {

      this.___inputChange ();

    }

    /* PRIVATE */

    _getNeededWidth () {

      this.$tempInput.css ( 'font', this.$input.css ( 'font' ) ).val ( this.$input.val () ).appendTo ( this.$layout );

      let width = this.$tempInput[0].scrollWidth;

      this.$tempInput.detach ();

      return Math.max ( this.options.minWidth, width );

    }

    /* INPUT / CHANGE */

    ___inputChange () {

      this._on ( true, 'input change', this._update );

    }

    /* UPDATE */

    _update () {

      let width = this._getNeededWidth ();

      if ( width === this._prevWidth ) return;

      this._prevWidth = width;

      this.$input.width ( width );

      this._trigger ( 'change' );

    }

  }

  /* FACTORY */

  Factory.make ( InputAutogrow, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Browser ));


// @require core/widget/widget.js

(function ( $, _, Svelto, Factory ) {

  /* CONFIG */

  let config = {
    name: 'inputFileNames',
    plugin: true,
    selector: '.input-file-names',
    options: {
      placeholder: 'Select a file...',
      callbacks: {
        change: _.noop
      }
    }
  };

  /* INPUT FILE NAMES */

  class InputFileNames extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$names = this.$element;

      this.$input = this.$names.closest ( 'label' ).find ( 'input[type="file"]' );
      this.input = this.$input[0];

    }

    _init () {

      this.options.placeholder = this.$names.text () || this.options.placeholder;

      this._update ();

    }

    _events () {

      this.___change ();

    }

    /* PRIVATE */

    _getNames () {

      let names = [];

      for ( let i = 0, l = this.input.files.length; i < l; i++ ) {

        names.push ( this.input.files[i].name );

      }

      return names;

    }

    _getText () {

      let names = this._getNames ();

      return names.length ? names.join ( ', ' ) : this.options.placeholder;

    }

    /* CHANGE */

    ___change () {

      this._on ( true, this.$input, 'change', this._update );

    }

    /* UPDATE */

    _update () {

      let previous = this.$names.text (),
          current = this._getText ();

      if ( previous === current ) return;

      this.$names.text ( current );

      this._trigger ( 'change' );

    }

  }

  /* FACTORY */

  Factory.make ( InputFileNames, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory ));


// @require core/widget/widget.js
// @require widgets/draggable/draggable.js

(function ( $, _, Svelto, Factory ) {

  /* CONFIG */

  let config = {
    name: 'layoutResizable',
    plugin: true,
    selector: '.layout.resizable',
    templates: {
      sash: _.template ( '<div class="sash"></div>' )
    },
    options: {
      classes: {
        nosash: 'no-sash',
        vertical: 'vertical'
      }
    }
  };

  /* LAYOUT RESIZER */

  class LayoutResizer extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$layout = this.$element;
      this.$panes = this.$layout.children ();
      this.$sashes = $.$empty;
      this.isHorizontal = !this.$layout.hasClass ( this.options.classes.vertical );
      this.mapping = {}; // id => [$pane, $sash, hasSash, isResizable, minDimension, maxDimension, dimension]

    }

    _init () {

      this._initMapping ();

      this.$layout.prepend ( this.$sashes );

      this._updateDimension ();
      this._updateMapping ();
      this._updatePanes ();
      this._updateSashes ();

    }

    _events () {

      this.___drag ();
      this.___resize ();

    }

    /* HELPERS */

    _calcProp ( $ele, prop, fallback = 0 ) {

      return parseFloat ( $ele.css ( prop ) ) || fallback;

    }

    _initMapping () {

      this.$panes.get ().forEach ( ( pane, id ) => {

        const $pane = $(pane),
              isLast = id === ( this.$panes.length - 1 ),
              hasSash = !isLast && !$pane.hasClass ( this.options.classes.nosash ),
              isResizable = hasSash || ( id && this.mapping[id - 1][2] ),
              $sash = hasSash ? $(this._template ( 'sash' )) : undefined,
              minDimensionRaw = this._calcProp ( $pane, this.isHorizontal ? 'min-width' : 'min-height' ),
              minDimension = minDimensionRaw || ( this._calcProp ( $pane, this.isHorizontal ? 'padding-left' : 'padding-top' ) + this._calcProp ( $pane, this.isHorizontal ? 'padding-right' : 'padding-bottom' ) + this._calcProp ( $pane, this.isHorizontal ? 'border-left-width' : 'border-top-width' ) + this._calcProp ( $pane, this.isHorizontal ? 'border-right-width' : 'border-bottom-width' ) ) || 0,
              maxDimensionRaw = parseFloat ( $pane.css ( this.isHorizontal ? 'max-width' : 'max-height' ) ),
              maxDimension = maxDimensionRaw || Infinity,
              dimension = 0;

        this.mapping[id] = [$pane, $sash, hasSash, isResizable, minDimension, maxDimension, dimension];

        if ( !hasSash ) return;

        $sash[0]._resid = id;

        this.$sashes = this.$sashes.add ( $sash );

      });

    }

    _updateDimension () {

      this.dimension = this.isHorizontal ? this.$layout.outerWidth () : this.$layout.outerHeight ();

    }

    _updateMapping () {

      for ( let id in this.mapping ) {
        const mapping = this.mapping[id];
        const dimension = this.isHorizontal ? mapping[0].outerWidth () : mapping[0].outerHeight ();
        mapping[6] = dimension;
      }

    }

    _updatePanes () {

      for ( let id in this.mapping ) {
        const mapping = this.mapping[id];
        const $pane = mapping[0];
        const dimension = mapping[6];
        this.isHorizontal ? $pane.css ( 'width', dimension ) : $pane.css ( 'height', dimension );
        if ( !mapping[3] ) continue;
        $pane.css ( 'flex-basis', dimension ); // So that panes scale properly on resize
      }

    }

    _updateSashes () {

      let offset = 0;

      for ( let id in this.mapping ) {
        const mapping = this.mapping[id];
        const $sash = mapping[1];
        const dimension = mapping[6];
        offset += dimension;
        if ( !$sash ) continue;
        this.isHorizontal ? $sash.translateX ( offset ) : $sash.translateY ( offset );
      }

    }

    /* DRAGGING */

    ___drag () {

      this.$sashes.draggable ({
        axis: this.isHorizontal ? 'x' : 'y',
        classes: {
          layout: {
            priorityZIndex: 'layout-priority-z-index sash-dragging'
          }
        },
        callbacks: {
          start: this.__dragStart.bind ( this ),
          move: this.__dragMove.bind ( this ),
          end: this.__dragEnd.bind ( this )
        }
      });

    }

    __dragStart ( event, data ) {

      this._prevMoveXY = data.startXY;

    }

    __dragMove ( event, data ) {

      const {draggable, moveXY} = data,
            deltaDimension = this.isHorizontal ? moveXY.x - this._prevMoveXY.x : moveXY.y - this._prevMoveXY.y;

      if ( !deltaDimension ) return;

      const id = draggable._resid,
            mapping = this.mapping[id];

      // We are starting by decrementing because we can actually determine when we've reached the limit

      let decSign = Math.sign ( deltaDimension ), // Direction of the decrement
          decId = decSign > 0 ? id + 1 : id, // Next id to target
          incSign = - decSign, // Direction of the increment
          incId = incSign > 0 ? id + 1 : id, // Id to increment
          extraId = incId, // Just a copy of incId, so that we can mutate it
          remDimension = Math.abs ( deltaDimension ), // Amount of remaining dimension left to distribute
          extraDimension = remDimension, // Dimension that goes over max-dimension and therefore can't be assigned
          accDimension = 0; // Amount of accumulated dimension that has been redistributed

      while ( true ) { // Checking how much extra dimension there is

        const mapping = this.mapping[extraId];

        if ( !mapping ) break;

        if ( mapping[3] ) {

          extraDimension -= Math.min ( extraDimension, ( mapping[5] - mapping[6] ) )

          if ( !extraDimension ) break;

        }

        extraId += incSign;

      }

      remDimension -= extraDimension;

      while ( true ) { // Decreasing dimension

        const mapping = this.mapping[decId];

        if ( !mapping ) break;

        if ( mapping[3] ) {

          const dimensionNext = Math.max ( mapping[4], mapping[6] - remDimension ),
                distributedDimension = mapping[6] - dimensionNext;

          accDimension += distributedDimension;
          remDimension -= distributedDimension;

          mapping[6] = dimensionNext;

          if ( !remDimension ) break;

        }

        decId += decSign;

      }

      if ( !accDimension ) return;

      this.isHorizontal ? data.moveXY.x -= remDimension + extraDimension : data.moveXY.y -= remDimension + extraDimension; // Removing remaining dimension in order to improve the alignment between the cursor and the sash
      this._prevMoveXY = data.moveXY; // If this event didn't cause any change, we don't consider it at all

      while ( true ) { // Increasing dimension

        const mapping = this.mapping[incId];

        if ( !mapping ) break;

        if ( mapping[3] ) {

          const partial = Math.min ( accDimension, ( mapping[5] - mapping[6] ) );

          mapping[6] += partial;
          accDimension -= partial;

          if ( !accDimension ) break;

        }

        incId += incSign;

      }

      this._updatePanes ();

    }

    __dragEnd () {

      this._updateMapping ();
      this._updateSashes ();

    }

    /* RESIZE */

    ___resize () {

      this._on ( true, $.$window, 'resize', this._throttle ( this.__resize.bind ( this ), 500 ) );

    }

    __resize () {

      this._updateDimension ();
      this._updateMapping ();
      this._updateSashes ();

    }

  }

  /* FACTORY */

  Factory.make ( LayoutResizer, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory ));


// @require core/widget/widget.js

//FIXME: Doesn't actually check if the scroll event happened along the same direction of the key that has been pressed
// It can detect scroll only on the document

(function ( $, _, Svelto, Factory ) {

  /* CONFIG */

  let config = {
    name: 'pager',
    plugin: true,
    selector: '.pager',
    options: {
      selectors: {
        previous: '.previous',
        next: '.next'
      },
      keystrokes: {
        'left': 'previous',
        'right': 'next'
      }
    }
  };

  /* PAGER */

  class Pager extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$pager = this.$element;

    }

    _events () {

      this.___keydown ();

    }

    /* KEYDOWN */

    __keydown ( event ) {

      if ( this.isLocked () || $.isFocused ( document.activeElement ) ) return;

      this.lock ();

      this._scrolled = false;

      this.___scroll ();

      this._delay ( () => { // Waiting for the `scroll` event to fire and giving other event handlers precedence

        this.unlock ();

        if ( this._scrolled ) return;

        this.___scrollReset ();

        if ( $.isDefaultPrevented ( event ) ) return; // Probably another widget was listening for the same event, and it should take priority over this

        super.__keydown ( event );

      }, 50 ); //FIXME: Not exactly a solid implementation

    }

    /* SCROLL */

    ___scroll () {

      this._one ( true, $.$document, 'scroll', this.__scroll );

    }

    ___scrollReset () {

      this._off ( $.$document, 'scroll', this.__scroll );

    }

    __scroll () {

      this._scrolled = true;

    }

    /* API */

    previous () {

      let $previous = this.$pager.find ( this.options.selectors.previous );

      if ( !$previous.length ) return;

      $previous[0].click ();

    }

    next () {

      let $next = this.$pager.find ( this.options.selectors.next );

      if ( !$next.length ) return;

      $next[0].click ();

    }

  }

  /* FACTORY */

  Factory.make ( Pager, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory ));


// @require lib/embedded_css/embedded_css.js
// @require lib/positionate/positionate.js
// @require lib/touching/touching.js
// @require widgets/autofocusable/autofocusable.js

//FIXME: Close it if after a `route` event if the trigger element is no longer visible

(function ( $, _, Svelto, Widgets, Factory, Pointer, EmbeddedCSS, Animations ) {

  /* CONFIG */

  let config = {
    name: 'popover',
    plugin: true,
    selector: '.popover',
    options: {
      contentChangeEvents: 'change datepicker:change datepicker:render editor:fullscreen editor:unfullscreen editor:preview editor:unpreview inputautogrow:change tabs:change tablehelper:change tagbox:change textareaautogrow:change timeago:change', // When one of these events are triggered update the position because the content probably changed
      mustCloseEvents: 'modal:beforeopen modal:beforeclose panel:beforeopen panel:beforeclose', //FIXME: This way opening/closing a modal/panel from inside a popover while still keeping it open is not supported
      parentChangeEvents: 'popover:close modal:close panel:close editor:fullscreen editor:unfullscreen', // When one of these events happen, and the target is an anchestor of the anchor, we close the popover //FIXME: Ugly
      positionate: {}, // Extending `$.positionate` options
      spacing: {
        affixed: 0,
        fullscreen: 0,
        noTip: 5,
        normal: 12
      },
      classes: {
        anchorDirection: 'popover-anchor-$1',
        noTip: 'no-tip',
        affixed: 'affixed',
        fullscreen: 'fullscreen',
        fullscreenRequest: 'fullscreen-request',
        moving: 'moving',
        show: 'show',
        open: 'open'
      },
      animations: {
        open: Animations.fast,
        close: Animations.fast
      },
      keystrokes: {
        'esc': 'close'
      },
      callbacks: {
        beforeopen: _.noop,
        open: _.noop,
        beforeclose: _.noop,
        close: _.noop
      }
    }
  };

  /* POPOVER */

  class Popover extends Widgets.Autofocusable {

    /* SPECIAL */

    _variables () {

      this.$popover = this.$element;
      this.popover = this.$popover[0];

      this.$popover.addClass ( this.guc );

      this.hasTip = !this.$popover.hasClass ( this.options.classes.noTip );
      this.isAffixed = this.$popover.hasClass ( this.options.classes.affixed );
      this.isFullscreen = this.$popover.hasClass ( this.options.classes.fullscreen );

      this._isOpen = this.$popover.hasClass ( this.options.classes.open );

    }

    _events () {

      if ( this._isOpen ) {

        this.___contentChange ();
        this.___mustClose ();
        this.___parentChange ();
        this.___resize ();
        this.___parentsScroll ();
        this.___layoutTap ();
        this.___keydown ();

      }

    }

    _destroy () {

      this.close ();

    }

    /* CONTENT CHANGE */

    ___contentChange () {

      this._on ( true, this.options.contentChangeEvents, this._positionate );

    }

    /* MUST CLOSE */

    ___mustClose () {

      this._on ( true, this.$layout, this.options.mustCloseEvents, this.close );

    }

    /* PARENT CHANGE */

    ___parentChange () {

      this._on ( true, $.$document, this.options.parentChangeEvents, this.__parentChange );

    }

    __parentChange ( event ) {

      if ( !this.$anchor || !event.target.contains ( this.$anchor[0] ) ) return;

      if ( this.$anchor.isVisible () ) {

        this._positionate ();

      } else {

        this.close ();

      }

    }

    /* RESIZE */

    ___resize () {

      this._on ( true, $.$window, 'resize:width', this._frames ( this._positionate.bind ( this ) ) ); //FIXME: It should handle a generic parent `resize`-like event, not just on `$.$window`

    }

    /* PARENTS SCROLL */

    ___parentsScroll () {

      let $parents = this.$popover.parents ().add ( this.$anchor ? this.$anchor.parents () : undefined ).add ( $.$window );

      this._on ( true, $parents, 'scroll', this._frames ( this._positionate.bind ( this ) ) );

    }

    /* LAYOUT TAP */

    ___layoutTap () {

      this._on ( true, this.$layout, Pointer.tap, this.__layoutTap );

    }

    __layoutTap ( event ) {

      if ( this.isLocked () ) return;

      if ( $.isDefaultPrevented ( event ) ) return;

      if ( event === this._openEvent || this.$popover.touching ({ point: $.eventXY ( event, 'clientX', 'clientY' )} ).length ) return event.stopImmediatePropagation ();

      this.close ();

    }

    /* ESC */

    ___keydown () { //TODO: Listen to `keydown` only within the layout, so maybe just if the layout is hovered or focused (right?)

      this._on ( true, $.$document, 'keydown', this.__keydown );

    }

    /* POSITIONATE */

    _positionate () {

      /* VARIABLES */

      let isFullscreenRequested = this.$popover.hasClass ( this.options.classes.fullscreenRequest ),
          noTip = ( this.$anchor && this.$anchor.hasClass ( this.options.classes.noTip ) ) || !this.hasTip || this.isAffixed || this.isFullscreen || isFullscreenRequested,
          spacing = this.isAffixed
                      ? this.options.spacing.affixed
                      : this.isFullscreen || isFullscreenRequested
                        ? this.options.spacing.fullscreen
                        : noTip
                          ? this.options.spacing.noTip
                          : this.options.spacing.normal;

      /* POSITIONATE */

      this.$popover.positionate ( _.extend ({
        $anchor: this.$anchor,
        pointer: noTip ? false : 'auto',
        spacing: spacing,
        callbacks: {
          change: this.__positionChange.bind ( this )
        }
      }, this.options.positionate ));

    }

    _toggleAnchorDirectionClass ( direction, force ) {

      if ( !this.$anchor ) return;

      this.$anchor.toggleClass ( _.format ( this.options.classes.anchorDirection, direction ), force );

    }

    __positionChange ( data ) {

      /* ANCHOR CLASS */

      if ( this._prevDirection !== data.direction ) {

        if ( this._prevDirection ) {

          this._toggleAnchorDirectionClass ( this._prevDirection, false );

        }

        this._toggleAnchorDirectionClass ( data.direction, true );

        this._prevDirection = data.direction;

      }

    }

    /* API */

    isOpen () {

      return this._isOpen;

    }

    toggle ( force, anchor, event ) {

      if ( !_.isBoolean ( force ) ) {

        force = anchor && ( !this.$anchor || this.$anchor && this.$anchor[0] !== anchor ) ? true : ( this.$prevAnchor || this.$anchor || 'point' in this.options.positionate ? !this._isOpen : false );

      }

      return this[force ? 'open' : 'close']( anchor, event );

    }

    open ( anchor, event ) {

      /* RESTORING ANCHOR */

      if ( !anchor && this.$prevAnchor && !('point' in this.options.positionate) && !('$anchor' in this.options.positionate) ) {

        anchor = this.$prevAnchor[0];

      }

      /* CHECKING */

      if ( ( !anchor || ( this._isOpen && this.$anchor && anchor === this.$anchor[0] ) ) && !('point' in this.options.positionate) && !('$anchor' in this.options.positionate) ) return null;

      if ( this.isLocked () ) return this.whenUnlocked ( () => this.open ( anchor, event ) );

      /* VARIABLES */

      this.lock ();

      this._isOpen = true;
      this._openEvent = event;
      this._wasMoving = false;

      /* PREVIOUS ANCHOR */

      if ( this.$anchor ) {

        this._toggleAnchorDirectionClass ( this._prevDirection, false );
        this._prevDirection = false;

        this.$prevAnchor = this.$anchor;

        if ( this._isOpen ) {

          this._wasMoving = true;

          this.$popover.addClass ( this.options.classes.moving );

        }

      }

      /* ANCHOR */

      this.$anchor = anchor ? $(anchor) : this.options.positionate.$anchor || false;

      /* BEFORE OPENING */

      this._trigger ( 'beforeopen' );

      /* OPENING */

      this._frame ( function () {

        this.$popover.addClass ( 'show' );

        this._positionate ();

        this._frame ( function () {

          this.$popover.addClass ( this.options.classes.open );

          this.autofocus ();

          this.unlock ();

          this._trigger ( 'open' );

        });

      });

      /* EVENTS */

      this._reset ();

      this.___layoutTap ();
      this.___keydown ();
      this.___contentChange ();
      this.___mustClose ();
      this.___parentChange ();
      this.___resize ();
      this.___parentsScroll ();

    }

    close () {

      if ( !this._isOpen ) return null;

      if ( this.isLocked () ) return this.whenUnlocked ( this.close.bind ( this ) );

      /* VARIABLES */

      this.lock ();

      this._isOpen = false;

      /* ANCHOR */

      this._toggleAnchorDirectionClass ( this._prevDirection, false );
      this._prevDirection = false;

      this.$prevAnchor = this.$anchor;
      this.$anchor = false;

      /* CLOSING */

      this._trigger ( 'beforeclose' );

      this._frame ( function () {

        this.$popover.removeClass ( this.options.classes.open  );

        if ( this._wasMoving ) {

          this.$popover.removeClass ( this.options.classes.moving );

        }

        this._delay ( function () {

          this.$popover.removeClass ( this.options.classes.show );

          this.autoblur ();

          this.unlock ();

          this._trigger ( 'close' );

        }, this.options.animations.close );

      });

      /* RESETTING */

      this._reset ();

    }

  }

  /* FACTORY */

  Factory.make ( Popover, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory, Svelto.Pointer, Svelto.EmbeddedCSS, Svelto.Animations ));


// @require core/browser/browser.js
// @require widgets/popover/popover.js

//TODO: Add support for selecting multiple options (with checkboxes maybe)
//TODO: Add an input field for searching through the options

(function ( $, _, Svelto, Widgets, Factory, Browser, Pointer, Colors ) {

  /* CONFIG */

  let config = {
    name: 'select',
    plugin: true,
    selector: '.select',
    templates: {
      base: _.template ( `
        <div class="popover select-popover card <%= o.size %> <%= o.color %> <%= o.css %> <%= o.guc %>">
          <div class="card-block">
            <% for ( var i = 0, l = o.options.length; i < l; i++ ) { %>
              <% print ( Svelto.Templates.Select[ o.options[i].value ? 'option' : 'optgroup' ] ({ opt: o.options[i], color: o.color }) ) %>
            <% } %>
          </div>
        </div>
      ` ),
      optgroup: _.template ( `
        <div class="divider">
          <%= o.opt.prop %>
        </div>
      ` ),
      option: _.template ( `
        <div class="button <%= o.color %>" data-value="<%= o.opt.prop %>">
          <%= o.opt.value %>
        </div>
      ` )
    },
    options: {
      native: true, // Don't show the popover and use the native select, enabled by default
      popover: {
        size: '',
        color: Colors.white,
        css: Widgets.Popover.config.options.classes.affixed + ' bordered'
      },
      classes: {
        open: 'open active',
        selected: 'active highlighted highlight-left',
        affixed: Widgets.Popover.config.options.classes.affixed
      },
      datas: {
        value: 'value'
      },
      selectors: {
        select: 'select',
        option: 'option',
        valueholder: '.select-value',
        valueholderFallback: 'label:not(.no-value)',
        button: '.button'
      },
      callbacks: {
        change: _.noop,
        open: _.noop,
        close: _.noop
      }
    }
  };

  /* SELECT */

  class Select extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$wrp = this.$element;
      this.$select = this.$wrp.find ( this.options.selectors.select );
      this.$options = this.$select.find ( this.options.selectors.option );
      this.$valueholder = this.$wrp.find ( this.options.selectors.valueholder ).first ();

      if ( !this.$valueholder.length ) {

        this.$valueholder = this.$wrp.find ( this.options.selectors.valueholderFallback ).first ();

      }

      this.initialValueholder = this.$valueholder.text ();

      this.selectOptions = [];

      this.$popover = false;

    }

    _init () {

      this._updateValueholder ();

      if ( !this.options.native ) {

        this.$select.addClass ( this.options.classes.hidden );

        this.___selectOptions ();
        this.___popover ();

      }

    }

    _events () {

      this.___change ();

    }

    /* CHANGE */

    ___change () {

      this._on ( true, this.$select, 'change', this.__change );

    }

    __change () {

      this._update ();

      this._trigger ( 'change' );

    }

    /* BUTTON TAP */

    ___buttonTap () {

      if ( this.options.native ) return;

      /* BUTTON TAP */

      this._on ( this.$popover, Pointer.tap, this.options.selectors.button, this.__buttonTap );

    }

    __buttonTap ( event ) {

      event.stopImmediatePropagation ();

      this.$popover.popover ( 'close' );

      this.set ( $(event.target).closest ( this.$buttons ).data ( this.options.datas.value ) );

    }

    /* OPTIONS */

    ___selectOptions () { //FIXME: Add support for arbitrary number of optgroups nesting levels

      let previousOptgroup;

      for ( let i = 0, l = this.$options.length; i < l; i++ ) {

        let option = this.$options[i],
            $option = $(option),
            $parent = $option.parent ();

        if ( $parent.is ( 'optgroup' ) ) {

          let currentOptgroup = $parent.attr ( 'label' );

          if ( currentOptgroup !== previousOptgroup ) {

            previousOptgroup = currentOptgroup;

            this.selectOptions.push ({
              prop: currentOptgroup
            });

          }

        }

        let value = $option.text ();

        if ( value ) {

          this.selectOptions.push ({
            value: $option.text (),
            prop: $option.attr ( 'value' )
          });

        }

      }

    }

    /* POPOVER */

    ___popover () {

      let html = this._template ( 'base', _.extend ( { guc: this.guc, options: this.selectOptions }, this.options.popover ) );

      this.$popover = $(html).appendTo ( this.$layout );
      this.$buttons = this.$popover.find ( this.options.selectors.button );

      this.$popover.popover ({
        positionate: {
          axis: 'y',
          strict: true
        },
        callbacks: {
          beforeopen: this.__setPopoverWidth.bind ( this ),
          open: this.__popoverOpen.bind ( this ),
          close: this.__popoverClose.bind ( this )
        }
      });

      this.$wrp.attr ( `data-${Widgets.Targeter.config.options.datas.target}`, '.' + this.guc ).popoverToggler ();

      this._updatePopover ();

    }

    __setPopoverWidth () {

      if ( this.$popover.is ( '.' + this.options.classes.affixed ) ) {

        this.$popover.css ( 'min-width', this.$wrp.outerWidth () );

      }

    }

    __popoverOpen () {

      this.___buttonTap ();

      this.$wrp.addClass ( this.options.classes.open );

      this._trigger ( 'open' );

    }

    __popoverClose () {

      this._reset ();

      this.___change ();

      this.$wrp.removeClass ( this.options.classes.open );

      this._trigger ( 'close' );

    }

    /* UPDATE */

    _updateValueholder () {

      let value = this.$select.val ();

      if ( _.isString ( value ) ) { //FIXME: Is it needed?

        if ( value.length ) {

          let $selectedOption = this.$options.filter ( `[value="${value}"]` ).last ();

          this.$valueholder.text ( $selectedOption.text () );

        } else {

          this.$valueholder.text ( this.initialValueholder );

        }

      }

    }

    _updatePopover () {

      this.$buttons.removeClass ( this.options.classes.selected );

      this.$buttons.filter ( '[data-' + this.options.datas.value + '="' + this.$select.val () + '"]' ).last ().addClass ( this.options.classes.selected );

    }

    _update () {

      this._updateValueholder ();

      if ( !this.options.native ) {

        this._updatePopover ();

      }

    }

    /* API */

    get () {

      return this.$select.val ();

    }

    set ( value ) {

      let $button = this.$buttons.filter ( '[data-' + this.options.datas.value + '="' + value + '"]' );

      if ( !$button.length ) return;

      this.$select.val ( value ).trigger ( 'change' );

    }

  }

  /* FACTORY */

  Factory.make ( Select, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory, Svelto.Browser, Svelto.Pointer, Svelto.Colors ));


// @require core/widget/widget.js
// @require lib/storage/storage.js

(function ( $, _, Svelto, Factory, Storage ) {

  /* CONFIG */

  let config = {
    name: 'storable',
    selector: '.storable'
  };

  /* STORABLE */

  class Storable extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.storageNamespace = `swns.${this.name}`;

    }

    /* STORAGE */

    _storageGet ( key ) {

      return Storage.get ( `${this.storageNamespace}.${key}` );

    }

    _storageSet ( key, value, ttl ) {

      Storage.set ( `${this.storageNamespace}.${key}`, value, ttl );

    }

    _storageRemove ( key ) {

      Storage.remove ( `${this.storageNamespace}.${key}` );

    }

  }

  /* FACTORY */

  Factory.make ( Storable, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Storage ));


// @require core/widget/widget.js

//TODO: Better performance with tableHelper, just put the new addded row in the right position, performance boost

(function ( $, _, Svelto, Factory, Pointer ) {

  /* CONFIG */

  let config = {
    name: 'tableSortable',
    plugin: true,
    selector: 'table.sortable:not(.datatable)',
    options: {
      sorters: {
        int: function ( a, b ) {
          return parseInt ( a, 10 ) - parseInt ( b, 10 );
        },
        float: function ( a, b ) {
          return parseFloat ( a ) - parseFloat ( b );
        },
        string: function ( a, b ) {
          a = a.toLocaleLowerCase ();
          b = b.toLocaleLowerCase ();
          return a.localeCompare ( b );
        }
      },
      datas: {
        sorter: 'sort',
        value: 'sort-value'
      },
      classes: {
        sort: {
          asc: 'sort-asc',
          desc: 'sort-desc'
        }
      },
      selectors: {
        header: 'thead th',
        sortable: '[data-sort]',
        body: 'tbody',
        notEmptyRow: 'tr:not(.table-row-empty)',
        rowCell: 'td'
      },
      callbacks: {
        sort: _.noop
      }
    }
  };

  /* TABLE SORTABLE */

  class TableSortable extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$table = this.$element;
      this.$headers = this.$table.find ( this.options.selectors.header );
      this.$sortables = this.$headers.filter ( this.options.selectors.sortable );
      this.$tbody = this.$table.find ( this.options.selectors.body );

      this.table = this.element;
      this.tbody = this.$tbody[0];

      this.sortData = {}; // Caching object for datas and references to rows
      this.isDirty = true;

      this.$currentSortable = false;
      this.currentIndex = false; // `$headers` index, not `$sortables` index
      this.currentDirection = false;

    }

    _init () {

      let $initial = this.$headers.filter ( `.${this.options.classes.sort.asc}, .${this.options.classes.sort.desc}` ).first ();

      if ( $initial.length === 1 ) {

        this.sort ( this.$headers.index ( $initial ), ( $initial.hasClass ( this.options.classes.sort.asc ) ? 'asc' : 'desc' ) );

      }

    }

    _events () {

      this.___change ();
      this.___tap ();

    }

    /* CHANGE */

    ___change () {

      this._on ( true, 'change tablehelper:change', this.__change );

    }

    __change () {

      if ( this.currentIndex !== false ) {

        this.sortData = {};
        this.isDirty = true;

        this.sort ( this.currentIndex, this.currentDirection );

      }

    }

    /* TAP */

    ___tap () {

      this._on ( this.$sortables, Pointer.tap, this.__tap );

    }

    __tap ( event ) {

      let newIndex = this.$headers.index ( event.currentTarget ),
          newDirection = this.currentIndex === newIndex
                           ? this.currentDirection === 'asc'
                             ? 'desc'
                             : 'asc'
                           : 'asc';

      this.sort ( newIndex, newDirection );

    }

    /* SORT */

    sort ( index, direction ) {

      /* VALIDATE */

      let $sortable = this.$headers.eq ( index );

      if ( !$sortable.length ) return; // Bad index

      let sorterName = $sortable.data ( this.options.datas.sorter );

      if ( !sorterName ) return; // Unsortable column

      let sorter = this.options.sorters[sorterName];

      if ( !sorter ) return; // Unsupported sorter

      direction = ( direction && direction.toLowerCase () === 'desc' ) ? 'desc' : 'asc';

      /* CHECKING CACHED DATAS */

      if ( _.isUndefined ( this.sortData[index] ) || this.isDirty ) {

        /* VARIABLES */

        let $trs = this.$tbody.find ( this.options.selectors.notEmptyRow );

        this.sortData[index] = new Array ( $trs.length );

        /* POPULATE */

        for ( let i = 0, l = $trs.length; i < l; i++ ) {

          let $td = $trs.eq ( i ).find ( this.options.selectors.rowCell ).eq ( index ),
              value = $td.data ( this.options.datas.value ) || $td.text ();

          this.sortData[index][i] = [$trs[i], value];

        }

      }

      /* SORT */

      if ( index !== this.currentIndex || this.isDirty ) {

        this.sortData[index].sort ( function ( a, b ) {

          return sorter ( a[1], b[1] );

        });

      }

      /* REVERSING */

      let needReversing = false;

      if ( !this.isDirty && index === this.currentIndex && this.currentDirection !== false  ) {

        needReversing = ( direction !== this.currentDirection );

      } else {

        needReversing = ( direction === 'desc' );

      }

      if ( needReversing ) {

        this.sortData[index].reverse ();

      }

      /* REORDER */

      if ( index !== this.currentIndex || direction !== this.currentDirection || this.isDirty ) {

        this.table.removeChild ( this.tbody ); // Detach

        for ( let i = 0, l = this.sortData[index].length; i < l; i++ ) {

          this.tbody.appendChild ( this.sortData[index][i][0] ); // Reorder

        }

        this.table.appendChild ( this.tbody ); // Attach

      }

      /* STYLE */

      if ( index !== this.currentIndex || direction !== this.currentDirection ) {

        if ( this.$currentSortable ) {

          this.$currentSortable.removeClass ( this.options.classes.sort[this.currentDirection] );

        }

        $sortable.addClass ( this.options.classes.sort[direction] );

      }

      /* UPDATE */

      this.isDirty = false;

      this.$currentSortable = $sortable;
      this.currentIndex = index;
      this.currentDirection = direction;

      /* TRIGGER */

      this._trigger ( 'sort', {
        index: this.currentIndex,
        direction: this.currentDirection
      });

    }

  }

  /* FACTORY */

  Factory.make ( TableSortable, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Pointer ));


// @require core/widget/widget.js

(function ( $, _, Svelto, Factory ) {

  /* CONFIG */

  let config = {
    name: 'tableHelper',
    plugin: true,
    selector: 'table.table',
    templates: {
      row: _.template ( `
        <tr <%= o.id ? 'class=' + o.id : '' %> >
          <% for ( var i = 0, l = o.datas.length; i < l; i++ ) { %>
            <td><%= o.datas[i] %></td>
          <% } %>
          <% for ( var i = 0, l = o.missing; i < l; i++ ) { %>
            <td></td>
          <% } %>
        </tr>
      ` )
    },
    options: {
      rowIdPrefix: 'srid',
      selectors: {
        header: 'thead',
        body: 'tbody',
        headerCell: 'th',
        rowCell: 'td',
        emptyRow: 'tr.table-row-empty',
        notEmptyRow: 'tr:not(.table-row-empty)'
      },
      callbacks: {
        change: _.noop,
        add: _.noop,
        update: _.noop,
        remove: _.noop,
        clear: _.noop
      }
    },
  };

  /* TABLE HELPER */

  class TableHelper extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$table = this.$element;
      this.$header = this.$table.find ( this.options.selectors.header );
      this.$body = this.$table.find ( this.options.selectors.body );
      this.$headerCells = this.$header.find ( this.options.selectors.headerCell );
      this.$emptyRow = this.$body.find ( this.options.selectors.emptyRow );

      this.columnsNr = this.$headerCells.length;

    }

    /* PRIVATE */

    _getRowId ( id ) {

      return this.options.rowIdPrefix + '-' + this.guid + '-' + id;

    }

    /* API */

    add ( id, ...datas ) {

      let rowId = id ? this._getRowId ( id ) : false;

      if ( datas.length ) {

        if ( rowId && $( '.' + rowId ).length === 1 ) return;

        let chunks = _.chunk ( datas, this.columnsNr ),
            $rows = $();

        chunks.forEach ( chunk => {

          let rowHtml = this._template ( 'row', { id: rowId, datas: chunk, missing: this.columnsNr - chunk.length } ),
              $row = $(`<table>${rowHtml}</table>`).find ( 'tr' ); // Parsing a `tr` tag without a table might not be supported by the DOM library

          $rows = $rows.add ( $row );

        });

        this.$body.append ( $rows );

        this._trigger ( 'change' );

        this._trigger ( 'add', {
          $rows: $rows
        });

      }

    }

    update ( id, ...datas ) {

      let $row = $( '.' + this._getRowId ( id ) );

      if ( datas.length && $row.length === 1 ) {

        let $rowCells = $row.find ( this.options.selectors.rowCell );

        for ( let i = 0, l = datas.length; i < l; i++ ) {

          if ( _.isString ( datas[i] ) ) {

            $rowCells.eq ( i ).html ( datas[i] );

          }

        }

        this._trigger ( 'change' );

        this._trigger ( 'update', {
          $row: $row
        });

      }

    }

    remove ( id ) {

      let $row = $( '.' + this._getRowId ( id ) );

      if ( $row.length === 1 ) {

        $row.remove ();

        this._trigger ( 'change' );

        this._trigger ( 'remove', {
          $row: $row
        });

      }

    }

    clear () {

      let $rows = this.$body.find ( this.options.selectors.notEmptyRow );

      if ( $rows.length ) {

        $rows.remove ();

        this._trigger ( 'change' );

        this._trigger ( 'clear', {
          $rows: $rows
        });

      }

    }

  }

  /* FACTORY */

  Factory.make ( TableHelper, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory ));


// @require core/widget/widget.js

(function ( $, _, Svelto, Factory ) {

  /* CONFIG */

  let config = {
    name: 'targeter',
    options: {
      widget: false, // The target's widget class
      target: false, // Selector used to select the target
      $fallback: false, // Fallback jQuery element
      datas: {
        target: 'target'
      }
    }
  };

  /* TARGETER */

  class Targeter extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this._targetSelector = this.options.target || ( this.options.widget ? this.$element.data ( `${this.options.widget.config.name.toLowerCase ()}-${this.options.datas.target}` ) : false ) || this.$element.data ( this.options.datas.target );

      this.$target = this._targetSelector
                       ? $(this._targetSelector)
                       : this.options.widget
                         ? this.$element.closest ( this.options.widget.config.selector )
                         : this.options.$fallback;

      this.$target = this.$target.length ? this.$target : this.options.$fallback;

      if ( !this.$target.length ) return false;

      this.target = this.$target[0];

      if ( this.options.widget ) this._targetInstance = this.$target[this.options.widget.config.name]( 'instance' );

    }

    _events () {

      this.___targetRemove ();

    }

    /* TARGET REMOVE */

    ___targetRemove () {

      this._on ( true, this.$target, 'remove', this.__targetRemove );

    }

    __targetRemove ( event ) {

      this.__remove ( event );

    }

  }

  /* FACTORY */

  Factory.make ( Targeter, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory ));


// @require ../targeter.js

(function ( $, _, Svelto, Widgets, Factory, Pointer ) {

  /* CONFIG */

  let config = {
    name: 'closer',
    options: {
      methods: {
        isOpen: 'isOpen',
        close: 'close'
      }
    }
  };

  /* CLOSER */

  class Closer extends Widgets.Targeter {

    /* SPECIAL */

    _events () {

      super._events ();

      this.___tap ();

    }

    /* TAP */

    ___tap () {

      this._on ( Pointer.tap, this.__tap );

    }

    __tap ( event ) {

      this.close ( event );

    }

    /* API */

    isOpen () {

      return this._targetInstance[this.options.methods.isOpen]();

    }

    close ( event ) {

      this._targetInstance.whenUnlocked ( () => this._targetInstance[this.options.methods.close]( this.element, event ) );

    }

  }

  /* FACTORY */

  Factory.make ( Closer, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory, Svelto.Pointer ));


// @require ../fullscreenable.js
// @require widgets/targeter/closer/closer.js

(function ( $, _, Svelto, Widgets, Factory ) {

  /* CONFIG */

  let config = {
    name: 'fullscreenableExiter',
    plugin: true,
    selector: '.fullscreenable-exiter, .fullscreen-exiter',
    options: {
      widget: Widgets.Fullscreenable,
      $fallback: $.$html,
      methods: {
        isOpen: 'isFullscreen',
        close: 'exit'
      }
    }
  };

  /* FULLSCREENABLE EXITER */

  class FullscreenableExiter extends Widgets.Closer {}

  /* FACTORY */

  Factory.make ( FullscreenableExiter, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory ));


// @require ../infobar.js
// @require widgets/targeter/closer/closer.js

(function ( $, _, Svelto, Widgets, Factory ) {

  /* CONFIG */

  let config = {
    name: 'infobarCloser',
    plugin: true,
    selector: '.infobar-closer',
    options: {
      widget: Widgets.Infobar
    }
  };

  /* INFOBAR CLOSER */

  class InfobarCloser extends Widgets.Closer {}

  /* FACTORY */

  Factory.make ( InfobarCloser, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory ));


// @require ../popover.js
// @require widgets/targeter/closer/closer.js

(function ( $, _, Svelto, Widgets, Factory ) {

  /* CONFIG */

  let config = {
    name: 'popoverCloser',
    plugin: true,
    selector: '.popover-closer',
    options: {
      widget: Widgets.Popover
    }
  };

  /* POPOVER CLOSER */

  class PopoverCloser extends Widgets.Closer {}

  /* FACTORY */

  Factory.make ( PopoverCloser, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory ));


// @require ../closer/closer.js
// @require core/browser/browser.js

(function ( $, _, Svelto, Widgets, Factory, Browser, Pointer ) {

  /* CONFIG */

  let config = {
    name: 'opener',
    options: {
      hover: {
        active: false,
        delays: {
          open: 750,
          close: 250
        }
      },
      methods: {
        open: 'open'
      }
    }
  };

  /* OPENER */

  class Opener extends Widgets.Closer {

    /* SPECIAL */

    _events () {

      super._events ();

      this.___hover ();

    }

    /* TAP */

    __tap ( event ) {

      this.open ( event );

    }

    /* HOVER */

    ___hover () {

      if ( this.options.hover.active ) {

        this._on ( Pointer.enter, this.__hoverEnter );

      }

    }

    __hoverEnter () {

      if ( !this.isOpen () ) {

        this._isHoverOpen = false;

        this._hoverOpenTimeout = this._delay ( this.__hoverOpen, this.options.hover.delays.open );

        this._one ( true, Pointer.leave, this.__hoverLeave );

      } else if ( this._isHoverOpen ) {

        if ( this._hoverCloseTimeout ) {

          clearTimeout ( this._hoverCloseTimeout );

          this._hoverCloseTimeout = false;

        }

        this._one ( true, Pointer.leave, this.__hoverLeave );

      }

    }

    __hoverOpen () {

      if ( !this.isOpen () ) {

        this.open ();

        this._isHoverOpen = true;

      }

      this._hoverOpenTimeout = false;

    }

    __hoverLeave  () {

      if ( this._hoverOpenTimeout ) {

        clearTimeout ( this._hoverOpenTimeout );

        this._hoverOpenTimeout = false;

      }

      if ( this.isOpen () && this._isHoverOpen ) {

        this._hoverCloseTimeout = this._delay ( this.__hoverClose, this.options.hover.delays.close );

        this._one ( true, this.$target, Pointer.enter, this.__hoverTargetEnter );

      }

    }

    __hoverClose () {

      if ( this.isOpen () && this._isHoverOpen ) {

        this.close ();

      }

      this._isHoverOpen = false;

      this._hoverCloseTimeout = false;

      this._off ( this.$target, Pointer.enter, this.__hoverTargetEnter );

    }

    __hoverTargetEnter () {

      if ( this._hoverCloseTimeout ) {

        clearTimeout ( this._hoverCloseTimeout );

        this._hoverCloseTimeout = false;

      }

      if ( this.isOpen () && this._isHoverOpen ) {

        this._one ( true, this.$target, Pointer.leave, this.__hoverTargetLeave );

      }

    }

    __hoverTargetLeave () {

      if ( this.isOpen () && this._isHoverOpen ) {

        this._hoverCloseTimeout = this._delay ( this.__hoverClose, this.options.hover.delays.close );

        this._one ( true, this.$target, Pointer.enter, this.__hoverTargetEnter );

      }

    }

    /* API */

    open ( event ) {

      this._targetInstance.whenUnlocked ( () => this._targetInstance[this.options.methods.open]( this.element, event ) );

    }

  }

  /* FACTORY */

  Factory.make ( Opener, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory, Svelto.Browser, Svelto.Pointer ));


// @require ../fullscreenable.js
// @require widgets/targeter/opener/opener.js

(function ( $, _, Svelto, Widgets, Factory ) {

  /* CONFIG */

  let config = {
    name: 'fullscreenableRequester',
    plugin: true,
    selector: '.fullscreenable-requester, .fullscreen-requester',
    options: {
      widget: Widgets.Fullscreenable,
      $fallback: $.$html,
      methods: {
        open: 'request'
      }
    }
  };

  /* FULLSCREENABLE REQUESTER */

  class FullscreenableRequester extends Widgets.Opener {}

  /* FACTORY */

  Factory.make ( FullscreenableRequester, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory ));


// @require ../popover.js
// @require widgets/targeter/opener/opener.js

(function ( $, _, Svelto, Widgets, Factory ) {

  /* CONFIG */

  let config = {
    name: 'popoverOpener',
    plugin: true,
    selector: '.popover-opener',
    options: {
      widget: Widgets.Popover
    }
  };

  /* POPOVER OPENER */

  class PopoverOpener extends Widgets.Opener {}

  /* FACTORY */

  Factory.make ( PopoverOpener, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory ));


// @require core/animations/animations.js
// @require core/pointer/pointer.js
// @require widgets/targeter/opener/opener.js

//TODO: Test with nested layouts
//TODO: Make it work with nested scrollable elements
// It only scrolls properly when the elements are not nested inside scrollable wrappers

(function ( $, _, Svelto, Widgets, Factory, Pointer, Animations ) {

  /* CONFIG */

  let config = {
    name: 'scroller',
    plugin: true,
    selector: '.scroller',
    options: {
      animations: {
        scroll: Animations.fast
      },
      callbacks: {
        scroll: _.noop
      }
    }
  };

  /* SCROLLER */

  class Scroller extends Widgets.Targeter {

    /* SPECIAL */

    _events () {

      super._events ();

      this.___tap ();

    }

    /* TAP */

    ___tap () {

      this._on ( Pointer.tap, this.__tap );

    }

    __tap ( event ) {

      this.scroll ();

    }

    /* API */

    scroll () {

      $.scrollTo ( this.target, { duration: this.options.animations.scroll } );

      this._trigger ( 'scroll' );

    }

  }

  /* FACTORY */

  Factory.make ( Scroller, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory, Svelto.Pointer, Svelto.Animations ));


// @require ../opener/opener.js

(function ( $, _, Svelto, Widgets, Factory ) {

  /* CONFIG */

  let config = {
    name: 'toggler',
    options: {
      methods: {
        toggle: 'toggle'
      }
    }
  };

  /* TOGGLER */

  class Toggler extends Widgets.Opener {

    /* TAP */

    __tap ( event ) {

      this.toggle ( undefined, event );

    }

    /* API */

    toggle ( force, event ) {

      return this._targetInstance[this.options.methods.toggle]( force, this.element, event );

    }

  }

  /* FACTORY */

  Factory.make ( Toggler, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory ));


// @require ../fullscreenable.js
// @require widgets/targeter/toggler/toggler.js

(function ( $, _, Svelto, Widgets, Factory ) {

  /* CONFIG */

  let config = {
    name: 'fullscreenableToggler',
    plugin: true,
    selector: '.fullscreenable-toggler, .fullscreen-toggler',
    options: {
      widget: Widgets.Fullscreenable,
      $fallback: $.$html
    }
  };

  /* FULLSCREENABLE TOGGLER */

  class FullscreenableToggler extends Widgets.Toggler {}

  /* FACTORY */

  Factory.make ( FullscreenableToggler, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory ));


// @require ../popover.js
// @require widgets/targeter/toggler/toggler.js

(function ( $, _, Svelto, Widgets, Factory ) {

  /* CONFIG */

  let config = {
    name: 'popoverToggler',
    plugin: true,
    selector: '.popover-toggler',
    options: {
      widget: Widgets.Popover
    }
  };

  /* POPOVER TOGGLER */

  class PopoverToggler extends Widgets.Toggler {}

  /* FACTORY */

  Factory.make ( PopoverToggler, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory ));


// @require core/widget/widget.js

// It supports only `box-sizing: border-box` textareas

(function ( $, _, Svelto, Factory ) {

  /* CONFIG */

  let config = {
    name: 'textareaAutogrow',
    plugin: true,
    selector: 'textarea.autogrow',
    options: {
      callbacks: {
        change: _.noop
      }
    }
  };

  /* AUTOGROW TEXTAREA */

  class AutogrowTextarea extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$textarea = this.$element;

      this.$tempTextarea = $('<textarea>').css ({
                              'position': 'fixed',
                              'visibility': 'hidden',
                              'padding': 0,
                              'min-height': 0,
                              'height': 0
                            });

    }

    _init () {

      this._update ();

    }

    _events () {

      this.___inputChange ();

    }

    /* PRIVATE */

    _getNeededHeight () {

      this.$tempTextarea.css ( 'font', this.$textarea.css ( 'font' ) ).val ( this.$textarea.val () || ' ' ).appendTo ( this.$layout ); // Ensuring that there's at least a space character inside of it fixed a bug in IE/Edge where the textarea gets shrinked

      let height = this.$tempTextarea[0].scrollHeight;

      this.$tempTextarea.detach ();

      return height;

    }

    /* INPUT / CHANGE */

    ___inputChange () {

      this._on ( true, 'input change', this._update );

    }

    /* UPDATE */

    _update () {

      let height = this._getNeededHeight ();

      if ( height === this._prevHeight ) return;

      this.$textarea.height ( height );

      this._prevHeight = height;

      this._trigger ( 'change' );

    }

  }

  /* FACTORY */

  Factory.make ( AutogrowTextarea, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory ));


// @require core/widget/widget.js

(function ( $, _, Svelto, Factory ) {

  /* CONFIG */

  let config = {
    name: 'textareaSender',
    plugin: true,
    selector: 'form textarea',
    options: {
      selectors: {
        form: 'form'
      },
      keystrokes: {
        'ctmd + enter': 'send'
      }
    }
  };

  /* TEXTAREA SENDER */

  class TextareaSender extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$textarea = this.$element;

      this.$form = this.$textarea.closest ( this.options.selectors.form );

    }

    _events () {

      this.___keydown ();

    }

    /* KEYDOWN */

    ___keydown ( $target ) {

      this._on ( this.$textarea, 'keydown', this.__keydown );

    }

    /* SEND */

    send () {

      const $submit = this.$form.find ( '[type="submit"]' );

      if ( $submit.length ) {

        $submit[0].click ();

      } else {

        this.$form[0].submit ();

      }

    }

  }

  /* FACTORY */

  Factory.make ( TextareaSender, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory ));


// @require core/widget/widget.js

(function ( $, _, Svelto, Factory ) {

  /* CONFIG */

  let config = {
    name: 'timeAgo',
    plugin: true,
    selector: '.timeago, .time-ago',
    options: {
      template: '[timeago]', // Template used for rendering the text
      timestamp: false, // UNIX timestamp
      title: false, // Update the title or the text?
      abort: { // Abort the loop if it has to wait more than `threshold`
        enabled: true, // Whether the abort functionality should be enabled (recommended, at least to avoid overflowing the delay https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)
        threshold: 604800, // 1 week
      },
      datas: {
        template: 'template',
        timestamp: 'timestamp'
      },
      callbacks: {
        change: _.noop
      }
    }
  };

  /* TIME AGO */

  class TimeAgo extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$timeAgoElement = this.$element;

    }

    _init () {

      this.options.template = this.$timeAgoElement.data ( this.options.datas.template ) || this.options.template;

      if ( !this.options.timestamp ) {

        this.options.timestamp = this.$timeAgoElement.data ( this.options.datas.timestamp );

      }

      this._loop ();

    }

    _destroy () {

      clearTimeout ( this.loopId );

    }

    /* LOOP */

    _loop ( seconds = 0 ) {

      if ( this.options.abort.enabled && seconds > this.options.abort.threshold ) return;

      this.loopId = this._delay ( function () {

        this._loop ( this._update ().next );

      }, seconds * 1000 );

    }

    /* UPDATE */

    _update () {

      let timeAgo = _.timeAgo ( this.options.timestamp ),
          str = this.options.template.replace ( '[timeago]', timeAgo.str );;

      if ( this.options.title ) {

        this.$timeAgoElement.attr ( 'title', str );

      } else {

        this.$timeAgoElement.text ( str );

      }

      this._trigger ( 'change' );

      return timeAgo;

    }

    /* API OVERRIDES */

    enable () {

      super.enable ();

      this._loop ();

    }

    disable () {

      super.disable ();

      clearTimeout ( this.loopId );

    }

  }

  /* FACTORY */

  Factory.make ( TimeAgo, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Timer ));


// @require core/svelto/svelto.js

(function ( $, _, Svelto, Widgets ) {

  /* TOASTS */

  class Toasts {

    constructor () {

      this.reset ();

      this.___visibility ();

    }

    /* GENERAL */

    get () {

      return this.toasts;

    }

    set ( toasts ) {

      this.toasts = toasts;

    }

    reset () {

      this.set ( [] );

    }

    add ( toast ) {

      if ( this.toasts.includes ( toast ) ) return;

      this.toasts.push ( toast );

    }

    remove ( toast ) {

      _.pull ( this.toasts, toast );

    }

    /* HOVERING */

    isHovering () {

      return !!this.hovering;

    }

    setHovering ( hovering ) {

      this.hovering = hovering;

    }

    /* VISIBILITY */

    ___visibility () {

      $.$document.on ( 'visibilitychange', this.__visibility.bind ( this ) );

    }

    __visibility () {

      if ( !this.toasts.length || this.isHovering () ) return;

      if ( document.hidden ) {

        this.pause ();

      } else {

        this.resume ();

      }

    }

    /* API MAPPING */

    _callMethod ( method ) {

      for ( let i = this.toasts.length - 1; i >= 0; i-- ) { // The array might get mutated in the process

        this.toasts[i][method]();

      }

    }

    open () {

      this._callMethod ( 'open' );

    }

    close () {

      this._callMethod ( 'close' );

    }

    pause () {

      this._callMethod ( 'pause' );

    }

    resume () {

      this._callMethod ( 'resume' );

    }

  };

  /* EXPORT */

  Widgets.Toasts = new Toasts ();

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets ));


 // @require core/animations/animations.js
 // @require core/colors/colors.js
 // @require core/sizes/sizes.js
 // @require lib/timer/timer.js
 // @require widgets/autofocusable/autofocusable.js
 // @require widgets/toasts/toasts.js

//TODO: Add support for dismissing a toast that contains only one button
//TODO: Add better support for swipe to dismiss

(function ( $, _, Svelto, Toasts, Widgets, Factory, Pointer, Timer, Animations, Colors, Sizes ) {

  /* CONFIG */

  let config = {
    name: 'toast',
    plugin: true,
    selector: '.toast',
    templates: {
      queues: _.template ( `
        <div class="toast-queues top">
          <div class="toast-queue expanded"></div>
          <div class="toast-queues-row">
            <div class="toast-queue left"></div>
            <div class="toast-queue center"></div>
            <div class="toast-queue right"></div>
          </div>
        </div>
        <div class="toast-queues bottom">
          <div class="toast-queues-row">
            <div class="toast-queue left"></div>
            <div class="toast-queue center"></div>
            <div class="toast-queue right"></div>
          </div>
          <div class="toast-queue expanded"></div>
        </div>
      ` ),
      base: _.template ( `
        <div class="toast <%= o.type %> <%= o.color %> <%= o.type !== 'action' ? 'actionable' : '' %> <%= o.css %>">
          <div class="infobar <%= Svelto.Colors.transparent %>">
            <% if ( o.img ) { %>
              <img src="<%= o.img %>" class="toast-img infobar-left">
            <% } %>
            <% if ( o.icon ) { %>
              <i class="icon <%= o.title && o.body ? 'xlarge' : '' %> infobar-left"><%= o.icon %></i>
            <% } %>
            <% if ( o.title || o.body ) { %>
              <div class="infobar-center">
                <% if ( o.title ) { %>
                  <p class="infobar-title">
                      <%= o.title %>
                    </p>
                <% } %>
                <% if ( o.body ) { %>
                  <%= o.body %>
                <% } %>
              </div>
            <% } %>
            <% if ( o.buttons.length === 1 ) { %>
              <div class="infobar-right">
                <% print ( Svelto.Templates.Toast.button ( o.buttons[0] ) ) %>
              </div>
            <% } %>
          </div>
          <% if ( o.buttons.length > 1 ) { %>
            <div class="toast-buttons multiple center-x">
              <% for ( var i = 0; i < o.buttons.length; i++ ) { %>
                <% print ( Svelto.Templates.Toast.button ( o.buttons[i] ) ) %>
              <% } %>
            </div>
          <% } %>
        </div>
      ` ),
      button: _.template ( `
        <div class="button <%= o.color || Svelto.Colors.white %> <%= o.size || Svelto.Sizes.small %> <%= o.css || '' %>">
          <%= o.text || '' %>
        </div>
      ` )
    },
    options: {
      anchor: { // Used for selecting the proper queue where this Toast should be attached
        x: 'left',
        y: 'bottom'
      },
      title: false,
      body: false,
      img: false,
      icon: false,
      buttons: [],
      /*
             : [{
                color: Colors.white,
                size: Sizes.small,
                css: '',
                text: '',
                onClick: _.noop // If it returns `false` the Toast won't be closed
             }],
      */
      type: 'alert',
      color: Colors.black,
      css: '',
      persistent: false, // Whether it should survive a change of page or not. Needed when used in frameworks like Meteor
      autoplay: true,
      ttl: 3500,
      ttlMinimumRemaining: 1000, // Auto-closing will be stopped on hover and started again on leave, with a remaining time of `Math.min ( what the remaining time was, this option )`;
      classes: {
        open: 'open'
      },
      selectors: {
        queues: '.toast-queues',
        queue: '.toast-queue',
        button: '.toast-buttons .button, .infobar-right .button'
      },
      animations: {
        open: Animations.normal,
        close: Animations.normal
      },
      keystrokes: {
        'esc': 'close'
      },
      callbacks: {
        open: _.noop,
        close: _.noop
      }
    }
  };

  /* TOAST */

  class Toast extends Widgets.Autofocusable {

    /* READY */

    static ready ( done ) {

      setTimeout ( function () { // In order to better support client size rendering //TODO: Maybe do this lazily

        const queues = Toast.config.templates.queues ();

        $.$layout.append ( queues );

        done ();

      });

    }

    /* SPECIAL */

    _variables () {

      this.$toast = this.$element;
      this.$buttons = this.$toast.find ( this.options.selectors.button );

      this.timer = false;
      this._openUrl = false;

      this._isOpen = this.$toast.hasClass ( this.options.classes.open );

    }

    _init () {

      this.$toast.widgetize ();

      if ( this._isOpen ) {

        this.___timer ();
        this.___tap ();
        this.___flick ();
        this.___buttonTap ();
        this.___enter ();
        this.___leave ();
        this.___persistent ();
        this.___keydown ();
        this.___breakpoint ();

      } else if ( this.options.autoplay ) {

        let whenReady = Toast.whenReady || Toast.__proto__.whenReady || Svelto.Widget.whenReady; //IE10 support -- static property

        whenReady.bind ( Toast )( this.open.bind ( this ) );

      }

    }

    /* PRIVATE */

    _getUrl () {

      return window.location.href.split ( '#' )[0];

    }

    /* TIMER */

    ___timer () {

      if ( this.options.type !== 'action' && _.isNumber ( this.options.ttl ) && !_.isNaN ( this.options.ttl ) && this.options.ttl !== Infinity ) {

        if ( !this.timer ) {

          this.timer = new Timer ( this.close.bind ( this ), this.options.ttl, !document.hidden );

        } else {

          this.timer.reset ();

        }

        Toasts.add ( this );

      }

    }

    /* TAP */

    ___tap () {

      if ( this.options.type !== 'action' ) {

        this._on ( Pointer.tap, this.__tap );

      }

    }

    __tap ( event ) {

      event.preventDefault (); // Otherwise the click goes through the toast in Chrome for iOS

      this.close ();

    }

    /* BUTTON TAP */

    ___buttonTap () {

      this._on ( this.$buttons, Pointer.tap, this.__buttonTap );

    }

    __buttonTap ( event, data ) {

      let $button = $(event.target),
          index = this.$buttons.index ( $button ),
          buttonObj = this.options.buttons[index];

      if ( buttonObj.onClick ) {

        if ( buttonObj.onClick.apply ( $button[0], [event, data] ) === false ) return;

      }

      this.close ();

    }

    /* ENTER */

    ___enter () {

      this._on ( true, Pointer.enter, this.__enter );

    }

    __enter () {

      Toasts.setHovering ( true );
      Toasts.pause ();

    }

    /* LEAVE */

    ___leave () {

      this._on ( true, Pointer.leave, this.__leave );

    }

    __leave () {

      Toasts.setHovering ( false );

      if ( !document.hidden ) {

        Toasts.resume ();

      }

    }

    /* FLICK */

    ___flick () {

      if ( this.options.type !== 'action' ) {

        this.$toast.flickable ({
          callbacks: {
            flick: this.__flick.bind ( this )
          }
        });

      }

    }

    __flick ( event, data ) {

      if ( data.orientation === 'horizontal' ) {

        this.close ();

      }

    }

    /* PERSISTENT */

    ___persistent () {

      if ( !this.options.persistent ) {

        this.___route ();

      }

    }

    __route () {

      let currentUrl = this._getUrl ();

      if ( this._openUrl && this._openUrl !== currentUrl ) {

        this.close ();

      }

    }

    /* RESET */

    _reset () {

      /* TOASTS */

      Toasts.remove ( this );

      /* FLICK */

      this.$toast.flickable ( 'destroy' );

      /* SUPER */

      super._reset ();

    }

    /* API */

    isOpen () {

      return this._isOpen;

    }

    open () {

      if ( this._isOpen ) return null;

      if ( this.isLocked () ) return this.whenUnlocked ( this.open.bind ( this ) );

      this.lock ();

      this._isOpen = true;

      this._frame ( function () {

        $(this.options.selectors.queues + '.' + this.options.anchor.y + ' ' + this.options.selectors.queue + '.' + this.options.anchor.x).append ( this.$toast );

        this._frame ( function () {

          this.$toast.addClass ( this.options.classes.open );

          this.autofocus ();

          this.unlock ();

          this._trigger ( 'open' );

        });

      });

      this.___timer ();
      this.___tap ();
      this.___flick ();
      this.___buttonTap ();
      this.___enter ();
      this.___leave ();
      this.___persistent ();
      this.___keydown ();
      this.___breakpoint ();

      this._defer ( function () {

        this._openUrl = this._getUrl ();

      });

    }

    close () {

      if ( !this._isOpen ) return null;

      if ( this.isLocked () ) return this.whenUnlocked ( this.close.bind ( this ) );

      this.lock ();

      this._isOpen = false;
      this._openUrl = false;

      this._frame ( function () {

        this.$toast.removeClass ( this.options.classes.open );

        this.autoblur ();

        this._delay ( function () {

          this.$toast.remove ();

          this.unlock ();

          this._trigger ( 'close' );

        }, this.options.animations.close );

      });

      this._reset ();

    }

    pause () {

      this.timer.pause ();

    }

    resume () {

      this.timer.remaining ( Math.max ( this.options.ttlMinimumRemaining, this.timer.remaining () ) ).play ();

    }

  }

  /* FACTORY */

  Factory.make ( Toast, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets.Toasts, Svelto.Widgets, Svelto.Factory, Svelto.Pointer, Svelto.Timer, Svelto.Animations, Svelto.Colors, Svelto.Sizes ));


Svelto.Widgets.Toast.config.options.anchor.x = 'right';


// @optional widgets/remote/action/action_helper.js
// @optional widgets/remote/modal/modal_helper.js
// @optional widgets/remote/panel/panel_helper.js
// @optional widgets/remote/popover/popover_helper.js
// @require widgets/targeter/targeter.js
// @require widgets/toast/toast.js

//FIXME: Shouldn't extend `Targeter`, but `SelectableActions` needs that

(function ( $, _, Svelto, Widgets, Factory, Pointer ) {

  /* CONFIG */

  let config = {
    name: 'actions',
    plugin: true,
    selector: '.actions',
    options: {
      $fallback: $.$html, //FIXME: Ugly, but needed in order to extend from `Targeter`
      ajax: {}, // Default values
      actions: {
        action: $.remoteAction,
        modal: $.remoteModal,
        panel: $.remotePanel,
        popover: $.remotePopover,
        page ( ajax ) {
          window.location.href = ajax.url;
        }
      },
      defaultAction: 'page',
      actionsArgs: {
        ajax ( $trigger ) {
          return this._getAjax ( $trigger );
        },
        panel ( $trigger ) {
          return [this._getAjax ( $trigger ), $trigger.data ( Widgets.Panel.config.options.datas.direction ), $trigger.data ( Widgets.Panel.config.options.datas.type )];
        },
        popover ( $trigger ) {
          return [this._getAjax ( $trigger ), $trigger];
        }
      },
      defaultActionArgs: 'ajax',
      characters: {
        separator: ','
      },
      attributes: {
        href: 'href' // In order to better support `a` elements (the data value has higher priority)
      },
      datas: {
        type: 'type',
        url: 'url',
        body: 'body',
        method: 'method'
      },
      selectors: {
        action: '.action'
      },
      callbacks: {
        action: _.noop
      }
    }
  };

  /* ACTIONS */

  class Actions extends Widgets.Targeter {

    /* SPECIAL */

    _variables () {

      super._variables ();

      this.$actions = this.$element.find ( this.options.selectors.action );

    }

    _events () {

      super._events ();

      this.___action ();

    }

    /* UTILITIES */

    _getAjax ( $trigger ) {

      let url = $trigger.data ( this.options.datas.url ) || $trigger.attr ( this.options.attributes.href ) || this.options.ajax.url,
          body = $trigger.data ( this.options.datas.body ) || this.options.ajax.body || {},
          method = $trigger.data ( this.options.datas.method ) || this.options.ajax.method;

      return _.extend ( {}, this.options.ajax, { url, body, method } );

    }

    _getArgs ( type, $trigger ) {

      let fn = this.options.actionsArgs[type] || this.options.actionsArgs[this.options.defaultActionArgs];

      if ( !fn ) return;

      let args = fn.call ( this, $trigger );

      return args ? _.castArray ( args ) : false;

    }

    /* ACTION */

    ___action () {

      this._on ( this.$actions, Pointer.tap, this.__action );

    }

    __action ( event ) {

      let $trigger = $(event.currentTarget),
          type = $trigger.data ( this.options.datas.type ) || this.options.defaultAction,
          action = this.options.actions[type];

      if ( !action ) return;

      let args = this._getArgs ( type, $trigger );

      if ( !args ) return;

      action ( ...args );

      this._trigger ( 'action', { type, args } );

    }

  }

  /* FACTORY */

  Factory.make ( Actions, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets, Svelto.Factory, Svelto.Pointer ));


// @require core/widget/widget.js
// @require lib/validator/validator.js
// @require widgets/toast/toast.js

//TODO: Add support for multiple checkboxes validation
//TODO: Add meta validators that accepts other validators as arguments, for example not[email], oppure not[matches[1,2,3]] oppure or[email,url] etc... maybe write it this way: or[matches(1-2-3)/matches(a-b-c)], or just use a smarter regex
//TODO: Maybe make it generic (so that it can be used in single elements) and just call it `validate`

(function ( $, _, Svelto, Factory, Validator ) {

  /* CONFIG */

  let config = {
    name: 'formValidate',
    plugin: true,
    selector: 'form.validate',
    templates: {
      message: _.template ( `
        <p class="form-validate-message <%= o.validity %>">
          <%= o.message %>
        </p>
      ` ),
      messages: _.template ( `
        <ul class="form-validate-message <%= o.validity %>">
          <% for ( var i = 0, l = o.messages.length; i < l; i++ ) { %>
            <li><%= o.messages[i] %></li>
          <% } %>
        </ul>
      ` )
    },
    options: {
      validators: { // If not found here it will use `Validator`'s validators
        required ( value ) {
          return !Validator.empty ( value );
        },
        values ( value, ...values ) {
          return Validator.included ( value, values );
        },
        field ( value, fieldName ) {
          const fieldValue = this.elementsByName[fieldName].value;
          return ( value === fieldValue );
        },
        checked () {
          return this.context.$element.prop ( 'checked' );
        },
        regex ( value, regex ) {
          return !!value.match ( new RegExp ( regex ) );
        }
      },
      messages: {
        form: {
          invalid: 'The form contains some errors',
        },
        validators: {
          invalid: {
            general: 'This value is not valid',
            alpha: 'Only alphabetical characters are allowed',
            alphanumeric: 'Only alphanumeric characters are allowed',
            hexadecimal: 'Only hexadecimal characters are allowed',
            number: 'Only numbers are allowed',
            integer: 'Only integers numbers are allowed',
            float: 'Only floating point numbers are allowed',
            min: 'The number must be at least $2',
            max: 'The number must be at maximum $2',
            range: 'The number must be between $2 and $3',
            minLength: 'The length must be at least $2',
            maxLength: 'The length must be at maximum $2',
            rangeLength: 'The length must be between $2 and $3',
            exactLength: 'The length must be exactly $2',
            email: 'Enter a valid email address',
            creditCard: 'Enter a valid credit card number',
            ssn: 'Enter a valid Social Security Number',
            ipv4: 'Enter a valid IPv4 address',
            url: 'Enter a valid URL',
            required: 'This field is required',
            values: 'This value is not allowed',
            field: 'The two fields don\'t match',
            checked: 'This must be checked'
          }
        }
      },
      characters: {
        separators: {
          validations: '|',
          arguments: ','
        }
      },
      regexes: {
        validation: /^([^\[]+)(?:\[(.*)\])?$/
      },
      datas: {
        id: '_fveid',
        validations: 'validations',
        messages: {
          invalid: 'invalid',
          valid: 'valid'
        }
      },
      classes: {
        invalid: 'invalid',
        valid: 'valid'
      },
      selectors: {
        element: 'input:not([type="button"]), textarea, select',
        textfield: 'input:not([type="button"]):not([type="checkbox"]):not([type="radio"]), textarea',
        wrapper: '.checkbox, .colorpicker, .datepicker, .editor, .radio, .select, .slider, .switch',
        output: '.form-validate-output'
      }
    }
  };

  /* FORM VALIDATE */

  class FormValidate extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$form = this.$element;
      this.$output = this.$form.find ( this.options.selectors.output );
      this.$elements = this.$form.find ( this.options.selectors.element );
      this.$textfields = this.$elements.filter ( this.options.selectors.textfield );

      this.___elements ();

    }

    _events () {

      this.___change ();
      this.___focus ();
      this.___blur ();
      this.___submit ();

    }

    /* ELEMENTS */

    ___elements () {

      this.elements = {};
      this.elementsByName = {};

      for ( let i = 0, l = this.$elements.length; i < l; i++ ) {

        let element = this.$elements[i],
            $element = $(element),
            $wrappers = $element.parents ( this.options.selectors.wrapper ),
            isWrapped = !!$wrappers.length,
            $wrapper = isWrapped ? $wrappers.first () : $element,
            id = $.guid++,
            validationsStr = $element.data ( this.options.datas.validations ),
            validations = false;

        if ( validationsStr ) {

          let validationsArr = validationsStr.split ( this.options.characters.separators.validations );

          validationsArr.forEach ( validationStr => {

            let matches = validationStr.match ( this.options.regexes.validation );

            if ( !matches ) return;

            let validationName = matches[1],
                validationArgs = matches[2] ? matches[2].split ( this.options.characters.separators.arguments ) : [],
                validator = this.options.validators[validationName] || Validator[validationName];

            if ( !validator ) return;

            if ( !validations ) validations = {};

            validations[validationName] = {
              args: validationArgs,
              validator: validator
            };

          });

        }

        element[this.options.datas.id] = id;

        this.elements[id] = {
          id: id,
          $element: $element,
          $wrapper: $wrapper,
          $message: false,
          name: element.name,
          value: $element.val (),
          validations: validations,
          isDirty: false,
          isValid: undefined,
          messages: {
            invalid: isWrapped ? $element.data ( this.options.datas.messages.invalid ) || $wrapper.data ( this.options.datas.messages.invalid ) : $element.data ( this.options.datas.messages.invalid ),
            valid: isWrapped ? $element.data ( this.options.datas.messages.valid ) || $wrapper.data ( this.options.datas.messages.valid ) : $element.data ( this.options.datas.messages.valid )
          }
        };

        this.elementsByName[this.elements[id].name] = this.elements[id];

      }

    }

    /* UPDATE */

    _updateElement ( elementObj ) {

      /* FORM */

      this._isValid = undefined;

      /* ELEMENT */

      elementObj.isDirty = true;
      elementObj.isValid = undefined;

      this._validateWorker ( elementObj );

      /* OTHERS */

      for ( let id in this.elements ) {

        if ( !this.elements.hasOwnProperty ( id ) ) continue;

        if ( id === elementObj.id ) continue;

        let otherElementObj = this.elements[id],
            isDepending = otherElementObj.validations && 'field' in otherElementObj.validations && otherElementObj.validations.field.args.indexOf ( elementObj.name ) !== -1,
            hasSameName = elementObj.name.length && otherElementObj.name === elementObj.name;

        if ( isDepending || hasSameName ) {

          otherElementObj.isValid = undefined;

          this._validateWorker ( otherElementObj );

        }

      }

    }

    _updateElements () {

      for ( let id in this.elements ) {

        if ( !this.elements.hasOwnProperty ( id ) ) continue;

        this._updateElement ( this.elements[id] );

      }

    }

    /* CHANGE */

    ___change () {

      this._on ( true, this.$elements, 'change', this.__change );

    }

    __change ( event ) {

      this._updateElement ( this.elements[event.currentTarget[this.options.datas.id]] );

    }

    /* FOCUS */

    ___focus () {

      this._on ( this.$textfields, 'focus', this.__focus );

    }

    __focus ( event ) {

      let elementObj = this.elements[event.currentTarget[this.options.datas.id]];

      elementObj.isValid = undefined;

      this.__indeterminate ( elementObj );

    }

    /* BLUR */

    ___blur () {

      this._on ( this.$textfields, 'blur', this.__blur );

    }

    __blur ( event ) {

      let elementObj = this.elements[event.currentTarget[this.options.datas.id]];

      this._validateWorker ( elementObj );

    }

    /* SUBMIT */

    ___submit () {

      this._on ( true, 'submit', this.__submit );

    }

    __submit ( event ) {

      this._updateElements ();

      if ( !this.isValid () ) {

        event.preventDefault ();
        event.stopImmediatePropagation ();

        $.toast ( this.options.messages.form.invalid );

      }

    }

    /* VALIDATION */

    _validateWorker ( elementObj ) {

      if ( _.isUndefined ( elementObj.isValid ) ) {

        let result = this._validate ( elementObj ),
            isValid = ( result === true );

        elementObj.isValid = isValid;

        if ( isValid ) {

          this.__valid ( elementObj );

        } else {

          this.__invalid ( elementObj, result );

        }

      }

    }

    _validate ( elementObj ) {

      let errors = [],
          validations = elementObj.validations;

      if ( elementObj.isDirty ) {

        elementObj.value = elementObj.$element.val ();

        elementObj.isDirty = false;

      }

      if ( validations ) {

        for ( let name in validations ) {

          if ( !validations.hasOwnProperty ( name ) ) continue;

          this.context = elementObj;

          let validation = validations[name],
              isValid = validation.validator.call ( this, elementObj.value, ...validation.args );

          if ( !isValid ) {

            let error = _.format ( this.options.messages.validators.invalid[name] || this.options.messages.validators.invalid.general, elementObj.value, ...validation.args );

            errors.push ( error );

          }

        }

      }

      return !errors.length ? true : errors;

    }

    /* STATE */

    __indeterminate ( elementObj ) {

      elementObj.$wrapper.removeClass ( this.options.classes.invalid + ' ' + this.options.classes.valid );

      this._updateMessage ( elementObj, false );

    }

    __valid ( elementObj ) {

      elementObj.$wrapper.removeClass ( this.options.classes.invalid ).addClass ( this.options.classes.valid );

      this._updateMessage ( elementObj, elementObj.messages.valid );

    }

    __invalid ( elementObj, errors ) {

      elementObj.$wrapper.removeClass ( this.options.classes.valid ).addClass ( this.options.classes.invalid );

      this._updateMessage ( elementObj, elementObj.messages.invalid || errors );

    }

    /* ERRORS */

    _updateMessage ( elementObj, message ) {

      if ( elementObj.$message ) {

        elementObj.$message.remove ();

      }

      if ( message ) {

        let validity = elementObj.isValid ? this.options.classes.valid : this.options.classes.invalid,
            msgHtml = _.isString ( message )
                        ? this._template ( 'message', { message: message, validity: validity } )
                        : message.length === 1
                          ? this._template ( 'message', { message: message[0], validity: validity } )
                          : this._template ( 'messages', { messages: message, validity: validity } );

        elementObj.$message = $(msgHtml);

        if ( this.$output.length ) {

          this.$output.append ( elementObj.$message );

        } else {

          elementObj.$wrapper.after ( elementObj.$message );

        }

      } else {

        elementObj.$message = false;

      }

    }

    /* API */

    isValid () {

      if ( _.isUndefined ( this._isValid ) ) {

        for ( let id in this.elements ) {

          if ( !this.elements.hasOwnProperty ( id ) ) continue;

          let elementObj = this.elements[id];

          if ( _.isUndefined ( elementObj.isValid ) ) {

            this._validateWorker ( elementObj );

          }

          if ( !elementObj.isValid ) {

            this._isValid = false;

          }

        }

        if ( _.isUndefined ( this._isValid ) ) {

          this._isValid = true;

        }

      }

      return this._isValid;

    }

  }

  /* FACTORY */

  Factory.make ( FormValidate, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Validator ));


// @require core/keyboard/keyboard.js
// @require widgets/icon/icon.js
// @require widgets/toast/toast.js

//FIXME: Auto focus on the partial input doesn't work good on mobile, the keyboard keeps opening and closing

(function ( $, _, Svelto, Factory, Colors, Icon, Sizes, Pointer, Keyboard ) {

  /* CONFIG */

  let config = {
    name: 'tagbox',
    plugin: true,
    selector: '.tagbox',
    templates: {
      tag: _.template ( `
        <div class="label tagbox-tag <%= o.color %> <%= o.size %> <%= o.css %>" data-tag-value="<%= o.value %>">
          <span><%= o.value %></span>
          <i class="icon <%= Svelto.Sizes.xsmall %> actionable tagbox-tag-remover"><%= Svelto.Icon ( 'close' ) %></i>
        </div>
      ` )
    },
    options: {
      init: '', // Initial value
      tags: [],
      tag: {
        minLength: 3,
        color: Colors.gray,
        size: '',
        css: 'circular'
      },
      characters: {
        forbid: true, // Forbid or not
        forbidden: [ '<', '>', ';', '`' ],
        separator: ',', // It will also become kind of a forbidden character, used for insertion
        inserters: [Keyboard.keys.ENTER, Keyboard.keys.TAB] // They are keyCodes
      },
      addOnBlur: true, // Treat a blur event like a submit event
      editBackspace: true, // Enable editing the last tag when pressing backspace with an empty input
      sort: false, // The tags will be outputted in alphanumeric-sort order
      escape: false, // Escape potential XSS characters
      deburr: false, // Replace non basic-latin characters
      messages: {
        tooShort: '`$1` is shorter than $2 characters',
        duplicate: '`$1` is a duplicate',
        forbidden: 'The character you entered is forbidden'
      },
      datas: {
        value: 'tag-value'
      },
      selectors: {
        input: 'input.hidden',
        partial: 'input.tagbox-partial, .tagbox-partial input',
        tags: '.tagbox-tags',
        tag: '.tagbox-tag',
        tagLabel: 'span',
        tagRemover: '.tagbox-tag-remover'
      },
      callbacks: {
        change: _.noop,
        add: _.noop,
        remove: _.noop,
        empty: _.noop
      }
    }
  };

  /* TAGBOX */

  class Tagbox extends Svelto.Widget {

    /* SPECIAL */

    _variables () {

      this.$tagbox = this.$element;
      this.$tags = this.$tagbox.find ( this.options.selectors.tags );
      this.$input = this.$tagbox.find ( this.options.selectors.input );
      this.$partial = this.$tagbox.find ( this.options.selectors.partial );
      this.partial = this.$partial[0];

    }

    _init ( suppressTriggers ) {

      /* REMOVE PREVIOUS */

      this.$tagbox.find ( this.options.selectors.tag ).remove ();

      /* OPTIONS */

      this.options.init = this.$input.val () || this.options.init;

      /* POPULATING */

      this.add ( this.options.init, suppressTriggers );

    }

    _events () {

      this.___partial ();

      this.___tapOnEmpty ();
      this.___tapOnTagRemover ();

    }

    /* PRIVATE */

    _sanitizeTag ( value ) {

      value = value.trim ();

      if ( this.options.escape ) {

        value = _.escape ( value );

      }

      if ( this.options.deburr ) {

        value = _.deburr ( value );

      }

      return value;

    }

    _getTagHtml ( value ) {

      return this._template ( 'tag', _.extend ( { value: value }, this.options.tag ) );

    }

    _clearPartial () {

      this.$partial.val ( '' ).trigger ( 'change' );

    }

    /* UPDATE */

    _updateInput () {

      this.$input.val ( this.options.tags.join ( this.options.characters.separator ) ).trigger ( 'change' );

    }

    /* TAG */

    _add ( value ) {

      let valueTrimmed = value.trim ();

      value = this._sanitizeTag ( value );

      if ( valueTrimmed.length < this.options.tag.minLength ) {

        if ( valueTrimmed.length ) { // So it won't be triggered when the user presses enter and the $partial is empty

          $.toast ( _.format ( this.options.messages.tooShort, value, this.options.tag.minLength ) );

        }

      } else if ( this.options.tags.includes ( value ) ) {

        $.toast ( _.format ( this.options.messages.duplicate, value ) );

      } else {

        this.options.tags.push ( value );

        if ( this.options.sort ) {

          this.options.tags.sort ();

        }

        let tagHtml = this._getTagHtml ( value );

        if ( this.options.tags.length === 1 ) {

          this.$tags.prepend ( tagHtml );

        } else if ( !this.options.sort ) {

          this.$tagbox.find ( this.options.selectors.tag ).last ().after ( tagHtml );

        } else {

          let index = this.options.tags.indexOf ( value );

          if ( index === 0 ) {

            this.$tagbox.find ( this.options.selectors.tag ).first ().before ( tagHtml );

          } else {

            this.$tagbox.find ( this.options.selectors.tag ).eq ( index - 1 ).after ( tagHtml );

          }

        }

        return true;

      }

      return false;

    }

    _remove ( $tag, tag ) {

      $tag.remove ();

      _.pull ( this.options.tags, tag );

    }

    /* PARTIAL */

    ___partial () {

      this._on ( this.$partial, 'keypress keydown', this.__keypressKeydown ); // `keypress` is for printable characters, `keydown` for the others

      this._on ( this.$partial, 'paste', this.__paste );

      if ( this.options.addOnBlur ) this._on ( this.$partial, 'blur', this.___blur );

    }

    /* KEYPRESS / KEYDOWN */

    __keypressKeydown ( event ) {

      let isShortcut = event.ctrlKey || event.metaKey || event.altKey || event.shiftKey;

      if ( isShortcut ) return;

      let value = this.$partial.val ();

      if ( this.options.characters.inserters.includes ( event.keyCode ) || event.keyCode === this.options.characters.separator.charCodeAt ( 0 ) ) {

        let added = this.add ( value );

        if ( added ) {

          this._clearPartial ();

        }

        event.preventDefault ();
        event.stopImmediatePropagation ();

      } else if ( event.keyCode === Keyboard.keys.BACKSPACE ) {

        if ( this.options.editBackspace && !value.length && this.options.tags.length ) {

          let $tag = this.$tagbox.find ( this.options.selectors.tag ).last ();

          if ( $tag.length ) {

            let edit = !Keyboard.keystroke.hasCtrlOrCmd ( event );

            this.remove ( $tag, edit );

            event.preventDefault ();
            event.stopImmediatePropagation ();

          }

        }

      } else if ( this.options.characters.forbid && this.options.characters.forbidden.includes ( String.fromCharCode ( event.keyCode ) ) ) {

        $.toast ( this.options.messages.forbidden );

        event.preventDefault ();
        event.stopImmediatePropagation ();

      }

    }

    /* PASTE */

    __paste ( event ) {

      let originalEvent = event.originalEvent || event;

      this.add ( originalEvent.clipboardData.getData ( 'text' ) );

      event.preventDefault ();
      event.stopImmediatePropagation ();

    }

    /* BLUR */

    ___blur ( event ) {

      let value = this.$partial.val ();

      if ( !value ) return;

      let added = this.add ( value );

      if ( added ) this._clearPartial ();

    }

    /* TAP ON TAG REMOVER */

    ___tapOnTagRemover () {

      this._on ( Pointer.tap, this.options.selectors.tagRemover, this.__tapOnTagRemover );

    }

    __tapOnTagRemover ( event ) {

      event.stopImmediatePropagation ();

      let $tag = $(event.target).closest ( this.options.selectors.tag );

      this.remove ( $tag );

    }

    /* TAP ON EMPTY */

    ___tapOnEmpty () {

      this._on ( Pointer.tap, this.__tapOnEmpty );

    }

    __tapOnEmpty ( event ) {

      if ( !$.isFocused ( this.partial ) && !$(event.target).is ( this.options.selectors.partial + ',' + this.options.selectors.tagLabel ) ) {

        this.partial.focus ();

      }

    }

    /* API */

    get () {

      return _.cloneDeep ( this.options.tags );

    }

    add ( tag, suppressTriggers ) { // The tag can be a string containing a single tag, multiple tags separated by `this.options.characters.separator`, or it can be an array (nested or not) of those strings

      if ( _.isArray ( tag ) ) {

        tag = _.flatten ( tag ).join ( this.options.characters.separator );

      }

      let tags = tag.split ( this.options.characters.separator ),
          adds = tags.map ( tag => this._add ( tag ) );

      let added = !!adds.find ( _.identity );

      if ( added ) {

        this._updateInput ();

        if ( !suppressTriggers ) {

          this._trigger ( 'change' );

          let addedTags = tags.filter ( ( tag, index ) => adds[index] );

          this._trigger ( 'add', addedTags );

        }

      }

      return added;

    }

    remove ( tag, edit, suppressTriggers ) { // The tag can be a string containing a single tag, multiple tags separated by `this.options.characters.separator`, or it can be an array (nested or not) of those strings. In addition it can also be the jQuery object of that tag.

      let $tags = [],
          tags = [];

      if ( tag instanceof $ ) {

        $tags = [tag];
        tags = [tag.data ( this.options.datas.value )];

      } else {

        if ( _.isArray ( tag ) ) {

          tag = _.flatten ( tag ).join ( this.options.characters.separator );

        }

        tag = tag.split ( this.options.characters.separator );

        for ( let i = 0, l = tag.length; i < l; i++ ) {

          let value = this._sanitizeTag ( tag[i] ),
              $tag = this.$tagbox.find ( this.options.selectors.tag + '[data-' + this.options.datas.value + '="' + value.replace ( /"/g, '\\"' ) + '"]' );

          if ( $tag.length === 1 ) {

            $tags.push ( $tag );
            tags.push ( value );

          }

        }

      }

      if ( tags.length ) {

        for ( let i = 0, l = tags.length; i < l; i++ ) {

          this._remove ( $tags[i], tags[i] );

        }

        this._updateInput ();

        if ( tags.length === 1 && edit === true ) {

          this.$partial.val ( tags[0] ).trigger ( 'change' );

        }

        if ( !suppressTriggers ) {

          this._trigger ( 'change' );

          this._trigger ( 'remove', tags );

          if ( !this.options.tags.length ) {

            this._trigger ( 'empty' );

          }

        }

      }

    }

    clear ( suppressTriggers ) {

      if ( this.options.tags.length ) {

        let previous = this.options.tags;

        this.options.tags = [];

        this.$tagbox.find ( this.options.selectors.tag ).remove ();

        this._clearPartial ();

        this._updateInput ();

        if ( !suppressTriggers ) {

          this._trigger ( 'change' );

          this._trigger ( 'remove', previous );

          this._trigger ( 'empty' );

        }

      }

    }

    reset () {

      let previous = this.options.tags;

      this.clear ( true );

      this._init ( true );

      if ( !_.isEqualJSON ( previous, this.options.tags ) ) {

        this._trigger ( 'change' );

        let added = _.difference ( this.options.tags, previous );

        if ( added.length ) {

          this._trigger ( 'add', added );

        }

        let removed = _.difference ( previous, this.options.tags );

        if ( removed.length ) {

          this._trigger ( 'remove', removed );

        }

        if ( !this.options.tags.length ) {

          this._trigger ( 'empty' );

        }

      }

    }

  }

  /* FACTORY */

  Factory.make ( Tagbox, config );

}( Svelto.$, Svelto._, Svelto, Svelto.Factory, Svelto.Colors, Svelto.Icon, Svelto.Sizes, Svelto.Pointer, Svelto.Keyboard ));


_.merge ( Svelto.Widgets.Tagbox.config, {
  templates: {
    tag: _.template ( `
      <div class="label tagbox-tag <%= o.color %> <%= o.size %> <%= o.css %>" data-tag-value="<%= o.value %>">
        <span><%= o.value %></span>
        <i class="icon <%= Svelto.Sizes.small %> actionable tagbox-tag-remover">close</i>
      </div>
    ` )
  },
  options: {
    tag: {
      minLength: 1,
      size: 'xsmall',
      css: 'circular'
    },
    addOnBlur: false,
    sort: false
  }
});


// @require ./toast.js

(function ( $, _, Svelto, Toast ) {

  /* HELPER */

  $.toast = function ( options = {} ) {

    /* OPTIONS */

    options = _.isPlainObject ( options ) ? options : { body: String ( options ) };

    /* TYPE */

    if ( options.buttons ) {

      options.type = 'action';

    }

    /* TOAST */

    return Toast.whenReady.call ( Toast, () => new Toast ( options ) );

  };

}( Svelto.$, Svelto._, Svelto, Svelto.Widgets.Toast ));


// @priority -1000000000
// @require core/modernizr/modernizr.js

(function ( Modernizr ) {

  /* READY */

  Modernizr.addTest ( 'ready', true );

}( window.Modernizr ));
